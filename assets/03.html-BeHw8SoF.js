import{aq as s,ar as a,as as p,at as e}from"./app-Cok9BT0p.js";const t={};function l(i,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="api技术核心原理" tabindex="-1"><a class="header-anchor" href="#api技术核心原理"><span>API技术核心原理</span></a></h1><h2 id="_1-api-是啥" tabindex="-1"><a class="header-anchor" href="#_1-api-是啥"><span>1. API 是啥</span></a></h2><p>API（Application Programming Interface，应用程序编程接口）是一组预先定义好的​​规则、协议和工具​​，它允许不同的软件应用程序之间相互通信和交换数据。</p><ul><li><p>​​Application（应用）​​：指任何有特定功能的软件。</p></li><li><p>​​​Programming（编程）​​：开发人员需要使用它来编写代码。</p></li><li><p>​​​Interface（接口）​​：它是两个系统之间相互交互的“契约”或连接点。</p></li></ul><h2 id="_2-传统风格接口" tabindex="-1"><a class="header-anchor" href="#_2-传统风格接口"><span>2. 传统风格接口</span></a></h2><p>通常指的是 ​​RPC (Remote Procedure Call, 远程过程调用)​​ 或 ​​SOAP (Simple Object Access Protocol)​​ 风格的接口。</p><ol><li><p>核心思想​​：</p><p>像​​调用本地函数/方法​​一样调用远程服务。接口设计是​​动作导向 (Action-Oriented)​​ 的。</p></li><li><p>特点​​：</p><ul><li><p>​​URL 设计​​：URL 路径通常包含​​动词​​，表示要执行的操作。</p><p>例如：/getUser, /createProduct, /deleteOrder</p></li><li><p>操作方式​​：通常只使用 ​​GET​​ 和 ​​POST​​ 这两种 HTTP 方法。真正的操作意图（是获取、创建还是删除）隐藏在 URL 或请求体里。</p></li><li><p>状态管理​​：可能会使用 ​​Session​​ 或 ​​Cookie​​ 来维护用户会话状态，服务器需要记住客户端的状态（是“有状态的”）。</p></li><li><p>​数据格式​​：SOAP 严格使用 XML，格式非常重，规范复杂。</p></li></ul></li><li><p>举个例子：一个传统的用户管理接口​​</p><ul><li>GET /getUser?id=123（获取用户）</li><li>POST /createUser（在请求体中传递用户JSON数据来创建用户）</li><li>POST /updateUser（更新用户）</li><li>GET /deleteUser?id=123（删除用户）</li></ul></li></ol><h2 id="_3-rest-与-restful" tabindex="-1"><a class="header-anchor" href="#_3-rest-与-restful"><span>3. REST 与 Restful</span></a></h2><ol><li><p>rest 与 restful 区别</p><p>首先，​​REST​​ 和 ​​RESTful​​ 在绝大多数语境下可以互换使用，细微区别在于：</p><ul><li><p>​​REST​​：是一种架构风格（Architectural Style），由 Roy Fielding 博士在其论文中提出的一套​​设计原则和约束​​的集合。它是一种理论。</p></li><li><p>RESTful​​：意思是“符合 REST 原则的”。我们说一个接口是 ​​RESTful​​ 的，是指它的实现遵守了 REST 的准则。它是一种实践。</p></li></ul></li><li><p>RESTful 的核心思想与约束</p><p>其核心思想是​​资源导向 (Resource-Oriented)​​。将所有事物视为网络上的​​资源​​，并使用统一的接口（HTTP方法）来操作它们。</p><p>​​核心原则包括：​​</p><ol><li><p>​资源 (Resource)​​：一切皆资源。用户、订单、商品都是资源。每个资源都有一个唯一的标识符（URI）。</p><p>URI 示例：/users/123（ID为123的用户资源）</p></li><li><p>统一接口 (Uniform Interface)​​：这是 REST 最重要的特征，主要体现为：</p><ul><li><p>使用标准的 HTTP 方法​​ 来对资源执行 ​​CRUD​​ (Create, Read, Update, Delete) 操作：</p><ul><li>​​GET​​： ​​获取/查询​​ 资源（Safe &amp; Idempotent 安全且幂等）</li><li>POST​​： ​​创建​​ 新资源（Non-Idempotent 非幂等）</li><li>​PUT​​： ​​完整更新​​ 资源（Idempotent 幂等）</li><li>PATCH​​： ​​部分更新​​ 资源（Non-Idempotent 或 Idempotent）</li><li>DELETE​​： ​​删除​​ 资源（Idempotent 幂等）</li></ul></li><li><p>同一个资源地址（URI），通过不同的方法来实现不同的功能。</p></li></ul></li><li><p>​无状态 (Stateless)​​：服务器不会保存客户端的任何会话状态。每次请求都必须包含处理该请求所需的所有信息（如认证令牌、参数等）。会话状态完全由客户端负责维护。</p></li><li><p>可缓存 (Cachable)​​：响应应该被明确标记为可缓存或不可缓存，以提高网络效率。</p></li></ol></li><li><p>​​举个例子：一个 RESTful 的用户管理接口​​</p><ul><li>GET /users/123-&gt; ​​获取​​ ID为123的用户</li><li>POST /users-&gt; ​​创建​​ 一个新用户（请求体中包含用户信息）</li><li>PUT /users/123-&gt; ​​完整更新​​ ID为123的用户信息（请求体中包含完整的用户信息）</li><li>PATCH /users/123-&gt; ​​部分更新​​ ID为123的用户信息（如只更新邮箱）</li><li>DELETE /users/123-&gt; ​​删除​​ ID为123的用户</li></ul></li></ol><h2 id="_4-graphql" tabindex="-1"><a class="header-anchor" href="#_4-graphql"><span>4. GraphQL</span></a></h2><p>GraphQL 是一种用于 API 的查询语言和运行时环境。它允许客户端精确地指定它需要什么数据，服务器则会返回 对应数据，不多也不少。​</p><p>一个完整的 GraphQL 接口由以下几个关键部分构成：</p><ol><li><p>​​Schema（模式）​​：这是 GraphQL 服务的​​核心契约和蓝图​​。它使用强类型系统定义了：</p><ul><li><p>​对象类型 (Object Types)​​：例如 User、Post，描述了数据的形状。</p></li><li><p>查询类型 (Query Type)​​：定义了所有客户端可以执行的查询操作（根字段）。</p></li><li><p>变更类型 (Mutation Type)​​：定义了所有客户端可以执行的变更操作（根字段）。</p></li><li><p>订阅类型 (Subscription Type)​​：定义了所有可以订阅的事件。</p></li></ul><p>它就像是服务器提供给客户端的​​一份详细菜单​​，写明了可以点什么菜（查询什么），以及每道菜里有什么配料（返回哪些字段）。</p></li><li><p>解析器 (Resolvers)​​：Schema 只定义了“是什么”，而​​解析器则定义了“怎么做”​​。每个字段（无论是根字段还是子字段）都有一个对应的解析器函数。当客户端请求某个字段时，服务器就会调用这个函数来获取数据。解析器是连接 GraphQL 引擎和你底层数据源（数据库、微服务、REST API 等）的桥梁。</p></li><li><p>​​类型系统 (Type System)​​：GraphQL 是强类型的。每个字段都有明确的类型，如 String, Int, Boolean，或是自定义类型如 User。这确保了查询的合法性，并在执行前就能提供强大的​​错误检查和编辑器智能提示​​。</p></li></ol><h2 id="_5-grpc" tabindex="-1"><a class="header-anchor" href="#_5-grpc"><span>5. grpc</span></a></h2><p>好的，我们来深入探讨一下 ​​gRPC 接口​​。这是一个非常核心的现代后端通信技术。</p><ol><li><p>契约优先与 Protocol Buffers (Protobuf)</p><p>这是 gRPC 的基石。你不是直接写代码，而是先在一个 ​​.proto文件​​中严格定义​​服务接口​​和​​数据结构​​。</p><ul><li>​​service​​：定义一个服务，里面包含多个可远程调用的方法（函数）。</li><li>message​​：定义结构化数据，类似于 JSON 对象或编程语言中的类/结构体。</li><li>rpc​​：在服务内部定义具体的远程方法。</li></ul><p><strong>示例 (helloworld.proto)</strong>：​​</p><div class="language-proto line-numbers-mode" data-highlighter="prismjs" data-ext="proto"><pre><code><span class="line">// 指定语法版本和包名</span>
<span class="line">syntax = &quot;proto3&quot;;</span>
<span class="line">package helloworld;</span>
<span class="line"></span>
<span class="line">// 定义请求和响应消息的结构</span>
<span class="line">message HelloRequest {</span>
<span class="line">    string name = 1; // 字段编号，非值</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">message HelloReply {</span>
<span class="line">    string message = 1;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 定义服务</span>
<span class="line">service Greeter {</span>
<span class="line">    // 定义一个RPC方法，接收HelloRequest，返回HelloReply</span>
<span class="line">    rpc SayHello (HelloRequest) returns (HelloReply) {}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>强大的代码生成</p><p>.proto文件是语言无关的。你可以使用 ​​Protobuf 编译器 (protoc)​​ 配合不同语言的插件（如 grpc-go，grpc-java），​​自动生成​​客户端存根（Stub）和服务端骨架（Skeleton）代码。</p><ul><li>服务端​​：你只需要继承生成的服务端基类，并实现具体的业务逻辑（如 SayHello方法）。</li><li>客户端​​：你只需要像调用本地对象一样调用生成的客户端对象的方法。</li></ul><p>这消除了手动编写样板代码（如网络传输、序列化/反序列化）的需要，并保证了接口的一致性。</p></li><li><p>基于 HTTP/2</p><p>gRPC 不像 REST 那样使用 HTTP/1.1，而是使用 ​​HTTP/2​​ 作为底层传输协议。这带来了巨大优势：</p><ul><li><p>二进制协议​​：头部和载荷都采用二进制格式，更紧凑、高效。</p></li><li><p>多路复用 (Multiplexing)​​：多个请求可以在同一个 TCP 连接上同时进行，避免了 HTTP/1.1 的队头阻塞问题，极大减少了连接开销。</p></li><li><p>服务器推送 (Server Push)​​：服务器可以主动向客户端推送数据（虽然 gRPC 自身实现方式不同）。</p></li><li><p>流式处理​​：天然支持四种流式模式。</p></li></ul></li><li><p>四种通信模式</p><p>gRPC 接口支持灵活的交互模式，远超简单的请求-响应：</p><ul><li><p>一元 RPC (Unary RPC)​​：最普通的模式，客户端发送一个请求，服务器返回一个响应。</p><div class="language-rpc line-numbers-mode" data-highlighter="prismjs" data-ext="rpc"><pre><code><span class="line">rpc SayHello (HelloRequest) returns (HelloReply) {}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>​​服务器流式 RPC (Server streaming RPC)​​：客户端发送一个请求，服务器返回一个流式的响应序列（例如，发送股票价格更新）。</p><div class="language-rpc line-numbers-mode" data-highlighter="prismjs" data-ext="rpc"><pre><code><span class="line">rpc LotsOfReplies (HelloRequest) returns (stream HelloReply) {}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>客户端流式 RPC (Client streaming RPC)​​：客户端发送一个流式的请求序列，服务器返回一个单一的响应（例如，客户端上传一系列测量读数，服务器返回一个汇总报告）。</p><div class="language-rpc line-numbers-mode" data-highlighter="prismjs" data-ext="rpc"><pre><code><span class="line">rpc LotsOfGreetings (stream HelloRequest) returns (HelloReply) {}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>​​双向流式 RPC (Bidirectional streaming RPC)​​：双方都使用一个独立的流来发送一系列消息（例如，一个实时聊天应用）。</p><div class="language-rpc line-numbers-mode" data-highlighter="prismjs" data-ext="rpc"><pre><code><span class="line">rpc BidiHello (stream HelloRequest) returns (stream HelloReply) {}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ol><h2 id="_6-trpc" tabindex="-1"><a class="header-anchor" href="#_6-trpc"><span>6. trpc</span></a></h2><ol><li><p>与 gRPC 的“契约优先”或 REST 的“文档优先”不同，tRPC 的核心哲学是 ​​“类型即契约”​​。</p><ul><li><p>传统方式​​：你需要额外维护一份接口契约（如 .proto文件或 OpenAPI/Swagger 文档），然后根据这份契约分别编写和调试前后端代码。契约和代码是分离的，容易不同步。</p></li><li><p>tRPC 方式​​：你的​​后端 TypeScript 代码本身就是契约​​。你编写一个普通的 TypeScript 函数，tRPC 通过其类型系统自动推断出这个函数的输入和输出类型，并让前端能安全地调用它。​​契约和代码是一体的​​，从根本上杜绝了前后端接口不一致的问题。</p></li></ul></li><li><p>定义路由器 (Router) 和过程 (Procedure)</p><p>在后端，你不需要定义 .proto文件，而是直接使用 tRPC 的辅助函数来创建路由器和 API 端点（在 tRPC 中称为 “Procedures”）。</p><p><strong>示例：后端​</strong> (server.ts)​</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token comment">// 1. 初始化 tRPC</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> initTRPC <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@trpc/server&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> z <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;zod&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 常用作输入验证库</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> t <span class="token operator">=</span> initTRPC<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 TRPC 实例</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 2. 创建路由器并定义 API 端点（Procedures）</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">const</span> appRouter <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">router</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line"><span class="token comment">// 定义一个名为 \`getUser\` 的查询 (Query)</span></span>
<span class="line"><span class="token literal-property property">getUser</span><span class="token operator">:</span> t<span class="token punctuation">.</span>procedure</span>
<span class="line">    <span class="token comment">// 使用 Zod 定义并验证输入</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> z<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// 定义查询实现，返回值类型会被自动推断</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">opts</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> input <span class="token punctuation">}</span> <span class="token operator">=</span> opts<span class="token punctuation">;</span> <span class="token comment">// input 的类型为 { id: string }</span></span>
<span class="line">    <span class="token comment">// 这里可以是数据库查询或其他逻辑</span></span>
<span class="line">    <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span>user<span class="token punctuation">.</span><span class="token function">findUnique</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">where</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> input<span class="token punctuation">.</span>id <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> user<span class="token punctuation">;</span> <span class="token comment">// TypeScript 知道 user 的类型，并会将其作为响应类型</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 定义一个名为 \`createUser\` 的变更 (Mutation)</span></span>
<span class="line"><span class="token literal-property property">createUser</span><span class="token operator">:</span> t<span class="token punctuation">.</span>procedure</span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> z<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">mutation</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">opts</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> input <span class="token punctuation">}</span> <span class="token operator">=</span> opts<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> newUser <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span>user<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> input<span class="token punctuation">.</span>name <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> newUser<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 导出路由器的类型，前端将直接使用它</span></span>
<span class="line"><span class="token keyword">export</span> type AppRouter <span class="token operator">=</span> <span class="token keyword">typeof</span> appRouter<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>集成到 Web 框架</p><p>tRPC 本身不是服务器，它需要与一个 Web 框架（如 Express、Next.js、Nuxt 等）适配。</p><p><strong>示例：在 Next.js API 路由中</strong> (pages/api/trpc/[trpc].ts)​​</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createNextApiHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@trpc/server/adapters/next&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> appRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../../../server/router&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 将 tRPC 路由器挂载到 \`/api/trpc\` 路径下</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">createNextApiHandler</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">router</span><span class="token operator">:</span> appRouter<span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在前端调用：魔法般的体验</p><p>这是 tRPC 最令人惊艳的部分。前端直接导入​​后端的路由器类型​​，创建一个类型安全的客户端。</p><p><strong>示例：前端</strong> (frontend.tsx)​​</p><div class="language-tsx line-numbers-mode" data-highlighter="prismjs" data-ext="tsx"><pre><code><span class="line"><span class="token comment">// 1. 导入来自后端的类型定义！</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> AppRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../server&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createTRPCProxyClient<span class="token punctuation">,</span> httpLink <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@trpc/client&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 2. 创建客户端，并传入后端路由器的类型作为泛型参数</span></span>
<span class="line"><span class="token keyword">const</span> trpc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createTRPCProxyClient</span><span class="token generic class-name"><span class="token operator">&lt;</span>AppRouter<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    links<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">httpLink</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token operator">:</span> <span class="token string">&#39;/api/trpc&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 3. 像调用本地函数一样进行调用，享受完整的类型安全和自动补全！</span></span>
<span class="line"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token comment">// ❌ 错误：TypeScript 会报错，因为 input 需要 { id: string }</span></span>
<span class="line"><span class="token comment">// const user = await trpc.getUser.query({ name: &quot;Alice&quot; });</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// ✅ 正确：完全的类型安全</span></span>
<span class="line"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> trpc<span class="token punctuation">.</span>getUser<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">&#39;1&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 现在 \`user\` 的类型就是后端 \`getUser\` 函数返回的 Promise 的解析值类型</span></span>
<span class="line"><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token operator">?.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自动补全！</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 调用变更 (mutation) 同样简单</span></span>
<span class="line"><span class="token keyword">const</span> newUser <span class="token operator">=</span> <span class="token keyword">await</span> trpc<span class="token punctuation">.</span>createUser<span class="token punctuation">.</span><span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;Alice&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newUser<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>`,18)]))}const o=s(t,[["render",l]]),r=JSON.parse('{"path":"/other/knowledge/common/03.html","title":"API技术核心原理","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1758492113000,"contributors":[{"name":"zhao-farmer","username":"zhao-farmer","email":"857899180@qq.com","commits":2,"url":"https://github.com/zhao-farmer"}],"changelog":[{"hash":"99c22db75003feb5447a5e9b7cef050f5faec996","time":1758492113000,"email":"857899180@qq.com","author":"zhao-farmer","message":"插件开发"},{"hash":"2c9ec28ff41db4bb3e8c363d6656a261f88b4c95","time":1757530254000,"email":"857899180@qq.com","author":"zhao-farmer","message":"react一些相关的"}]},"filePathRelative":"other/knowledge/common/03.md"}');export{o as comp,r as data};
