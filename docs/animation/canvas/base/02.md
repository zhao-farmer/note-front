
# 二、绘制图形

## 2.1 直线

### 2.1.1 canvas 知识

1. 坐标系

canvas使用W3C坐标系。  
原点左上角，x轴正方向向右，y轴正方向向下。

2. 操作方法 

moveTo()和lineTo()配合使用来画直线

```js
ctx.moveTo(x1, y1); //移动到起点
ctx.lineTo(x2, y2);	//连接到终点
ctx.stroke();	//开始绘制
```


### 2.1.2 直线的绘制

1.  一条直线

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
        // 画一条线
        ctx.moveTo(50, 200);
        ctx.lineTo(300, 50);
        ctx.stroke();
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/004.png" style="border:1px solid black">


2.  Z字线

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.moveTo(50, 50);
        ctx.lineTo(300, 50);
        
        ctx.lineTo(50, 300);//上个点（100, 50）为新的起点。
        
        //cxt.moveTo(50, 100);
        ctx.lineTo(300, 300);
        
        ctx.stroke();
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/005.png" style="border:1px solid black">




3. 三角形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.moveTo(50, 300);//首尾重合
        ctx.lineTo(400, 50);
        ctx.lineTo(50, 50);
        ctx.lineTo(50, 300);//首尾重合
        ctx.stroke();
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/006.png" style="border:1px solid black">


4. 矩形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.moveTo(50, 300);//首尾重合
        ctx.lineTo(50, 50);
        ctx.lineTo(400, 50);
        ctx.lineTo(400, 300);
        ctx.lineTo(50, 300);//首尾重合
        ctx.stroke();
      
    </script>
</body>
</html>
```
- canvas 图

<img src="/animation/canvas/base/image/007.png" style="border:1px solid black">


## 2.2 矩形

矩形分为描边矩形和填充矩形。

### 2.2.1 描边矩形

strokeStyle属性和strokeRect()方法画描边矩形。

```js
ctx.strokeStyle = 属性值;
cts.strokeRect(x, y, width, height);
```

1. strokeStyle属性  

3种取值：颜色值、渐变色和图案。

```js
ctx.strokeStyle = "#FF0000";
ctx.strokeStyle = "#F00";
ctx.strokeStyle = "red";
ctx.strokeStyle = "rgb(255, 0, 0)";
ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
```

2. strokeRect()方法  

先设置好strokeStyle属性，后使用strokeRect()方法。

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.strokeStyle = "red";
        ctx.strokeRect(50, 50, 200, 300);
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/008.png" style="border:1px solid black">


### 2.3.2 填充矩形

fillStyle属性和fillRect()方法画填充矩形。

```js
ctx.fillStyle = 属性值;
cts.fillRect(x, y, width, height);
```

1.  fillStyle属性  
    3种取值：颜色值、渐变色和图案。

```js
ctx.fillStyle= "#FF0000";
ctx.fillStyle= "#F00";
ctx.fillStyle= "red";
ctx.fillStyle= "rgb(255, 0, 0)";
ctx.fillStyle= "rgba(255, 0, 0, 0.8)";
```

2.  fillRect()方法  

先设置好fillStyle属性，后使用fillRect()方法。

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.fillStyle = "HotPink";
        ctx.fillRect(50, 50, 300, 200);
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/009.png" style="border:1px solid black">



3. 同时绘制描边矩形和填充矩形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.strokeStyle = "red";
        ctx.strokeRect(50, 50, 200, 200);
        
        ctx.fillStyle = "#FFE8E8";
        ctx.fillRect(50, 50, 200, 200);
      
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/010.png" style="border:1px solid black">


4.  两个重叠的填充矩形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.fillStyle = "HotPink";
        ctx.fillRect(80, 80, 200, 200);

        ctx.fillStyle = "rgba(0, 0, 255, 0.3)";
        ctx.fillRect(30, 30, 200, 200);
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/011.png" style="border:1px solid black">


### 2.3.3 rect()方法

```js
rect(x, y, width, height);
```

- strokeRect()和fillRect()调用后，立即绘制矩形。
- rect()调用后，再调用stroke()或fill()才会绘制矩形。

```js
ctx.rect(50, 50, 80, 80);
ctx.strokeStyle="red";
ctx.stroke();
//等价于
ctx.strokeStyle="red";
ctx.strokeRect(50, 50, 80, 80);
```

```js
ctx.rect(50, 50, 80, 80);
ctx.fillStyle="red";
ctx.fill();
//等价于
ctx.fillStyle="red";
ctx.fillRect(50, 50, 80, 80);
```

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        //绘制描边矩形
        ctx.rect(50, 50, 200, 200);
        ctx.strokeStyle = "red";
        ctx.stroke();

        //绘制填充矩形
        ctx.rect(50, 50, 200, 200);
        ctx.fillStyle = "#FFE8E8";
        ctx.fill();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/010.png" style="border:1px solid black">



### 2.3.4 清空矩形

```js
cxt.clearRect(x, y, width, height);
```

1. 清空指定区域

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
     
        ctx.fillStyle = "HotPink";
        ctx.fillRect(50, 50, 200, 200);
        
        ctx.clearRect(80, 80, 140, 140);
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/012.png" style="border:1px solid black">

2. 清空canvas


- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <br />
    <input id="btn1" type="button" value="画出图形" />
    <input id="btn2" type="button" value="清空canvas" />
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
        
        // 画图
        function darw(){
            ctx.fillStyle = "HotPink";
            ctx.fillRect(50, 50, 200, 250);

            ctx.strokeStyle = "red";
            ctx.strokeRect(80, 80, 300, 300);

            ctx.fillStyle = "rgba(0, 0, 255, 0.3)";
            ctx.fillRect(30, 30, 250, 200);
        }
        darw()

        btn1.onclick = function () {
            darw()
        }
     
        btn2.onclick = function () {
            ctx.clearRect(0, 0, c1.width, c1.height);
        }
    
    </script>
</body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/base/html/01.html" width="650" height="450"></iframe>

## 2.4 多边形

计算各顶点坐标，然后使用moveTo()和lineTo()绘制出来。

### 2.4.1 箭头

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
        
        // 绘制箭头
        ctx.moveTo(40, 60);
        ctx.lineTo(100, 60);
        ctx.lineTo(100, 30);
        ctx.lineTo(150, 75);
        ctx.lineTo(100, 120);
        ctx.lineTo(100, 90);
        ctx.lineTo(40, 90);
        ctx.lineTo(40, 60);
        ctx.stroke();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/013.png" style="border:1px solid black">


### 2.4.2 正多边形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');
        
         /*
         * n：表示n边形
         * centerX、centerY：表示n边形中心坐标
         * r：表示n边形的大小
         */
         function createPolygon(ctx, n, centerX, centerY, r) {
            ctx.beginPath();
            for (var i = 0; i < n; i++) {
                var x = Math.cos(2*Math.PI*i/n);
                var y = Math.sin(2*Math.PI*i/n);
                ctx.lineTo(centerX+r*x, centerY+r*y);
            }
            ctx.closePath();
        }


        // 绘制箭头
        var n = 7;
        var centerX = 100;
        var centerY = 100;
        var r = 80;
        createPolygon(ctx, n, centerX, centerY, r);//调用自定义的方法createPolygon()
        ctx.fillStyle = "HotPink";
        ctx.fill();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/014.png" style="border:1px solid black">


### 2.4.3 多角星

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        /*
			* n：表示n角星
			* centerX、centerY：表示n角星中心坐标
			* rMax：表示n角星外部圆的半径
			* rMin：表示n角星内部圆的半径
        */
        function createPolygonalStar(ctx, n, centerX, centerY, rMax, rMin) {
            ctx.beginPath();
            for (var i = 0; i < n; i++) {
                var xMax = rMax*Math.cos(2*Math.PI*i/n);
                var yMax = rMax*Math.sin(2*Math.PI*i/n);
                ctx.lineTo(centerX+xMax, centerY+yMax);
                
                var xMin = rMin*Math.cos(2*Math.PI*(i+0.5)/n);
                var yMin = rMin*Math.sin(2*Math.PI*(i+0.5)/n);
                ctx.lineTo(centerX+xMin, centerY+yMin);
            }
            ctx.closePath();
        }

        // 绘制箭头
        var n = 6;
        var centerX = c1.width/2;
        var centerY = c1.height/2;
        // 最大半径与最小半径 控制星星大的形状
        var rMax = 100;
        var rMin = 25;
        createPolygonalStar(ctx, n, centerX, centerY, rMax, rMin)
        ctx.closePath();
        ctx.stroke();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/015.png" style="border:1px solid black">


## 2.5 圆形

### 2.5.1 圆形简介

```js
cxt.beginPath();
cxt.arc(x, y, 半径, 开始角度, 结束角度, anticlockwise);
cxt.closePath();
```

开始角度和结束角度使用弧度，比如360\*Math.PI/180。  
anticlockwise默认false，顺时针方向。

### 2.5.2 描边圆

```js
cxt.beginPath();
cxt.arc(x, y, 半径, 开始角度, 结束角度, anticlockwise);
cxt.closePath();

cxt.strokeStyle = "颜色值";
cxt.stroke();
```

1. 圆

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        //整圆
        ctx.beginPath();
        ctx.arc(240, 160, 100, 0, 360 * Math.PI / 180);
        //ctx.closePath();
        //描边
        ctx.strokeStyle = "HotPink";
        ctx.stroke();
        
        //半圆
        ctx.beginPath();
        ctx.arc(160, 160, 100, 0, 180 * Math.PI / 180, true);
        ctx.closePath();
        //描边
        ctx.strokeStyle = "HotPink";
        ctx.stroke();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/016.png" style="border:1px solid black">



2. 弧形

- 代码


```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        ctx.beginPath();
        ctx.arc(140, 140, 100, 0, -90 * Math.PI / 180, true);
        ctx.closePath();
        ctx.strokeStyle = "HotPink";
        ctx.stroke();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/017.png" style="border:1px solid black">


### 2.5.3 填充圆

```js
cxt.beginPath();
cxt.arc(x, y, 半径, 开始角度, 结束角度, anticlockwise);
cxt.closePath();

cxt.fillStyle = "颜色值";
cxt.fill();
```

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        //整圆
        ctx.beginPath();
        ctx.arc(240, 160, 100, 0, 360 * Math.PI / 180);
        //ctx.closePath();
        //描边
        ctx.fillStyle = "#9966FF";
        ctx.fill();
        
        //半圆
        ctx.beginPath();
        ctx.arc(160, 160, 100, 0, 180 * Math.PI / 180, true);
        ctx.closePath();
        //描边
        ctx.fillStyle = "HotPink";
        ctx.fill();
    
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/018.png" style="border:1px solid black">


## 2.6 弧线

arc和arcTo()。

### 2.6.1 arc()方法画弧线

```js
cxt.beginPath();
cxt.arc(x, y, 半径, 开始角度, 结束角度, anticlockwise);

cxt.strokeStyle = "颜色值";
cxt.stroke();
```

anticlockwise默认false，顺时针方向。

1. 弧线

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        //整圆
        ctx.beginPath();
        ctx.arc(140, 140, 100, 0, -90 * Math.PI / 180, true);
        //ctx.closePath(); //闭合
        ctx.stroke();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/019.png" style="border:1px solid black">


2. 弧线+直线

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

         //绘制一条直线
        ctx.beginPath();
        ctx.moveTo(20, 20);
        ctx.lineTo(70, 20);
        ctx.stroke();

        //绘制圆弧+直线
        ctx.beginPath();
        ctx.arc(70, 70, 50, 0, -90 * Math.PI / 180, true);
        ctx.moveTo(120, 70);
        ctx.lineTo(120, 120);
        ctx.stroke();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/020.png" style="border:1px solid black">



### 2.6.2 arcTo()方法画弧线

```js
cxt.arcTo(cx, cy, x2, y2, radius)
```

*   cx, cy控制点坐标
*   x2，y2结束点坐标
*   x1，y1开始点坐标，moveTo()或lineTo()提供。  
    arcTo()利用开始点、控制点、结束点形成的夹角，绘制与一段与夹角两边相切且半径为radius的短的圆弧。当开始点不是圆弧起点时，会绘制开始点到圆弧起点的直线。
*   弧线
    

1. 弧线+直线

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        ctx.moveTo(20, 20);
        ctx.arcTo(120, 20, 120, 70, 50);
        ctx.lineTo(120, 120);
        ctx.stroke();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/020.png" style="border:1px solid black">


2. 圆角矩形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        ctx.moveTo(40, 20);
        ctx.lineTo(160, 20);
        ctx.arcTo(180, 20, 180, 40, 20);
        ctx.moveTo(180, 40);
        ctx.lineTo(180, 110);
        ctx.arcTo(180, 130, 160, 130, 20);
        ctx.moveTo(160, 130);
        ctx.lineTo(40, 130);
        ctx.arcTo(20, 130, 20, 110, 20);
        ctx.moveTo(20, 110);
        ctx.lineTo(20, 40);
        ctx.arcTo(20, 20, 40, 20, 20);
        ctx.stroke();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/021.png" style="border:1px solid black">

3. 圆角矩形函数封装

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

          /*
            * createRoundedRect()用于绘制圆角矩形
            * width、height：分别表示长和宽
            * r：表示圆角半径
            * offsetX、offsetY：分别表示左上角顶点坐标
         */
         function createRoundedRect(ctx, width, height, r, offsetX, offsetY) {
            ctx.beginPath();
            ctx.moveTo(offsetX + r, offsetY);
            //ctx.lineTo(offsetX + width - r, offsetY);
            ctx.arcTo(offsetX + width, offsetY, offsetY + width, offsetY + r, r);
            //ctx.lineTo(offsetX + width, offsetY + height - r);
            ctx.arcTo(offsetX + width, offsetY + height, offsetX + width - r, offsetY + height, r);
            //ctx.lineTo(offsetX + r, offsetY + height);
            ctx.arcTo(offsetX, offsetY + height, offsetX, offsetY + height - r, r);
            //ctx.lineTo(offsetX, offsetY + r);
            ctx.arcTo(offsetX, offsetY, offsetX + r, offsetY, r);
            //ctx.closePath();
        }

        createRoundedRect(ctx, 100, 100, 20, 20, 20);
        ctx.fillStyle = "HotPink";
        ctx.fill();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/022.png" style="border:1px solid black">



## 2.7 绘制扇形

1. 扇形

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        ctx.beginPath();
        ctx.moveTo(100, 75);
        ctx.arc(c1.width/2, c1.height/2, 100, 30*Math.PI/180, 120*Math.PI/180, false);
        ctx.closePath();
        ctx.strokeStyle = "HotPink";
        ctx.stroke();

    </script>
</body>
</html>
```


- canvas 图

<img src="/animation/canvas/base/image/023.png" style="border:1px solid black">



2. 扇形函数封装

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        function createSector(ctx, x, y, r, angle1, angle2) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.arc(x, y, r, angle1*Math.PI/180, angle2*Math.PI/180, false);
            ctx.closePath();
        }

        createSector(ctx, c1.width/2, c1.height/2, 200, 30, 120);
        ctx.fillStyle = "HotPink";
        ctx.fill();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/024.png" style="border:1px solid black">



## 2.8 椭圆


```js
context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
```

参数：

- x: 椭圆弧对应的圆心横坐标。
- y: 椭圆弧对应的圆心纵坐标。
- radiusX: 椭圆弧的长轴半径大小。
- radiusY: 椭圆弧的短轴半径大小。
- rotation: 椭圆弧的旋转角度，单位是弧度。
- startAngle: 圆弧开始的角度，角度从横轴开始算，单位是弧度。
- endAngleN: 圆弧结束的角度，单位是弧度。
- anticlockwise（可选）: 弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为true，则表示按照逆时针方向从startAngle绘制到endAngle。

### 2.8.1 椭圆基础

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="200"></canvas>

        <script>
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");

            ctx.beginPath();
            // 参数依次为：x坐标，y坐标，椭圆的水平半径，椭圆的垂直半径，旋转角度，起始角，结束角
            ctx.ellipse(200, 100, 100, 50, 0, 0, Math.PI * 2); 
            ctx.stroke(); // 或者 ctx.fill();
        </script>
    </body>
</html>
```
- canvas 图

<img src="/animation/canvas/base/image/025.png" style="border:1px solid black">


## 2.8.2 椭圆圆环

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');


        // 外层椭圆
        ctx.beginPath();
        ctx.ellipse(200, 100, 100, 60, 0, 0, 2 * Math.PI);  
        ctx.strokeStyle = "#666";
        ctx.stroke();

        // 内层椭圆填充
        ctx.beginPath();
        ctx.ellipse(200, 100, 70, 40, 0, 0, 2 * Math.PI);
        ctx.fillStyle = "#ffeb3b";
        ctx.fill();  // 组合椭圆形成环形效果

    </script>
</body>
</html>
```
- canvas 图

<img src="/animation/canvas/base/image/026.png" style="border:1px solid black">


## 2.9 二次贝塞尔曲线

![](/animation/canvas/base/image/027.gif)

```js
cxt.quadraticCurveTo(cx, cy, x2, y2);
```

cx，cy控制点坐标，x2，y2结束点坐标。  
moveTo()或lineTo()提供开始点。


1. 基础应用

- 代码

```js
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8"/>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        var c1 = document.getElementById("canvas");
        var ctx = c1.getContext('2d');

        ctx.moveTo(30, 120);
        ctx.quadraticCurveTo(100, 20, 360, 240);
        ctx.stroke();

    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/028.png" style="border:1px solid black">



2. 二次贝塞尔曲线画气泡

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
        ctx.beginPath()

        //起始点
        ctx.moveTo(200,300);
        //两个控制点 一个终点 六个参数
        ctx.quadraticCurveTo(150,300,150,200)
        ctx.quadraticCurveTo(150,100,300,100)
        ctx.quadraticCurveTo(450,100,450,200)
        ctx.quadraticCurveTo(450,300,250,300)
        //尾巴
        ctx.quadraticCurveTo(250,350,150,350)
        ctx.quadraticCurveTo(200,350,200,300)
        ctx.stroke()
        ctx.closePath()
     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/029.png" style="border:1px solid black">


## 2.10 三次贝塞尔曲线

![](/animation/canvas/base/image/030.gif)

```js
cxt.bezierCurveTo(cx1, cy1, cx2, cy2,x2, y2);
```

cx1，cy1控制点1坐标，cx2，cy2控制点2坐标，x2，y2结束点坐标。  
moveTo()或lineTo()提供开始点。

1. 基础应用

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
         //绘制三次贝塞尔曲线
        ctx.moveTo(40, 160);
        ctx.bezierCurveTo(40, 40, 240, 240, 240, 120);
        ctx.stroke();
     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/031.png" style="border:1px solid black">

2. 三次贝塞尔曲线画心形

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
        // 六段♥
        ctx.moveTo(75, 40);
        ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
        ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
        ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
        ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
        ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
        ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
        ctx.stroke();


        // 二段♥
        ctx.beginPath()
        ctx.moveTo(300,200);
        //起点 两个控制点一个终点
        ctx.bezierCurveTo(350,150,400,200,300,280)
        ctx.bezierCurveTo(200,200,250,150,300,200)
        ctx.stroke()
        ctx.closePath()
     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/032.png" style="border:1px solid black">

3. 贝塞尔曲线画N叶草

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
         /*
            * createLeaf()用于绘制N叶草
            * n：n片
            * centerX、centerY：花朵中心位置的坐标
            * rMin：控制花朵的大小
            * rMax：控制花瓣长度
         */
         function createLeaf(ctx, n, centerX, centerY, rMin, rMax) {
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + rMin);
            var degree = 2*Math.PI/n;
            for (var i = 1; i < n + 1; i++) {
                //计算控制点坐标
                var cx1 = centerX + rMax * Math.sin((i - 1) * degree);
                var cy1 = centerY + rMax * Math.cos((i - 1) * degree);
                var cx2 = centerX + rMax * Math.sin(i * degree);
                var cy2 = centerY + rMax * Math.cos(i * degree);
                //计算结束点的坐标
                var x = centerX + rMin * Math.sin(i * degree);
                var y = centerY + rMin * Math.cos(i * degree);
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
            }
            ctx.closePath();
        }


        var n = 5;
        var rMin = 20*0.4;
        var rMax = 80*1.5;
        createLeaf(ctx, n, c1.width/2, c1.height/2, rMin, rMax);
        ctx.fillStyle = "#00FF99";//浅绿色
        ctx.fill();

     </script>
</body>
</html>

```

- canvas 图

<img src="/animation/canvas/base/image/033.png" style="border:1px solid black">


>这里，我们在一条路径中连续定义首尾相连的多段贝塞尔曲线，其中每段三次贝塞尔曲线的起点和终点都落在圆心为（centerX, centerY）、半径为rMin的圆上，而每段圆弧的两个控制点落在圆心为（centerX, centerY）、半径为rMax的圆上，于是形成了N叶草的图形。其中，起点、终点和控制点坐标是使用正弦和余弦函数计算出来的。总的来说，使用二次或三次贝塞尔曲线来绘制一个图形是相当有挑战的，因为这不像在矢量绘图软件Adobe Illustrator（简称AI）里那样有即时的视觉反馈（所见即所得）。所以用它来画复杂图形比较麻烦。但是从理论上来说，任何复杂的图形都可以用贝塞尔曲线绘制出来！这也是贝塞尔曲线强大之处。

## 2.11 Path2D

Path2D 类提供一个表示任意几何形状路径的简单而又灵活的形状。

Path2D() 会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）

```js
new Path2D();     // 空的Path对象
new Path2D(path); // 克隆Path对象
new Path2D(d);    // 从SVG建立Path对象
```

所有的路径方法都可以在Path2D中使用。



1. 基础案例

- 代码


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
        var heartPath = new Path2D();
        console.log(heartPath);

        //起始点
        heartPath.moveTo(300,200);
        //起点 两个控制点一个终点 六个参数
        heartPath.bezierCurveTo(350,150,400,200,300,280)
        heartPath.bezierCurveTo(200,200,250,150,300,200)     
        ctx.stroke(heartPath)

        var chatPath = new Path2D()
        chatPath.moveTo(200,300);
        //两个控制点 一个终点 
        chatPath.quadraticCurveTo(150,300,150,200)
        chatPath.quadraticCurveTo(150,100,300,100)
        chatPath.quadraticCurveTo(450,100,450,200)
        chatPath.quadraticCurveTo(450,300,250,300)
        //尾巴
        chatPath.quadraticCurveTo(250,350,150,350)
        chatPath.quadraticCurveTo(200,350,200,300)
        ctx.stroke(chatPath)
        // ctx.fill(chatPath)

        //使用svg的折线
        var palyline = new Path2D('M10 10 h 80 v 80 h -80 z')
        ctx.stroke(palyline)
     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/034.png" style="border:1px solid black">

2. 颜色设置

- 颜色相关
    1. 使用strokeStyle （路径颜色）或 fillStyle（填充颜色）进行设置颜色
    2. 可以设置为'red','ffffff','ffffff00','rgb(255,255,255)','rgba(255,0,255m.3)' 基本web颜色能设成什么，这个地方就能设置成什么颜色
    3. 想要使用不同的颜色
    4. 使用globalAlpha可以设置全局颜色的透明度

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
        //找到画布
        var c1 = document.getElementById("c1");
        //获取画笔
        var ctx = c1.getContext('2d');
        
        var heartPath = new Path2D();
        console.log(heartPath);

        //设置全局透明度
        ctx.globalAlpha = 0.4

        //起始点
        heartPath.moveTo(300,200);
        //起点 两个控制点一个终点
        heartPath.bezierCurveTo(350,150,400,200,300,280)
        heartPath.bezierCurveTo(200,200,250,150,300,200)  
        //设置轮廓的颜色
        
        ctx.fillStyle = 'rgb(0,0,255)'
        ctx.fill(heartPath)
        // ctx.strokeStyle = "red"
        // ctx.stroke(heartPath)

        var chatPath = new Path2D()
        chatPath.moveTo(200,300);
        //两个控制点 一个终点 六个参数
        chatPath.quadraticCurveTo(150,300,150,200)
        chatPath.quadraticCurveTo(150,100,300,100)
        chatPath.quadraticCurveTo(450,100,450,200)
        chatPath.quadraticCurveTo(450,300,250,300)
        //尾巴
        chatPath.quadraticCurveTo(250,350,150,350)
        chatPath.quadraticCurveTo(200,350,200,300)

        ctx.strokeStyle = "blue"

        ctx.stroke(chatPath)

        ctx.strokeStyle = '#ff00ff'
      

        //使用svg的折线
        var palyline = new Path2D('M10 10 h 80 v 80 h -80 z')
        ctx.stroke(palyline)

        ctx.fillStyle = 'rgba(255,0,225,.3)'
        ctx.fillRect(200,180,40,40)
        
     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/035.png" style="border:1px solid black">


## 2.12 案例—线条作画

1. 画出笑脸

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
     <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
          //找到画布
          var c1 = document.getElementById("c1");
          //找到画笔
          var ctx = c1.getContext('2d');
         
          //1.绘制一张脸
          ctx.beginPath()
          ctx.arc(75,75,50,0,Math.PI * 2);
          ctx.stroke()
          ctx.closePath()

          //2.绘制一张嘴巴
          ctx.beginPath()
          ctx.arc(75,75,30,0,Math.PI)
          ctx.stroke()
          ctx.closePath()

          //3.绘制两个眼睛
          ctx.beginPath()
          ctx.arc(60,65,5,0,Math.PI * 2)
          ctx.stroke()
          ctx.closePath()
          ctx.beginPath()
          ctx.arc(90,65,5,0,Math.PI * 2)
          ctx.stroke()
          ctx.closePath()

     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/036.png" style="border:1px solid black">

2. 画出网格


- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
     <title>Document</title>
</head>
<body>
     <canvas id="c1" width="600" height="400" ></canvas>
     <script>
          var canvas = document.getElementById('c1');
          var ctx = canvas.getContext('2d');

          function drawGrid(context,color,stepx,stepy){
               ctx.strokeStyle=color;
               ctx.lineWidth = 0.5;

               for(var i =stepx+0.5;i<ctx.canvas.width;i+=stepx) {
                    ctx.beginPath();
                    ctx.moveTo(i,0);
                    ctx.lineTo(i,ctx.canvas.height);
                    ctx.stroke();
               }
               for(var i = stepy+0.5;i<ctx.canvas.height;i+=stepy){
                    ctx.beginPath();
                    ctx.moveTo(0,i);
                    ctx.lineTo(ctx.canvas.width,i);
                    ctx.stroke();
               }
          }
          drawGrid(ctx,'lightgray',10,10);

     </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/037.png" style="border:1px solid black">


## 2.13 画板

1. 基础型

画出网格


- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600px" height="400px"></canvas>
    <br />
    <button id="clear">清空</button>

    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");

        let isDown = false;
        let beginPoint = null;
        let points = [];
        // 设置线条颜色
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        canvas.addEventListener("mousedown", down, false); //按下鼠标按键时触发
        canvas.addEventListener("mousemove", move, false); //移动鼠标时触发
        canvas.addEventListener("mouseup", up, false); //释放鼠标按键时触发
        canvas.addEventListener("mouseout", up, false); //鼠标离开元素时触发
        // 鼠标按下
        function down(evt) {
            isDown = true;
            beginPoint = getPos(evt);
        }

        // 鼠标移动
        function move(evt) {
            if (!isDown) return;
            const endPoint = getPos(evt);
            drawLine(beginPoint, endPoint);
            beginPoint = endPoint;
        }

        // 抬起鼠标
        function up(evt) {
            if (!isDown) return;
            const endPoint = getPos(evt);
            drawLine(beginPoint, endPoint);
            beginPoint = null;
            isDown = false;
        }

        // 定位赋值
        function getPos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top,
            };
        }
        // 绘制
        function drawLine(beginPoint, endPoint) {
            ctx.beginPath();
            ctx.moveTo(beginPoint.x, beginPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
            ctx.closePath();
        }

        function drawLine(beginPoint, endPoint) {
            ctx.beginPath();
            ctx.moveTo(beginPoint.x, beginPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
            ctx.closePath();
        }

        document.getElementById("clear").onclick = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };
    </script>
</body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/base/html/02.html" width="650" height="450"></iframe>


但是这样是有缺陷的 通过这种方式画出来的线条存在锯齿，不够平滑，而且你画得越快，折线感越强。


**问题分析**

出现该现象的原因主要是：

我们是以canvas的lineTo方法连接点的，连接相邻两点的是条直线，非曲线，因此通过这种方式绘制出来的是条折线；受限于浏览器对mousemove事件的采集频率，大家都知道在mousemove时，浏览器是每隔一小段时间去采集当前鼠标的坐标的，因此鼠标移动的越快，采集的两个临近点的距离就越远，故“折线感越明显“；

**如何才能画出平滑的曲线?**

要画出平滑的曲线，其实也是有方法的，lineTo靠不住那我们可以采用canvas的另一个绘图API——quadraticCurveTo，它用于绘制二次贝塞尔曲线。



2. 二次贝塞尔曲线


- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="600px" height="400px"></canvas>
    <br />
    <button id="clear">清空</button>

    <script>
    
        var canvas = document.getElementById('myCanvas');
        var ctx = canvas.getContext('2d');
        let isDown = false;
        let beginPoint = null;
        let points = [];
        // 设置线条颜色
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 1;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        canvas.addEventListener('mousedown', down, false) //按下鼠标按键时触发
        canvas.addEventListener('mousemove', move, false) //移动鼠标时触发
        canvas.addEventListener('mouseup', up, false) //释放鼠标按键时触发
        canvas.addEventListener('mouseout', up, false) //鼠标离开元素时触发

        // 鼠标按下
        function down(evt) {
            isDown = true
            const { x, y } = getPos(evt)
            points.push({ x, y })
            beginPoint = { x, y }
        }
        // 鼠标移动
        function move(evt) {
            if (!isDown) return

            const { x, y } = getPos(evt)
            points.push({ x, y })

            if (points.length > 3) {
                const lastTwoPoints = points.slice(-2)
                const controlPoint = lastTwoPoints[0]
                const endPoint = {
                x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,
                y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2
                }
                drawLine(beginPoint, controlPoint, endPoint)
                beginPoint = endPoint
            }
        }
        // 抬起鼠标
        function up(evt) {
            if (!isDown) return
            const { x, y } = getPos(evt)
            points.push({ x, y })

            if (points.length > 3) {
                const lastTwoPoints = points.slice(-2)
                const controlPoint = lastTwoPoints[0]
                const endPoint = lastTwoPoints[1]
                drawLine(beginPoint, controlPoint, endPoint)
            }
            beginPoint = null
            isDown = false
            points = []
        }
        // 定位赋值
        function getPos(evt) {
            const rect = canvas.getBoundingClientRect()
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            }
        }
        // 绘制
        function drawLine(beginPoint, controlPoint, endPoint) {
            ctx.beginPath()
            ctx.moveTo(beginPoint.x, beginPoint.y)
            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y)
            ctx.stroke()
            ctx.closePath()
        }
    

        document.getElementById("clear").onclick = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };
    </script>
</body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/base/html/03.html" width="650" height="450"></iframe>



## 2.11 案例-绘制调色板

1. 方格调色板

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="myCanvas" width="300px" height="300px"></canvas>
    <script>
    
        var canvas = document.getElementById('myCanvas');
        var ctx = canvas.getContext('2d');

        var n = 8;
        var step = 30;
        for(var y = 0; y < n; y++) {
            for(var x = 0; x < n; x++) {
                ctx.fillStyle = "rgb(" + Math.floor(255-255*y/n) + ", " + Math.floor(255-255*x/n) + ", 0)";
                ctx.fillRect(x*step, y*step, step, step);
            }
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/038.png" style="border:1px solid black">


2. 渐变调色板

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="myCanvas" width="600px" height="400px"></canvas>
    <script>
    
        var canvas = document.getElementById('myCanvas');
        var ctx = canvas.getContext('2d');

        var r = 255, g = 0, b = 0;
        var step = 6;
        for(var i = 0; i < 150; i++) {
            if(i < 25) {
                g += 10;
            } else if(i > 25 && i < 50) {
                r -= 10;
            } else if (i > 50 && i < 75) {
                g -= 10;
                b += 10;
            } else if(i >= 75 && i < 100) {
                r += 10;
            } else {
                b -= 10;
            }
            ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ")";
            ctx.fillRect(step*i, 0, step, canvas.height-10);
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/039.png" style="border:1px solid black">
