# 七、像素操作


## 7.1 像素认知

### 7.1.1 ImageData() 对象

1. ImageData 是什么？
ImageData 是图片的数据化，它具备以下属性：

- data：Uint8ClampedArray `[r,g,b,a, r,g,b,a, r,g,b,a, r,g,b,a]`
- width：整数
- heidth：整数

>注：Uint8ClampedArray 翻译过来是 8位无符号整型固定数组，其取值范围是[0,255]。若小于0，则为0，大于255，则为255。若为小数，则取整，取整的方法是银行家舍入。


2. 怎么拿到 ImageData() 对象？

- 直接建立ImageData() 对象（相当于自己新建了一张图片）。

```js
new ImageData(width, height)  
new ImageData(Uint8ClampedArray, width, height)

ctx.createImageData()
ctx.createImageData(width, height)
ctx.createImageData(ImageData)
```

- 获取canvas 的ImageData() 对象（可以以此原理获取真实图片的数据）

```js
ctx.getImageData(x, y, width, height)
```

3. 在canvas 中显示ImageData

```js
context.putImageData(imagedata, dx, dy);
context.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
```


### 7.1.2 理解 ImageData 中的像素集合和图像栅格的对应关系

1. ImageData 对象的属性：

- data：Uint8ClampedArray `[0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15]`
- width：2
- heidth：2

![]/animation/canvas/base/image/073.png)


2. 遍历像素集合的方法

逐像素遍历：每隔 4 个数据遍历一次，简单快捷。

```js
for(let i=0;i<arr.length;i+=4){
  let r=data[i+0];
  let g=data[i+1];
  let b=data[i+2];
  let a=data[i+3];
  console.log(r,g,b,a)
}
```

行列遍历：基于行列遍历，可获取像素点的位置信息。

```js
for(let y=0;y<h;y++){
  for(let x=0;x<w;x++){
    let ind=(y*w+x)*4;
    let r=data[ind];
    let g=data[ind+1];
    let b=data[ind+2];
    let a=data[ind+3];
    console.log(r,g,b,a)
  }
}
```

## 7.2 像素创建

### 7.2.1 ImageData像素


ImageData 接口描述 `<canvas>` 元素的一个隐含像素数据的区域。使用 ImageData()构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。


1. ImageData 像素

ImageData 对象表示 canvas 元素指定区域的像素数据。

图片像素数据实际上就是一个个的颜色值，可使用 RGBA 颜色模型来表示，所以 ImageData 对象的像素数据，就是图像的一个个像素点的颜色值，长度为 windth * height * 4，这里的 4 就是对应的 RGBA 4个颜色通道。

- 语法

    ```js
    new ImageData(array, width, height);
    new ImageData(width, height);
    ```

- 参数说明

    - array：是一个 Uint8ClampedArray 类型数组的实例，存储的是像素点的颜色值数据，数组元素按每个像素点的 RGBA 4通道的数值依次排列，该数组的长度必须为 windth * height * 4，否则报错。如果不给定该数组参数，则会根据宽高创建一个全透明的图像。
    - width：图像宽度
    - height：图像高度



2. Uint8ClampedArray 数组

ImageData对象的数据参数和属性，是 Uint8ClampedArray 类型数组的实例。

Uint8ClampedArray 是8位无符号整型固定数组，属于11个类型化数组(TypeArray)中的一个，元素值固定在0-255区间的。

它的属性参数及用法，与其他中的类型化数组一样，具体的介绍可见博文 前端二进制知识与相关API 。

因为 Uint8ClampedArray 无符号整形固定的特点，对于存储像素点的颜色值正好，RGBA 四个通道，每个通道的取值都是 0 - 255 间的数字。如表示红色、无透明，[255, 0, 0, 255]。


> 注意：
> 1. 透明度一般在前端颜色体系中使用的是 0 - 1 区间的值，包括在canvas中颜色属性也是 0 - 1。而 RGB 三色的取值则基本保持一致，即 0 - 255。
> 2. 图像像素点数组的长度必须为 宽 * 高 * 4 。


- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
</head>
<body>
    <canvas id="c1" width="600" height="400"></canvas>
    <script>
        const canvas = document.getElementById("c1");
        const ctx = canvas.getContext("2d");


        let height = 100;
        let width = 100;

        // 1. 透明图
        const imgData1 = new ImageData(height, width)
        ctx.putImageData(imgData1,0,0);


        // 2. 通过 Uint8ClampedArray 使用 ImageData
        let u8cArray = []
        let redArray = [255, 0, 0, 255];
        // 100 * 100 的 红色
        for (let i = 0; i < 100; i++) {
            for (let i = 0; i < 100; i++) {
                u8cArray.push(...redArray)
            }
        }
        let clampedArray = new Uint8ClampedArray(u8cArray);
        const imgData2 = new ImageData(clampedArray,100, 100)
        ctx.putImageData(imgData2,100,0);
       
        // 3. 创建图后设置图像颜色
        const imagedata3 = new ImageData(height, width)
        const length = imagedata3.data.length
        for (let i = 0; i < length; i += 4) {
            // 设置为绿色
            imagedata3.data[i] = 0
            imagedata3.data[i + 1] = 255
            imagedata3.data[i + 2] = 0
            imagedata3.data[i + 3] = 255
        }
        ctx.putImageData(imagedata3, 200, 0)

    </script>
</body>
</html>
```

- 图像

<img src="/animation/canvas/base/image/074.png" style="border:1px solid black">


### 7.2.2 ImageBitmap

1. ImageBitmap位图

- ImageBitmap特性
    - ImageBitmap 表示一个位图图像，可绘制到canvas中，并且具有低延迟的特性。
    - 与ImageData 一样的是，他们都是在浏览器环境下可以访问的全局对象。
    - ImageData 不一样的是，ImageBitmap 没有构造函数，可以直接引用对象(无意义)，但无法通过构造函数创建，而需要借助 createImageBitmap() 进行创建。
- 属性和方法：
    - width：只读，表示图像的像素宽度
    - height：只读，表示图像的像素高度
    - close()：释放ImageBitmap关联的所有图像资源

2. createImageBitmap()


createImageBitmap() 接受不同的图像资源，返回一个成功结果为ImageBitmap的Promise异步对象。

- 基本语法如下：

```js
createImageBitmap(image, [options])
createImageBitmap(image, sx, sy, sw, sh, [options])
```

- 基本参数
    - image：图像源
        可取值：img, SVG-image, video, canvas, HTMLImageElement, SVGImageElement, HTMLVideoElement, HTMLCanvasElement, Blob, File, ImageData, ImageBitmap, 或 OffscreenCanvas 对象
    - sx：裁剪起点横坐标
    - sy：裁剪起点纵坐标
    - sw：裁剪宽度
    - sh：裁剪高度
    - options：可选，为其设置选项的对象。可用的选项是:
        - imageOrientation: 是原样呈现还是垂直翻转，可选 none(默认)、flipY
        - premultiplyAlpha: 颜色通道是否由alpha通道预乘，可选 none、premultiply、default(默认)
        - colorSpaceConversion: 是否使用色彩空间转换进行解码，可选 none、default (默认)
        - resizeWidth: 压缩新宽度
        - resizeHeight: 压缩新高度
        - resizeQuality: 压缩质量，可选 pixelated、low(默认)、medium、high
        - createImageBitmap 可以直接读取多种图像数据源，比如 ImageData、File、以及多种HTML元素对象等等，这可以让我们更加灵活的处理图像数据。


- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
</head>
<body>
    <script>
        var image = new Image();
        image.src = "./images/3.jpeg";

        image.onload = function () {
            createImageBitmap(image).then(imageBitmap => {
                const canvas = document.createElement('canvas')
                canvas.width = imageBitmap.width
                canvas.height = imageBitmap.height
                const ctx = canvas.getContext('2d')
                ctx.drawImage(imageBitmap, 0, 0)
                
                document.body.append(canvas)
            })
        }
    </script>
</body>
</html>
```

- 图像

<img src="/animation/canvas/base/image/075.png" style="border:1px solid black">


## 7.3 ImageData在canvas中的应用

### 7.3.1 createImageData


- 语法：

    1. 以指定的尺寸（以像素计）创建新的 ImageData 对象：

    ```js
    var imgData = context.createImageData(width,height);
    ```

    2. 创建与指定的另一个 ImageData 对象尺寸相同的新 ImageData 对象（不会复制图像数据）：

    ```js
    var imgData = context.createImageData(imageData);
    ```

- 参数
    - width: ImageData对象的宽度，以像素计。
    - height: ImageData 对象的高度，以像素计。
    - imageData: 另一个 ImageData 对象。

> 注意： createImageData 创建的都是空白透明图层。


- 代码

```html
<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta charset="utf-8" />
    </head>
    <body>
        <canvas id="c1" width="600" height="400"></canvas>
        <script>
            const canvas = document.getElementById("c1");
            const ctx = canvas.getContext("2d");

            // 方式一
            const reateImageData1 = ctx.createImageData(100, 100);
            const length1 = reateImageData1.data.length;
            for (let i = 0; i < length1; i += 4) {
                // 红色
                reateImageData1.data[i] = 255;
                reateImageData1.data[i + 1] = 0;
                reateImageData1.data[i + 2] = 0;
                reateImageData1.data[i + 3] = 255;
            }
            // 像素点绘制
            ctx.putImageData(reateImageData1, 0, 0);

            // 方式二
            const imagedata = new ImageData(100, 100);
            const reateImageData2 = ctx.createImageData(imagedata);
            const length2 = reateImageData2.data.length;
            for (let i = 0; i < length2; i += 4) {
                // 设置为绿色
                reateImageData2.data[i] = 0;
                reateImageData2.data[i + 1] = 255;
                reateImageData2.data[i + 2] = 0;
                reateImageData2.data[i + 3] = 255;
            }
            ctx.putImageData(reateImageData2, 110, 0);
        </script>
    </body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/076.png" style="border:1px solid black">


### 7.3.2 getImageData

- 语法

    ```js
    context.getImageData(x, y, width, height)
    ```
- 参数:
    - x: 开始复制的左上角位置的 x 坐标。
    - y: 开始复制的左上角位置的 y 坐标。
    - width: 将要复制的矩形区域的宽度。
    - height: 将要复制的矩形区域的高度。


- 代码

```html
<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta charset="utf-8" />
    </head>
    <body>
        <canvas id="c1" width="600" height="400"></canvas>
        <script>
            const canvas = document.getElementById("c1");
            const ctx = canvas.getContext("2d");

            let image = new Image();
            image.src = "./images/2.png";

            image.onload = function () {
                ctx.drawImage(image,0,0);

                let data = ctx.getImageData(50, 50, 200, 200);
			    ctx.putImageData(data, 350, 100);
            }

        </script>
    </body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/077.png" style="border:1px solid black">


### 7.3.3 putImageData

- 语法:

    ```js
    context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight);
    ```
- 参数:
    - imagedata: 一个 ImageData 对象，包含要绘制到画布上的像素数据。
    - dx: 目标画布的左上角 x 坐标。
    - dy: 目标画布的左上角 y 坐标。
    - dirtyX (可选): 要绘制的矩形区域的左上角 x 坐标。
    - dirtyY (可选): 要绘制的矩形区域的左上角 y 坐标。
    - dirtyWidth (可选): 要绘制的矩形区域的宽度。
    - dirtyHeight (可选): 要绘制的矩形区域的高度。

如果提供了 dirtyX, dirtyY, dirtyWidth, 和 dirtyHeight 参数，则只绘制指定的矩形区域。否则，整个 ImageData 对象都会被绘制到画布上。



- 代码

```html
<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta charset="utf-8" />
    </head>
    <body>
        <canvas id="c1" width="600" height="400"></canvas>
        <script>
            const canvas = document.getElementById("c1");
            const ctx = canvas.getContext("2d");

            let image = new Image();
            image.src = "./images/2.png";

            image.onload = function () {
                ctx.drawImage(image,0,0);

                let data = ctx.getImageData(100, 100, 100, 100);
			    // 方式1
                ctx.putImageData(data, 310, 100);

                // 方式2 再次裁剪
                ctx.putImageData(data, 420, 100,20,20,60,60);
            }
        </script>
    </body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/078.png" style="border:1px solid black">


## 7.4 操作像素构成滤镜


### 7.4.1 反色效果

颜色反转，像素取相反值。

- 一个像素由 rgba 4个元素组成，在反色效果中，不需要修改 a ，因为它负责不透明度。
- 而 rgb 如果都是 255 ，就是白色，如果都是 0 就是黑色。
- 反色的原理就是用 255 减去原来的值。也就是说红、绿、蓝各自取反。
- 比如 `rgb(10, 200, 100)` ，那么反色就是 `rgb(245, 55, 155)`。



```js
for(var i=0; i<data.length; i+=4) {
	data[i+0] = 255-data[i+0];
	data[i+1] = 255-data[i+1];
	data[i+2] = 255-data[i+2];
}
```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"反色效果");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10,10,200,370)
            let data = imageData.data;

            for (let i = 0; i < data.length; i+=4) { 
                data[i] = 255 - data[i];
                data[i + 1 ] = 255 - data[i + 1];
                data[i + 2 ] = 255 - data[i + 2];
                data[i + 3 ] = 255;
            }
            ctx.putImageData(imageData,380,10)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/079.png" style="border:1px solid black">


### 7.4.2 灰度效果

灰度图（average），彩色图片转换成黑白图片。

```js
for(var i=0; i<data.length; i+=4) {
	var average = (data[i+0]+data[i+1]+data[i+2]) / 3;
	data[i+0] = average;
	data[i+1] = average;
	data[i+2] = average;
}
```


- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"灰度效果");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10,10,200,370)
            let data = imageData.data;

            for (let i = 0; i < data.length; i+=4) { 

                //计算出当前像素的平局值   
                let avg = (data[i] + data[i + 1] +  data[i + 1])/3;
                data[i] = avg;
                data[i + 1 ] = avg;
                data[i + 2 ] = avg;
                data[i + 3 ] = 255;
            }
            ctx.putImageData(imageData,380,10)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/080.png" style="border:1px solid black">


### 7.4.3 黑白效果

将每个像素的 rgb 都相加起来，再除以 3 。判断一下是否大于 128 ，如果大于的话，直接取白色（255）；小于的话就取黑色（0）。

因为每个通道的取值范围是 0 ~ 255，取中间值来判断，就使用了 128 做判断值。

```js
for (let i = 0; i < data.length; i+=4) { 
    const r = data[i + 0]
    const g = data[i + 1]
    const b = data[i + 2]
    const avg = (r + g + b) / 3
    data[i + 0] = data[i + 1] = data[i + 2] = avg >= 128 ? 255 : 0
}
```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"黑白效果");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10,10,200,370)
            let data = imageData.data;

            for (let i = 0; i < data.length; i+=4) { 
                const r = data[i + 0]
                const g = data[i + 1]
                const b = data[i + 2]
                const avg = (r + g + b) / 3
                data[i + 0] = data[i + 1] = data[i + 2] = avg >= 128 ? 255 : 0
            }
            ctx.putImageData(imageData,380,10)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/081.png" style="border:1px solid black">

### 7.4.4 RGB通道

先设置一个调节参数。如果只是想调红通道，那就让红通道和这个参数相加或者相减。

```js
let arg = 80; // 调节参数

for (var i = 0; i < rData.length; i += 4) {
    rData[i + 0] += arg; // r，红通道
}

```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400"></canvas>
    <script>
        class Arrow {
            #color = "skyblue";
            constructor(x, y, content) {
                this.x = x;
                this.y = y;
                this.content = content;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath();
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath();
                ctx.fill();

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext("2d");

        // 箭头
        let arrow = new Arrow(300, 200, "RGB通道");
        arrow.draw(ctx);

        var img = new Image();
        img.src = "./images/1.jpg";

        img.onload = function () {
            ctx.drawImage(img, 10, 10, 200, 370);

            let arg = 80; // 调节参数

            // r 红通道
            const imageData1 = ctx.getImageData(10, 10, 200, 120);
            const rData = imageData1.data;

            for (var i = 0; i < rData.length; i += 4) {
                rData[i + 0] += arg; // r，红通道
            }
            ctx.putImageData(imageData1, 380, 10);

            // g 绿通道
            const imageData2 = ctx.getImageData(10, 120, 200, 120);
            const gData = imageData2.data;
            for (var i = 0; i < gData.length; i += 4) {
                gData[i + 1] += arg; // g，绿通道
            }
            ctx.putImageData(imageData2, 380, 120);

            // b 蓝通道
            const imageData3 = ctx.getImageData(10, 240, 200, 130);
            const bData = imageData3.data;
            for (var i = 0; i < bData.length; i += 4) {
                bData[i + 2] += arg; // b，蓝通道
            }
            ctx.putImageData(imageData3, 380, 240);
        };
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/082.png" style="border:1px solid black">



### 7.4.5 RGB蒙版

先设置一个调节参数。如果只是想调红通道，那就让红通道和这个参数相加或者相减。

```js
for(var i=0; i<data.length; i+=4) {
	var r = data[i+0];
	var g = data[i+1];
	var b = data[i+2];
	var average = (r+g+b)/3;
	data[i+0] = average;
	data[i+1] = 0;
	data[i+2] = 0;
}
```
>如：图片偏红的效果。r取rgb平均值，g，b取0。

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400"></canvas>

    <script>
        class Arrow {
            #color = "skyblue";
            constructor(x, y, content) {
                this.x = x;
                this.y = y;
                this.content = content;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath();
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath();
                ctx.fill();

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext("2d");

        // 箭头
        let arrow = new Arrow(300, 200, "RGB蒙版");
        arrow.draw(ctx);

        var img = new Image();
        img.src = "./images/1.jpg";

        img.onload = function () {
            ctx.drawImage(img, 10, 10, 200, 370);

            // r 红通道
            const imageData1 = ctx.getImageData(10, 10, 200, 120);
            const rData = imageData1.data;

            for (var i = 0; i < rData.length; i += 4) {
                let avg = (rData[i] + rData[i + 1] + rData[i + 1]) / 3;
                rData[i] = avg;
                rData[i + 1] = 0;
                rData[i + 2] = 0;
                rData[i + 3] = 255;
            }
            ctx.putImageData(imageData1, 380, 10);

            // g 绿通道
            const imageData2 = ctx.getImageData(10, 120, 200, 120);
            const gData = imageData2.data;

            for (var i = 0; i < gData.length; i += 4) {
                let avg = (gData[i] + gData[i + 1] + gData[i + 1]) / 3;
                gData[i] = 0;
                gData[i + 1] = avg;
                gData[i + 2] = 0;
                gData[i + 3] = 255;
            }
            ctx.putImageData(imageData2, 380, 120);

            // b 蓝通道
            const imageData3 = ctx.getImageData(10, 240, 200, 130);
            const bData = imageData3.data;

            for (var i = 0; i < bData.length; i += 4) {
                let avg = (bData[i] + bData[i + 1] + bData[i + 1]) / 3;
                bData[i] = 0;
                bData[i + 1] = 0;
                bData[i + 2] = avg;
                bData[i + 3] = 255;
            }
            ctx.putImageData(imageData3, 380, 240);
        };
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/083.png" style="border:1px solid black">


### 7.4.6 复古效果

sepia，古旧效果，加权平均。

```js
for(var i=0; i<data.length; i+=4) {
	var r = data[i+0];
	var g = data[i+1];
	var b = data[i+2];
	data[i+0] = r*0.39+g*0.76+b*0.18;
	data[i+1] = r*0.35+g*0.68+b*0.16;
	data[i+2] = r*0.27+g*0.53+b*0.13;
}
```



- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"复古效果");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10,10,200,370)
            let data = imageData.data;

            for (let i = 0; i < data.length; i+=4) { 
                let r = data[i + 0]
                let g = data[i + 1]
                let b = data[i + 2]

                data[i] = r * 0.39 + g * 0.76 + b * 0.18;
                data[i + 1 ] = r * 0.35 + g * 0.68 + b * 0.16;
                data[i + 2 ] = r * 0.27 + g * 0.53 + b * 0.13;
                data[i + 3 ] = 255;
            }
            ctx.putImageData(imageData,380,10)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/084.png" style="border:1px solid black">




### 7.4.7 透明处理

透明度乘以n。

```js
var n = 0.3;
for(var i=0; i<data.length; i+=4) {
	data[i+3] *= n;
}
```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"透明处理");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10,10,200,370)
            let data = imageData.data;

            for (let index = 0; index < data.length; index+=4) { 
                data[index + 3] *= 0.3
            }
            ctx.putImageData(imageData,380,10)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/085.png" style="border:1px solid black">


### 7.4.8 亮度处理

如果需要调亮，就把 rgb 每个值往上调；如果要调暗，就往下调。

```js
var a = -50;
for(var i=0; i<data.length; i+=4) {
	data[i+0] += a;
	data[i+1] += a;
	data[i+2] += a;
}
```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"亮度效果");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);

            // 获取对象 并开始反转
            let imageData1 = ctx.getImageData(10,10,200,185);
            let imageData2 = ctx.getImageData(10,185,200,185);
            // 调整大小
            const a = 100;

            for (let i = 0; i < imageData1.data.length; i+=4) { 
                //变亮
                imageData1.data[i] += a;
                imageData1.data[i + 1 ] += a;
                imageData1.data[i + 2 ] += a;
                imageData1.data[i + 3 ] = 255;

                //变暗
                imageData2.data[i] -= a;
                imageData2.data[i + 1 ] -= a;
                imageData2.data[i + 2 ] -= a;
                imageData2.data[i + 3 ] = 255;
            }
            ctx.putImageData(imageData1,380,10);
            ctx.putImageData(imageData2,380,185);
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/086.png" style="border:1px solid black">



### 7.4.9 高斯模糊

让图片模糊的方法是，当前像素的值，取决于周围8个像素的平均值（某些情况没有8个那么多，比如像素在图像的边缘）。将平均值赋给当前正在操作的像素，就可以得到一个和周边像素比较接近的过渡颜色。



- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400"></canvas>
    <script>
        class Arrow {
            #color = "skyblue";
            constructor(x, y, content) {
                this.x = x;
                this.y = y;
                this.content = content;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath();
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath();
                ctx.fill();

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext("2d");

        // 箭头
        let arrow = new Arrow(300, 200, "高斯模糊");
        arrow.draw(ctx);

        var img = new Image();
        img.src = "./images/1.jpg";

        img.onload = function () {
            ctx.drawImage(img, 10, 10, 200, 370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10, 10, 200, 370);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            const gaussMatrix = [];

            let gaussSum = 0;
            let x = 0;
            let y = 0;

            let i = 0;
            let j = 0;
            let k = 0;
            let len = 0;

            const radius = 10;
            const sigma = 5;

            let r = 0;
            let g = 0;
            let b = -1 / (2 * sigma * sigma);
            let a = 1 / (Math.sqrt(2 * Math.PI) * sigma);

            // 生成高斯矩阵
            for (i = 0, x = -radius; x <= radius; x++, i++) {
                g = a * Math.exp(b * x * x);
                gaussMatrix[i] = g;
                gaussSum += g;
            }

            // 归一化, 保证高斯矩阵的值在[0,1]之间
            for (i = 0, len = gaussMatrix.length; i < len; i++) {
                gaussMatrix[i] /= gaussSum;
            }

            // x 方向一维高斯运算
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    r = g = b = a = 0;
                    gaussSum = 0;
                    for (j = -radius; j <= radius; j++) {
                        k = x + j;
                        if (k >= 0 && k < width) {
                            // 确保 k 没超出 x 的范围
                            // r,g,b,a 四个一组
                            i = (y * width + k) * 4;
                            r += data[i] * gaussMatrix[j + radius];
                            g += data[i + 1] * gaussMatrix[j + radius];
                            b += data[i + 2] * gaussMatrix[j + radius];
                            gaussSum += gaussMatrix[j + radius];
                        }
                    }
                    i = (y * width + x) * 4;
                    // 除以 gaussSum 是为了消除处于边缘的像素, 高斯运算不足的问题
                    // console.log(gaussSum)
                    data[i] = r / gaussSum;
                    data[i + 1] = g / gaussSum;
                    data[i + 2] = b / gaussSum;
                }
            }

            // y 方向一维高斯运算
            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    r = g = b = a = 0;
                    gaussSum = 0;
                    for (j = -radius; j <= radius; j++) {
                        k = y + j;
                        if (k >= 0 && k < height) {
                            // 确保 k 没超出 y 的范围
                            i = (k * width + x) * 4;
                            r += data[i] * gaussMatrix[j + radius];
                            g += data[i + 1] * gaussMatrix[j + radius];
                            b += data[i + 2] * gaussMatrix[j + radius];
                            gaussSum += gaussMatrix[j + radius];
                        }
                    }
                    i = (y * width + x) * 4;
                    data[i] = r / gaussSum;
                    data[i + 1] = g / gaussSum;
                    data[i + 2] = b / gaussSum;
                }
            }

            ctx.putImageData(imageData,380,10)
        };
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/087.png" style="border:1px solid black">



### 7.4.10 马赛克

马赛克的原理是：先定义一个马赛克范围参数，该参数越大，马赛克的格子就越大。通过该参数去到当前正在操作的像素的四周像素，并将这些像素的颜色值求出一个平均值，然后该像素四周的像素都使用求出来的颜色值。


1. 方法一

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="c1" width="600" height="400"></canvas>
        <script>
            class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
                draw(ctx) {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // 图形
                    ctx.fillStyle = this.#color;
                    ctx.beginPath();
                    ctx.moveTo(-50, -25);
                    ctx.lineTo(0, -25);
                    ctx.lineTo(0, -50);
                    ctx.lineTo(50, 0);
                    ctx.lineTo(0, 50);
                    ctx.lineTo(0, 25);
                    ctx.lineTo(-50, 25);
                    ctx.closePath();
                    ctx.fill();

                    // 文字
                    ctx.strokeStyle = "orange";
                    ctx.font = "200 16px Arial";
                    ctx.strokeText(this.content, -35, 5);

                    ctx.restore();
                }
            }

            var c1 = document.getElementById("c1");
            var ctx = c1.getContext("2d");

            // 箭头
            let arrow = new Arrow(300, 200, "马赛克1");
            arrow.draw(ctx);

            var img = new Image();
            img.src = "./images/1.jpg";

            img.onload = function () {
                ctx.drawImage(img, 10, 10, 200, 370);

                // 获取对象 并开始反转
                let imageData = ctx.getImageData(10, 10, 200, 370);
                // const data = imageData.data;

                let num = 6;
                let imgWidthStep = imageData.width / num;
                let imgHeightStep = imageData.height / num;

                for (let i = 0; i < imgWidthStep; i++) {
                    for (let j = 0; j < imgHeightStep; j++) {
                        let color = computedColor(imageData, (i + 1) * num, j * num);
                        for (let k = 0; k < num; k++) {
                            for (let l = 0; l < num; l++) {
                                setImg(imageData, i * num + l, j * num + k, color);
                            }
                        }
                    }
                }

                ctx.putImageData(imageData, 380, 10);
            };

            // 计算颜色值
            function computedColor(imgData, x, y) {
                const { width, data } = imgData;
                const color = [];

                color[0] = data[(y * width + x) * 4 + 0]; // r
                color[1] = data[(y * width + x) * 4 + 1]; // g
                color[2] = data[(y * width + x) * 4 + 2]; // b
                color[3] = data[(y * width + x) * 4 + 3]; // a
                return color;
            }

            // 设置颜色
            function setImg(imgData, x, y, color) {
                const { width, data } = imgData;
                data[(y * width + x) * 4 + 0] = color[0]; // r
                data[(y * width + x) * 4 + 1] = color[1]; // g
                data[(y * width + x) * 4 + 2] = color[2]; // b
                data[(y * width + x) * 4 + 3] = color[3]; // a
            }
        </script>
    </body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/088.png" style="border:1px solid black">

2. 方法二

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400"></canvas>
    <script>
        class Arrow {
            #color = "skyblue";
            constructor(x, y, content) {
                this.x = x;
                this.y = y;
                this.content = content;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath();
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath();
                ctx.fill();

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext("2d");

        // 箭头
        let arrow = new Arrow(300, 200, "马赛克2");
        arrow.draw(ctx);

        var img = new Image();
        img.src = "./images/1.jpg";

        img.onload = function () {
            ctx.drawImage(img, 10, 10, 200, 370);

            const width = c1.width;
            const height = c1.height;

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(10, 10, 200, 370);
            const data = imageData.data;

            // 按照像素块处理
            const blockSize = 5;

            // 按块处理图像
            for (let y = 0; y < height; y += blockSize) {
                for (let x = 0; x < width; x += blockSize) {
                    // 首先计算当前块的平均颜色
                    let r = 0,
                        g = 0,
                        b = 0,
                        a = 0;
                    let pixelCount = 0;

                    // 累加块内所有像素颜色
                    for (let by = 0; by < blockSize && y + by < height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                            const pixelIndex = ((y + by) * width + (x + bx)) * 4;
                            r += data[pixelIndex]; // 红色通道
                            g += data[pixelIndex + 1]; // 绿色通道
                            b += data[pixelIndex + 2]; // 蓝色通道
                            a += data[pixelIndex + 3]; // Alpha通道
                            pixelCount++;
                        }
                    }

                    // 计算平均颜色
                    r = Math.round(r / pixelCount);
                    g = Math.round(g / pixelCount);
                    b = Math.round(b / pixelCount);
                    a = Math.round(a / pixelCount);

                    // 将平均颜色应用到整个块
                    for (let by = 0; by < blockSize && y + by < height; by++) {
                        for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                            const pixelIndex = ((y + by) * width + (x + bx)) * 4;
                            data[pixelIndex] = r;
                            data[pixelIndex + 1] = g;
                            data[pixelIndex + 2] = b;
                            data[pixelIndex + 3] = a;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 380, 10);
        };
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/089.png" style="border:1px solid black">




### 7.4.11 部分处理

跳针完像素后，只使用其中一块。

```js
// 后面四个参数就是调整的部分
ctx.putImageData(imageData,380,10,100,185,100,185)
```

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <canvas id="c1" width="600" height="400" ></canvas>
    <script>
        class Arrow {
                #color = "skyblue";
                constructor(x, y, content) {
                    this.x = x;
                    this.y = y;
                    this.content = content;
                }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y); 

                // 图形
                ctx.fillStyle = this.#color;
                ctx.beginPath(); 
                ctx.moveTo(-50, -25);
                ctx.lineTo(0, -25);
                ctx.lineTo(0, -50);
                ctx.lineTo(50, 0);
                ctx.lineTo(0, 50);
                ctx.lineTo(0, 25);
                ctx.lineTo(-50, 25);
                ctx.closePath(); 
                ctx.fill(); 

                // 文字
                ctx.strokeStyle = "orange";
                ctx.font = "200 16px Arial";
                ctx.strokeText(this.content, -35, 5);

                ctx.restore();
            }
        }

        var c1 = document.getElementById("c1");
        var ctx = c1.getContext('2d');

        // 箭头
        let arrow = new Arrow(300,200,"部分改变");
        arrow.draw(ctx)

        var img = new Image();
        img.src = './images/1.jpg';

        img.onload = function(){
            ctx.drawImage(img,10,10,200,370);
            ctx.drawImage(img,380,10,200,370);

            // 获取对象 并开始反转
            let imageData = ctx.getImageData(380,10,200,370)
            let data = imageData.data;

            for (let i = 0; i < data.length; i+=4) { 
                // 正常跳帧
                let avg = (data[i] + data[i + 1] +  data[i + 1])/3;
                data[i] = avg;
                data[i + 1 ] = avg;
                data[i + 2 ] = avg;
                data[i + 3 ] = 255;
            }
            ctx.putImageData(imageData,380,10,100,185,100,185)
        }
    </script>
</body>
</html>
```

- canvas 图

<img src="/animation/canvas/base/image/090.png" style="border:1px solid black">

