# 五、检测

## 5.1 边界检测

什么是边界检测？

在之前的开发中，物体在运动过程中一旦超出画布，就会消失，我接下来要讲解物体如何去检测是否碰到了边界，碰到边界后又会有哪些处理的办法。

边界检测，就是物体运动的限制范围。边界检测的范围，既可以是画布的某个区域，也可以是整个画布。


### 5.1.1 边界限制

![](/animation/canvas/senior/image/008.png)


假设，我们有个小球，中心点为（x, y），那么它边界检测的代码为：


```js
if (ball.x < ball.radius) {
  // 小球碰到了左边界
} else if (ball.x > cnv.width - ball.raduis) {
  // 小球碰到了右边界
}
if (ball.y < ball.radius) {
  // 小球碰到了上边界
} else if (ball.y > cnv.height - ball.raduis) {
  // 小球碰到了下边界
}
```

下面是一个按照四周滚动的案例

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }


            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            // 半径
            let radius = 30;
            // 初始化小球
            const ball = new Ball(radius, radius, radius);

            // 状态 0 1 2 3 分别向四个方向移动
            let state = 0;
            // 速度
            let speed = 2;


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if(state == 0){
                    if(ball.x >= canvas.width - radius){
                        state ++;
                        ball.x = canvas.width - radius;
                        
                    }else{
                        ball.x += speed;
                    }
                }else if(state == 1){
                    if(ball.y >= canvas.height - radius){
                        state ++;
                        ball.y = canvas.height - radius;
                    }else{
                        ball.y += speed;
                    }
                }else if(state == 2){
                    if(ball.x <=  radius){
                        state ++;
                        ball.x = radius
                    }else{
                        ball.x -= speed;
                    }
                }else if(state == 3){
                    if(ball.y <=  radius){
                        state = 0;
                        ball.y = radius
                    }else{
                        ball.y -= speed;
                    }
                }
               
                ball.fill(ctx)
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/25.html" width="650" height="450"></iframe>


### 5.1.2 边界环绕

边界环绕，指的是物体从一个边界完全消失，就会从另一个边界出现，是一种环绕效果。

注意加粗的字体，完全消失。

下面我们用代码描述一下，如何判定完全消失。

![](/animation/canvas/senior/image/009.png)

```js
if (ball.x < -ball.radius) {
  // 完全超出左边界
} else if (ball.x > cnv.width + ball.radius) {
  // 完全超出右边界
}
if (ball.y < -ball.radius) {
  // 完全超出上边界
} else if (ball.y > cnv.height + ball.radius) {
  // 完全超出下边界
}
```


- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }


            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            // 半径
            let radius = 30;
            // 竖球
            const verticalBall = new Ball(canvas.width/2, -radius, radius);
            // 横球
            const horizontalBall = new Ball(-radius, canvas.height/2, radius,"red");
            
            // 速度
            let speed = 2;


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                verticalBall.y += speed;
                if(verticalBall.y > canvas.height + radius){
                    // 完全超出下边界
                    verticalBall.y = - radius
                }

                horizontalBall.x += speed;
                if(horizontalBall.x > canvas.width + radius){
                    // 完全超出下边界
                    horizontalBall.x = - radius
                }
                
               
                verticalBall.fill(ctx)
                horizontalBall.fill(ctx)
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/26.html" width="650" height="450"></iframe>


### 5.1.3 边界生成
边界生成，指的是物体完全超出边界后，会在最开始的位置重新生成。

边界生成，经常运用于粒子特效，是一个非常有用的知识点。

接下来，展示一下判断边界完全超出的方式：



- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }


            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

           // 生成随机颜色
            const getRandomColor = () => {
                return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)])
                    && (color.length == 6) ? color : arguments.callee(color)
                })('')
            }

            // 定义数组，用来缓存小球
            let balls = []
            // 小球数量
            const n = 50;

            // 生成n个小球，小球颜色、vx、vy都是随机值
            for (let i = 0; i < n; i ++) {
                // 初始化小球
                const ball = new Ball(canvas.width / 2, canvas.height / 2,10,getRandomColor(),)
                ball.vx = Math.random() * 2 - 1 // 生成-1 - 1 的任意数，控制小球运动方向的随机性
                ball.vy = Math.random() * 2 - 1
                balls.push(ball)
            }

            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                balls.forEach(ball => {
                    // 边界检测
                    if (ball.x < -ball.radius
                    || ball.x > canvas.width + ball.radius
                    || ball.y < -ball.radius
                    || ball.y > canvas.height + ball.radius) {
                        // 超出边界后重新生成
                        ball.x = canvas.width / 2
                        ball.y = canvas.height / 2
                        ball.vx = Math.random() * 2 - 1
                        ball.vy = Math.random() * 2 - 1
                    }
                    ball.fill(ctx)

                    ball.x += ball.vx
                    ball.y += ball.vy
                })
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/27.html" width="650" height="450"></iframe>

当我们加入重力影响后


- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }


            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

           // 生成随机颜色
            const getRandomColor = () => {
                return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)])
                    && (color.length == 6) ? color : arguments.callee(color)
                })('')
            }

            // 定义数组，用来缓存小球
            let balls = [];
            // 小球数量
            const n = 50;
            // 重力系数
            const gravity = 0.015;

            // 生成n个小球，小球颜色、vx、vy都是随机值
            for (let i = 0; i < n; i ++) {
                // 初始化小球
                const ball = new Ball(canvas.width / 2, canvas.height / 2,10,getRandomColor(),)


                // ===原本随机弹射===
                ball.vx = Math.random() * 2 - 1 // 生成-1 - 1 的任意数，控制小球运动方向的随机性
                ball.vy = Math.random() * 2 - 1

                // ===散弹效果===
                // ball.vx = 3
                // ball.vy = (Math.random() * 2 - 1) * 3;

                balls.push(ball)
            }

            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                balls.forEach(ball => {
                    // 边界检测
                    if (ball.x < -ball.radius
                    || ball.x > canvas.width + ball.radius
                    || ball.y < -ball.radius
                    || ball.y > canvas.height + ball.radius) {
                        // 超出边界后重新生成
                        ball.x = canvas.width / 2
                        ball.y = canvas.height / 2

                        // ===原本随机弹射===
                        ball.vx = Math.random() * 2 - 1
                        ball.vy = Math.random() * 2 - 1

                        // ===散弹效果===
                        //随机产生3~4之间的任意数
                        // ball.vx = Math.random() + 3;
                        // ball.vy = (Math.random() * 2 - 1) * 3;
                    }
                    ball.fill(ctx)

                    ball.x += ball.vx
                    ball.y += ball.vy
                    ball.vy += gravity
                })
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/28.html" width="650" height="450"></iframe>

### 5.1.4 边界反弹


小球重力案例：小球落下时进行边界检测，如果碰到边界，就会去改变vy(纵轴方向速度)取反。

边界反弹的原理亦是如此。


边界反弹语法如下：

```js
if (ball.x < ball.radius) {
  // 小球碰到了左边界
  ball.x = ball.radius
  vx = -vx
} else if (ball.x > cnv.width - ball.radius) {
  // 小球碰到了右边界
  ball.x = cnv.width - ball.radius
  vx = -vx
}
if (ball.y < ball.radius) {
  // 小球碰到了上边界
  ball.y = ball.radius
  vy = -vy
} else if (ball.y > cnv.height - ball.radius) {
  // 小球碰到了下边界
  ball.y = cnv.height - ball.radius
  vy = -vy
}
```

1. 单球反弹

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            const ball = new Ball(canvas.width / 2, canvas.height / 2,30);

            // 随机生成 -vx -vy -3 - 3
            let vx = (Math.random() * 2 - 1) * 3;
            let vy = (Math.random() * 2 - 1) * 3;


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ball.x += vx
                ball.y += vy
                
                // 边界检测 触碰边界 速度反向
                if (ball.x < ball.radius) {
                    // 小球碰到了左边界
                    ball.x = ball.radius
                    vx = -vx
                } else if (ball.x > (canvas.width - ball.radius)) {
                    // 小球碰到了右边界
                    ball.x = canvas.width - ball.radius
                    vx = -vx
                }
                if (ball.y < ball.radius) {
                    // 小球碰到了上边界
                    ball.y = ball.radius
                    vy = -vy
                } else if (ball.y > (canvas.height - ball.radius)) {
                    // 小球碰到了下边界
                    ball.y = canvas.height - ball.radius
                    vy = -vy
                }

                ball.fill(ctx)
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/29.html" width="650" height="450"></iframe>


2. 多球反弹

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

             // 生成随机颜色
             const getRandomColor = () => {
                return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)])
                    && (color.length == 6) ? color : arguments.callee(color)
                })('')
            }


            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            //定义一个用来存放小球的数组balls
            let balls = [];
            //n表示小球数量
            let n = 10;

            //生成n个小球，其中小球的color、vx、vy都是随机的
            for (let i = 0; i < n; i++) {
                let ball = new Ball(canvas.width / 2, canvas.height / 2, 20, getRandomColor());
                //随机产生-3~3之间的任意数，作为vx、vy的值
                ball.vx = (Math.random() * 2 - 1) * 3;
                ball.vy = (Math.random() * 2 - 1) * 3;
                //添加到数组balls中
                balls.push(ball);
            };


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                //使用forEach()函数遍历数组balls
                balls.forEach(function (ball) {
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    //边界检测
                    //碰到左边界
                    if (ball.x < ball.radius) {
                        ball.x = ball.radius;
                        ball.vx = -ball.vx;
                        //碰到右边界
                    } else if (ball.x > canvas.width - ball.radius) {
                        ball.x = canvas.width - ball.radius;
                        ball.vx = -ball.vx;
                    }
                    //碰到上边界
                    if (ball.y < ball.radius) {
                        ball.y = ball.radius;
                        ball.vy = -ball.vy;
                        //碰到下边界
                    } else if (ball.y > canvas.height - ball.radius) {
                        ball.y = canvas.height - ball.radius;
                        ball.vy = -ball.vy;
                    }

                    ball.fill(ctx);
                })

            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/30.html" width="650" height="450"></iframe>


## 5.2 碰撞检测

碰撞检测，是物体与物体之间的关系。用来检测物体与物体之间是否发生了碰撞，例如：射击游戏，就是检测子弹与敌人的碰撞。

碰撞检测，主要归纳为以下两种实现方式：

- 外接矩形判定法
- 外接圆判定法


### 5.2.1 外接矩形判定法

当我们需要被检测的物体为矩形，或者形态接近于矩形，我们就可以把这个物体抽象为矩形，然后判断两个矩形是否发生了碰撞。实现该方法，我们需要做到两步：1. 找出物体的外接矩形 2. 对外接矩形进行碰撞检测。

如下图所示，有些物体虽然看起来没有发生碰撞，但是在外接矩形检测法的规则下，它们就会被认定为发生了碰撞。

![](/animation/canvas/senior/image/010.png)

在我们实际开发中，如果想要判定两个不规则的图形是否生了碰撞，是非常困难的！但是，我们使用“外接矩形法”去判断，将会特别简单，但是，“外接矩形法”有个明显的缺点，就是误差较大。即使是这样，它简单的判定方式可以减少我们的开发难度，依然备受欢迎，毕竟有得必有失，没有什么完美的算法，只能取最合适的算法。

下边的描述需要大家认真阅读：

判断两个矩形是否发生碰撞，我们只需要判断：两个矩形左上角顶点的坐标所处的范围。如果两个矩形左上角顶点坐标以下四个条件都不满足，则可以判定为发生了碰撞。

```js
 // 判断矩形是否发生了碰撞
const checkRect = (rectA, rectB) => {
  return !(rectA.x + rectA.width < rectB.x ||
         rectB.x + rectB.width < rectA.x ||
         rectA.y + rectA.height < rectB.y ||
         rectB.y + rectB.height < rectA.y)
}
```

1. 小球碰撞

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>
        <div id="msg"></div>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

            // 判断是否发生了碰撞
            const checkRect = (rectA, rectB) => {
                return !(rectA.x + rectA.width < rectB.x ||
                        rectB.x + rectB.width < rectA.x ||
                        rectA.y + rectA.height < rectB.y ||
                        rectB.y + rectB.height < rectA.y)
            }
            // 获取小球的外接矩形
            const getRect = (ball) => {
                return {
                    x: ball.x - ball.radius,
                    y: ball.y - ball.radius,
                    width: ball.radius * 2,
                    height: ball.radius * 2
                }
            }
            // 定义鼠标事件
            const mouseEvent = (element) => {
                let mouse = { x: 0, y: 0 } // 存储鼠标位置信息
                element.addEventListener('mousemove', e => {
                    let x = e.pageX
                    let y = e.pageY
                    // 计算鼠标在canvas画布中的相对位置
                    mouse.x = x - element.offsetLeft
                    mouse.y = y - element.offsetTop
                })
                return mouse
            }



            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

   

            // 定义小球A
            const ballA = new Ball(canvas.width / 2, canvas.height / 2, 30);
            // 获取小球A的外接矩形
            const rectA = getRect(ballA);

            const getMouse = mouseEvent(canvas);




            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制小球A和它的外接矩形
                ballA.fill(ctx)
                ctx.strokeRect(rectA.x, rectA.y, rectA.width, rectA.height)

                // 定义一个追随鼠标位移的小球B
                const ballB = new Ball(getMouse.x, getMouse.y, 30, 'red')
                // 获取B的外接矩形
                const rectB = getRect(ballB)
                // 绘制B以及它的外接矩形
                ballB.fill(ctx)
                ctx.strokeRect(rectB.x, rectB.y, rectB.width, rectB.height)

                // 碰撞检测
                if (checkRect(rectA, rectB)) {
                    document.querySelector('#msg').innerHTML = '撞上了！'
                } else {
                    document.querySelector('#msg').innerHTML = '没撞上'
                }
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/31.html" width="650" height="450"></iframe>


2. 落方块


- 代码

```html
<!DOCTYPE html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <title>Document</title>
</head>
<body>
    <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>
    <script>
         class Box{
            constructor(x = 0,y = 0,width = 12,height = 12,color = '#6699FF'){
                //小球中心的x坐标
                this.x = x;
                //小球中心的y坐标
                this.y = y;
                // 宽度
                this.width = width;
                // 高度
                this.height = height;
                // 小球颜色
                this.color = color;
                // x轴 y轴 速度
                this.vx = 0;
                this.vy = 0;

            }

            fill (ctx){
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.fillRect(this.x, this.y,this.width,this.height );
                ctx.closePath();
                ctx.fill()
            }
        }
        // 定义鼠标事件
        const mouseEvent = (element) => {
            let mouse = { x: 0, y: 0 } // 存储鼠标位置信息
            element.addEventListener('mousemove', e => {
                let x = e.pageX
                let y = e.pageY
                // 计算鼠标在canvas画布中的相对位置
                mouse.x = x - element.offsetLeft
                mouse.y = y - element.offsetTop
            })
            return mouse
        }

        // 生成随机颜色
        const getRandomColor = () => {
            return '#' +
            (function (color) {
                return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)])
                && (color.length == 6) ? color : arguments.callee(color)
            })('')
        }

        // 判断是否发生了碰撞
        const checkRect = (rectA, rectB) => {
            return !(rectA.x + rectA.width < rectB.x ||
                    rectB.x + rectB.width < rectA.x ||
                    rectA.y + rectA.height < rectB.y ||
                    rectB.y + rectB.height < rectA.y)
        }

        // 获取按键方向
        const getKey = () => {
            let key = {}
            window.addEventListener('keydown', e => {
                if (e.keyCode === 38 || e.keyCode === 87) {
                    key['direction'] = 'up'
                } else if (e.keyCode === 39 || e.keyCode === 68) {
                    key['direction'] = 'right'
                } else if (e.keyCode === 40 || e.keyCode === 83) {
                    key['direction'] = 'down'
                } else if (e.keyCode === 37 || e.keyCode === 65) {
                    key['direction'] = 'left'
                } else {
                    key['direction'] = null
                }
            }, false)
            return key
        }


        //定义一个函数createBox()，用于创建一个新的方块
        function createBox() {
            let x = Math.random() * canvas.width;
            let y = 0;
            let width = Math.random() * 40 + 10;
            let height = Math.random() * 40 + 10;
            let color = getRandomColor();
            let box = new Box(x, y, width, height, color);
            //添加到数组boxes中
            boxes.push(box);
            return box;
        }



        // 获取canvas对象
        const canvas = document.getElementById("myCanvas");
        // 获取上下文对象context
        const ctx = canvas.getContext("2d");

        //定义一个用来存放方块的数组boxes
        let boxes = [];
        //定义一个“当前活动”的方块
        let activeBox = createBox();
        
        //加入鼠标控制
        // var key = getKey();
        // window.addEventListener("keydown", function () {
        //     switch (key.direction) {
        //         case "down":
        //             activeBox.y += 5;
        //             break;
        //         case "left":
        //             activeBox.x -= 10;
        //             break;
        //         case "right":
        //             activeBox.x += 10;
        //             break;
        //     }
        // }, false);

        
        //定义方块的Y轴速度
        let vy = 2;




        (function frame() {
            window.requestAnimationFrame(frame);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            activeBox.y += vy;

            //边界检测，如果到达底部，则创建一个新的box
            if (activeBox.y > canvas.height - activeBox.height) {
                activeBox.y = canvas.height - activeBox.height;
                activeBox = createBox();
            }
            //遍历数组boxes，以便单独处理每一个box
            boxes.forEach(function (box) {
                /*如果当前遍历的box不是“活动方块（activeBox）”，并且当前遍历的方块与“活动方块（activeBox）”碰上了，则创建新的方块*/
                if (activeBox !== box && checkRect(activeBox, box)) {
                    activeBox.y = box.y - activeBox.height;
                    activeBox = createBox();
                }
                box.fill(ctx);
            });
        })();

    </script>
</body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/32.html" width="650" height="450"></iframe>


### 5.2.2 外接圆判定法


“外接圆判定法”指的是，当一个物体为圆，或者接近圆，我们可以把这个物体抽象成圆，然后判断这两个圆是否发生了碰撞。实现该方法，我们需要做到两步：1. 找出物体的外接圆 2. 对外接圆进行碰撞检测。

如下图所示，有些物体虽然看起来没有发生碰撞，但是在外接圆检测法的规则下，它们就会被认定为发生了碰撞。

![](/animation/canvas/senior/image/011.png)

外接圆碰撞检测很简单：只需要判断两个圆圆心距离是否大于或等于两个圆的半径之和，是，则无碰撞。如果两个圆圆心距离小于两个圆的半径之和，则判定为发生了碰撞。

```js
// 判断圆是否发生了碰撞
const checkCircle = (circleA, circleB) => {
  const dx = circleB.x - circleA.x
  const dy = circleB.y - circleA.y
  const distance = Math.sqrt(dx * dx + dy * dy)
  if (distance < (circleA.radius + circleB.radius)) {
    return true
  }
  return false
}
```

1. 小球手动碰撞

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>
        <div id="msg"></div>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

           // 判断圆是否发生了碰撞
            const checkCircle = (circleA, circleB) => {
                const dx = circleB.x - circleA.x
                const dy = circleB.y - circleA.y
                const distance = Math.sqrt(dx * dx + dy * dy)
                if (distance < (circleA.radius + circleB.radius)) {
                    return true
                }
                return false
            }
                        // 定义鼠标事件
            const mouseEvent = (element) => {
                let mouse = { x: 0, y: 0 } // 存储鼠标位置信息
                element.addEventListener('mousemove', e => {
                    let x = e.pageX
                    let y = e.pageY
                    // 计算鼠标在canvas画布中的相对位置
                    mouse.x = x - element.offsetLeft
                    mouse.y = y - element.offsetTop
                })
                return mouse
            }

            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            // 定义小球A
            const ballA = new Ball(canvas.width / 2, canvas.height / 2, 30);
            const getMouse = mouseEvent(canvas);

            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制小球
                ballA.fill(ctx)

                // 定义一个追随鼠标位移的小球B
                const ballB = new Ball(getMouse.x, getMouse.y, 30, 'red')
                ballB.fill(ctx)

                // 碰撞检测
                if (checkCircle(ballA, ballB)) {
                    document.querySelector('#msg').innerHTML = '撞上了！'
                } else {
                    document.querySelector('#msg').innerHTML = '没撞上'
                }
            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/33.html" width="650" height="450"></iframe>



2. 小球自动碰撞

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>
        <div id="msg"></div>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

           // 判断圆是否发生了碰撞
            const checkCircle = (circleA, circleB) => {
                const dx = circleB.x - circleA.x
                const dy = circleB.y - circleA.y
                const distance = Math.sqrt(dx * dx + dy * dy)
                if (distance < (circleA.radius + circleB.radius)) {
                    return true
                }
                return false
            }
         
            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            // 定义小球A
            //定义两个小球：ballA和ballB
            var ballA = new Ball(0, canvas.height / 2, 30, "#FF6699");
            var ballB = new Ball(canvas.width, canvas.height / 2, 30, "#66CCFF");
            //定义小球X轴速度
            var vx = 2;


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 定义一个追随鼠标位移的小球B
                ballA.x += vx;
                ballB.x += -vx;

                //如果发生碰撞，则速度取反
                if (checkCircle(ballB, ballA)) {
                    vx = -vx;
                }

                // 绘制小球
                ballA.fill(ctx)
                ballB.fill(ctx)

                // 继续进行动画
                if(ballA.x < 30 && vx < 0){
                    vx = -vx;
                }

            })();
        </script>
    </body>
</html>
```

- canvas 示例

<iframe src="/note-front/animation/canvas/senior/html/34.html" width="650" height="450"></iframe>


### 5.2.3 多物体碰撞

n个物体，n×(n-1)/2种碰撞情况。

```js
balls.forEach(function(ballA, i) {
	for (var j = i + 1; j < balls.length; j++) {
		var ballB = balls[j];
		if (tools.checkCircle(ballB, ballA)) {
			//...
		}
	}
});
```

1. 小球相撞

- 代码

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
    </head>
    <body>
        <canvas id="myCanvas" width="600" height="400" style="background: #ccc"> </canvas>
        <div id="msg"></div>

        <script>
            class Ball{
                constructor(x = 0,y = 0,radius = 12,color = '#6699FF'){
                    //小球中心的x坐标
                    this.x = x;
                     //小球中心的y坐标
                    this.y = y;
                    //小球半径
                    this.radius = radius;
                    // 小球颜色
                    this.color = color;
                    // x轴 y轴 速度
                    this.vx = 0;
                    this.vy = 0;

                }

                fill (ctx){
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 360 * Math.PI / 180);
                    ctx.closePath();
                    ctx.fill()
                }
            }

            // 生成随机颜色
            const getRandomColor = () => {
                return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)])
                    && (color.length == 6) ? color : arguments.callee(color)
                })('')
            }

             // 判断圆是否发生了碰撞
             const checkCircle = (circleA, circleB) => {
                const dx = circleB.x - circleA.x
                const dy = circleB.y - circleA.y
                const distance = Math.sqrt(dx * dx + dy * dy)
                if (distance < (circleA.radius + circleB.radius)) {
                    return true
                }
                return false
            }

            //碰撞检测（小球与小球）
            function checkCollision(ballA, i) {
                for (var j = i + 1; j < balls.length; j++) {
                    var ballB = balls[j];
                    //如果两个小球碰撞，则碰撞后vx、vy都取相反值
                    if (checkCircle(ballB, ballA)) {
                        ballA.vx = -ballA.vx;
                        ballA.vy = -ballA.vy;
                        ballB.vx = -ballB.vx;
                        ballB.vy = -ballB.vy;


                        //每次碰撞，小球的x、y都加入偏移量，避免相互重叠
                        if (ballA.vx > 0) {
                            ballA.x += 5;
                        } else {
                            ballA.x -= 5;
                        }
                        if (ballA.vy > 0) {
                            ballA.y += 5;
                        } else {
                            ballA.y -= 5;
                        }
                        if (ballB.vx > 0) {
                            ballB.x += 5;
                        } else {
                            ballB.x -= 5;
                        }
                        if (ballB.vy > 0) {
                            ballB.y += 5;
                        } else {
                            ballB.y -= 5;
                        }

                    }
                }
            }

            //边界检测（小球与边界）
            function checkBorder(ball) {
                //碰到左边界
                if (ball.x < ball.radius) {
                    ball.x = ball.radius;
                    ball.vx = -ball.vx;
                    //碰到右边界
                } else if (ball.x > canvas.width - ball.radius) {
                    ball.x = canvas.width - ball.radius;
                    ball.vx = -ball.vx;
                }
                //碰到上边界
                if (ball.y < ball.radius) {
                    ball.y = ball.radius;
                    ball.vy = -ball.vy;
                    //碰到下边界
                } else if (ball.y > canvas.height - ball.radius) {
                    ball.y = canvas.height - ball.radius;
                    ball.vy = -ball.vy;
                }
            }

            //绘制小球
            function drawBall(ball) {
                ball.fill(ctx);
                ball.x += ball.vx;
                ball.y += ball.vy;
            }

            // 获取canvas对象
            const canvas = document.getElementById("myCanvas");
            // 获取上下文对象context
            const ctx = canvas.getContext("2d");

            let n = 8;
            let balls = [];

            //生成n个小球，小球的x、y、color、vx、vy属性取的都是随机值
            for (let i = 0; i < n; i++) {
                ball = new Ball();
                ball.x = Math.random() * canvas.width;
                ball.y = Math.random() * canvas.height;
                ball.radius = 20;
                ball.color = getRandomColor();
                ball.vx = Math.random() * 6 - 3;
                ball.vy = Math.random() * 6 - 3;
                //添加到数组balls中
                balls.push(ball);
            }


            (function drawFrame() {
                window.requestAnimationFrame(drawFrame, canvas);
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                //碰撞检测
                balls.forEach(checkCollision);
                //边界检测
                balls.forEach(checkBorder);
                //绘制小球
                balls.forEach(drawBall);

            })();
        </script>
    </body>
</html>
```

<iframe src="/note-front/animation/canvas/senior/html/35.html" width="650" height="450"></iframe>
