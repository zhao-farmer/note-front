<script lang="ts" setup>
    import {ref} from 'vue'
    let state1 = ref(false)
    let state2 = ref(false)
    let state3 = ref(false)
    let state4 = ref(false)
    let state5 = ref(false)
    let state6 = ref(false)
    let state7 = ref(false)
    let state8 = ref(false)
</script>


# 二、 进阶

## 2.1 插槽

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        import { Application, Assets, Color, Container, Texture, Sprite, Graphics, Text, TextStyle, BlurFilter, FillGradient } from "../js/pixi.mjs";

        //使用立即执行函数进行调用
        (async () => {
            // 创建应用程序
            const app = new Application();

            // 应用程序初始化
            await app.init({ 
                background: "#1099bb",
                width: 800,
                height:600,
            });

            // 应用程序页面添加到网页上
            document.body.appendChild(app.canvas);

            // 加载纹理
            await Assets.load([
                "../assets/images/eggHead.png", 
                "../assets/images/flowerTop.png", 
                "../assets/images/helmlok.png", 
                "../assets/images/skully.png"
            ]);

            const REEL_WIDTH = 160;
            const SYMBOL_SIZE = 150;

            // 创建不同的插槽符号
            const slotTextures = [
                Texture.from("../assets/images/eggHead.png"),
                Texture.from("../assets/images/flowerTop.png"),
                Texture.from("../assets/images/helmlok.png"),
                Texture.from("../assets/images/skully.png"),
            ];

            // 创建卷轴信息数组
            const reels = [];
            //创建一个滚动容器
            const reelContainer = new Container();
            // 判断几条reel（卷轴）
            for (let i = 0; i < 5; i++) {
                //新增容器
                const rc = new Container();
                //并设置列的位置
                rc.x = i * REEL_WIDTH;
                // 添加容器内
                reelContainer.addChild(rc);

                //设置卷轴信息，并把创建的容器赋予其中一个属性
                const reel = {
                    container: rc,
                    symbols: [],
                    position: 0,
                    previousPosition: 0,
                    blur: new BlurFilter(),
                };

                //滤镜的位置
                reel.blur.blurX = 0;
                reel.blur.blurY = 0;
                //将卷轴的滤镜信息赋予新建的容器
                rc.filters = [reel.blur];

                // 构建每一列上每个符号
                for (let j = 0; j < 4; j++) {
                    //随机显示4个图片上的一个 作为新建精灵的纹理
                    const symbol = new Sprite(slotTextures[Math.floor(Math.random() * slotTextures.length)]);
                    // 缩放精灵以适应符号区域。  宽与高与精灵宽与高比例更小的赋予 设置的比例
                    symbol.scale.x = symbol.scale.y = Math.min(SYMBOL_SIZE / symbol.width, SYMBOL_SIZE / symbol.height);

                    // y轴的位置与循环j值相关
                    symbol.y = j * SYMBOL_SIZE;
                    // x值 设置为容器的宽度 减去精灵本身的宽度的一半  如果部位整数进行四舍五入
                    symbol.x = Math.round((SYMBOL_SIZE - symbol.width) / 2);
                    // 将当前数据加入到卷轴信息中
                    reel.symbols.push(symbol);
                    // 每一个精灵都加入到当前列的容器里
                    rc.addChild(symbol);
                }
                // 卷轴信息加入到数组中
                reels.push(reel);
            }
            // 将卷轴容器加入到舞台上
            app.stage.addChild(reelContainer);

            //覆盖顶部与底部 并放入到reelContainer（容器）
            const margin = (app.screen.height - SYMBOL_SIZE * 3) / 2;
            //y轴起始位置 margin 高度减去要显示的高度 除以2
            reelContainer.y = margin;
            //x轴起始位置 宽度减去要显示宽度 除以2
            reelContainer.x = Math.round(app.screen.width - REEL_WIDTH * 5) / 2;
            // 上半部分设置黑色
            const top = new Graphics().rect(0, 0, app.screen.width, margin).fill({ color: 0x0 });
            // 下半部分设置黑色
            const bottom = new Graphics().rect(0, SYMBOL_SIZE * 3 + margin, app.screen.width, margin).fill({ color: 0x0 });

            // 创建渐变填充
            const fill = new FillGradient(0, 0, 0, 36 * 1.7);

            // colors 两个颜色之间出现的颜色 将循环的颜色放入控件中加载，并转成16位
            const colors = [0xffffff, 0x00ff99].map(color => Color.shared.setValue(color).toNumber());

            //多少分之一 减价对应的颜色
            colors.forEach((number, index) => {
                const ratio = index / colors.length;

                fill.addColorStop(ratio, number);
            });

            //添加文本的样式
            const style = new TextStyle({
                fontFamily: "Arial",
                fontSize: 36,
                fontStyle: "italic",
                fontWeight: "bold",
                fill: { fill },
                stroke: { color: 0x4a1850, width: 5 },
                dropShadow: {
                    color: 0x000000,
                    angle: Math.PI / 6,
                    blur: 4,
                    distance: 6,
                },
                wordWrap: true,
                wordWrapWidth: 440,
            });

            const playText = new Text("启动滚动!", style);
            //添加下面中间的位置
            playText.x = Math.round((bottom.width - playText.width) / 2);
            //app.screen.height - margin 下方的位置  剩下的是设置文本的位置
            playText.y = app.screen.height - margin + Math.round((margin - playText.height) / 2);
            //8.0之后不建议使用容器之外定义子项
            bottom.addChild(playText);

            // 添加头部文本
            const headerText = new Text("PIXI怪物老虎机!", style);

            headerText.x = Math.round((top.width - headerText.width) / 2);
            headerText.y = Math.round((margin - headerText.height) / 2);
            top.addChild(headerText);

            app.stage.addChild(top);
            app.stage.addChild(bottom);

            // 设置交互性。
            // 点击时触发信息
            bottom.eventMode = "static";
            //鼠标样式改为手指类型
            bottom.cursor = "pointer";
            //添加事件  鼠标点击时触发事件  addListener与on一样都是监控用的
            bottom.addListener("pointerdown", () => {
                startPlay();
            });

            let running = false;

            // 功能开始播放。
            function startPlay() {
                //防止多次点击
                if (running) return;
                running = true;

                //循环每条数组
                for (let i = 0; i < reels.length; i++) {
                    //每一列的对象
                    const r = reels[i];
                    //判断0-3之间
                    const extra = Math.floor(Math.random() * 3);
                    //目标对象  当前位置 + 10 + (0-15) + (0-3)
                    const target = r.position + 10 + i * 5 + extra;
                    // 定制时间 最小2500 最大 2500 + 1800 + 1800 = 5100
                    const time = 2500 + i * 600 + extra * 600;
                    //将配置加入 寻要循环的位置
                    tweenTo(r, "position", target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);
                }
            }

            // 当前轮询是否已结束
            function reelsComplete() {
                running = false;
            }

            // 监听动画更新
            app.ticker.add(() => {
                // 更新插槽
                for (let i = 0; i < reels.length; i++) {
                    //获取对象
                    const r = reels[i];
                    //根据速度更新模糊滤镜y值。
                    //如果也考虑到时间，这会更好。现在模糊取决于帧率。
                    // 设置Y轴模糊度
                    r.blur.blurY = (r.position - r.previousPosition) * 8;
                    //之前的位置
                    r.previousPosition = r.position;

                    // 循环其中的条状容器 .
                    for (let j = 0; j < r.symbols.length; j++) {
                        // 每一个对象
                        const s = r.symbols[j];
                        //当前对象的Y轴
                        const prevy = s.y;
                        //新的Y值
                        // 下面的事件中 position都是从初始值一直到目标值
                        // 每次posion变化 y轴也会花生变化

                        s.y = ((r.position + j) % r.symbols.length) * SYMBOL_SIZE - SYMBOL_SIZE;
                        // y轴 一直会随着r.position 变化而花生变化
                        // 当position 从大于1的数回到1时，y轴也会花生相应的变化
                        // console.log(s.y, prevy);

                        // 能整除4 且有余数(小数)的新值都是负数
                        // 能整除4 无余数 新值也是负值 但整除4等于1 时 下面的判断就会出现错误
                        // 不能整除4 不管有没有余数都不会发生改变

                        //结果是 symbols.length 下四个精灵  每个循环四次都会改变一下纹理
                        // y轴移动时 还会改变纹理的成功了
                        if (s.y < 0 && prevy > SYMBOL_SIZE) {
                            //获取新的随机纹理
                            s.texture = slotTextures[Math.floor(Math.random() * slotTextures.length)];
                            //x轴y轴改变
                            s.scale.x = s.scale.y = Math.min(SYMBOL_SIZE / s.texture.width, SYMBOL_SIZE / s.texture.height);
                            //x轴也改变
                            s.x = Math.round((SYMBOL_SIZE - s.width) / 2);
                        }
                    }
                }
            });

            // 非常简单且实用函数 在实际产品中，这应该被一个适当的library （库）所取代。
            const tweening = [];

            function tweenTo(object, property, target, time, easing, onchange, oncomplete) {
                const tween = {
                    object,
                    property,
                    propertyBeginValue: object[property],
                    target,
                    easing,
                    time,
                    change: onchange,
                    complete: oncomplete,
                    start: Date.now(),
                };

                tweening.push(tween);

                return tween;
            }
            // 监听动画更新
            app.ticker.add(() => {
                //获取当前时间
                const now = Date.now();
                //移除集合
                const remove = [];
                //循环替换集合
                for (let i = 0; i < tweening.length; i++) {
                    //获取当前对象
                    const t = tweening[i];
                    //判断 当前获取的时间减去开始插入时的时间 再除以定制时间 随着时间的增长 会越来越趋近于1
                    //值是0-1 越来越接近于1
                    const phase = Math.min(1, (now - t.start) / t.time);
                    // t.object等于当前数列的对象 设置的当前属性position  = lerp函数[上次移动位置,目标对象,箭头函数 ]
                    //位置  最后的值大于 t.easing(phase)接近于想要的位置
                    t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));
                    // console.log(t.propertyBeginValue, t.target, t.easing(phase), t.object[t.property]);
                    //t.change存在，执行change函数，默认为空
                    if (t.change) t.change(t);
                    //如果都是1
                    if (phase === 1) {
                        //将目标对象 赋予position
                        t.object[t.property] = t.target;
                        //如果是最后一位开始将运行状态running改为true
                        if (t.complete) t.complete(t);
                        //将对象插入到移除列表中
                        remove.push(t);
                    }
                }
                //按照循环进行删除
                for (let i = 0; i < remove.length; i++) {
                    tweening.splice(tweening.indexOf(remove[i]), 1);
                }
            });

            //基本警报功能
            function lerp(a1, a2, t) {
                return a1 * (1 - t) + a2 * t;
            }

            // tweenjs的回退功能。
            // 直接返回一个箭头函数  这个箭头函数传入的值是0-1 传入的值越接近1返回的值也越接近于1
            function backout(amount) {
                // --t 传入的数据先前去1
                // 如果t等于0.1  --t等于 0.9 t * t = 0.81  结果等于 0.81 * -0.58 + 1 = 0.311499999999999
                // 如果t > 0.67 小于时 返回值 大于1
                return t => --t * t * ((amount + 1) * t + amount) + 1;
            }
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state1 = !state1">{{state1?"关闭展示":"开启展示"}}</button>
<div v-if="state1">
    <iframe src="/note-front/animation/pixi/example/html/09.html" width="850" height="650"></iframe>
</div>

## 2.2 刮刮卡

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        import { Application, Assets, Graphics, Sprite, RenderTexture, Point } from "../js/pixi.mjs";

        (async () => {
            // 创建应用程序
            const app = new Application();

            // 初始化应用程序
            await app.init({ 
                height:600,
                width:800, 
            });

            // 将应用程序添加到网页中
            document.body.appendChild(app.canvas);

            // 画一个原型纹理将被作为我们的笔刷
            const brush = new Graphics().circle(0, 0, 50).fill({ color: 0xffffff });

            // 创建一条线来插值绘制的点
            const line = new Graphics();

            // 加载纹理
            await Assets.load([
                "../assets/images/bg_grass.jpg", 
                "../assets/images/bg_rotate.jpg"
            ]);
            //获取宽与高
            const { width, height } = app.screen;
            //将舞台大小设置屏幕的大小
            const stageSize = { width, height };
            //设置精灵并赋值屏幕的宽度与高度
            const background = Object.assign(Sprite.from("../assets/images/bg_grass.jpg"), stageSize);
            const imageToReveal = Object.assign(Sprite.from("../assets/images/bg_rotate.jpg"), stageSize);
            //创建渲染纹理
            const renderTexture = RenderTexture.create(stageSize);
            //将这个纹理赋值给新的精灵
            const renderTextureSprite = new Sprite(renderTexture);
            //新精灵作为遮罩 当遮罩有值的时候 这个精灵回显示出来
            imageToReveal.mask = renderTextureSprite;
            // 舞台上把这三者添加上
            // 由于renderTextureSprite初始值为空 所以imageToReveal精灵显示不出  只能 显示background
            // 更改renderTextureSprite的遮罩信息，可以将imageToReveal数据显示出来
            app.stage.addChild(background, imageToReveal, renderTextureSprite);

            //设置事件启动
            app.stage.eventMode = "static";
            //点击命中返回的范围是整个屏幕
            app.stage.hitArea = app.screen;
            //分别加载四种监控 鼠标按下 鼠标释放 在访问区域的外部 指针在页面上的移动
            app.stage.on("pointerdown", pointerDown)
                .on("pointerup", pointerUp)
                .on("pointerupoutside", pointerUp)
                .on("pointermove", pointerMove);
            //拖拽进行的状态
            let dragging = false;
            // 最后按下鼠标指针
            let lastDrawnPoint = null;

            //传入的参数 鼠标的位置
            function pointerMove({ global: { x, y } }) {
                //如果鼠标按下了
                if (dragging) {
                    //笔刷进入当前位置
                    brush.position.set(x, y);
                    // 文档路径错误，哎
                    app.renderer.render({
                        //主体 笔刷
                        container: brush,
                        //目标渲染纹理
                        target: renderTexture,
                        // 清理
                        clear: false,
                        //跳过清理转换
                        skipUpdateTransform: false,
                    });
                    //这个判断 最后画的点是否存在  是第二次进入
                    if (lastDrawnPoint) {
                        //将上次移动的位置移动到这次的位置 宽度设置100且颜色为白色
                        line.clear()
                            .moveTo(lastDrawnPoint.x, lastDrawnPoint.y)
                            .lineTo(x, y)
                            .stroke({ width: 100, color: 0xffffff });
                        //将新内容放到渲染纹理中
                        app.renderer.render({
                            container: line,
                            target: renderTexture,
                            clear: false,
                            skipUpdateTransform: false,
                        });
                    }
                    //如果为空新建一个Point 否则使用上次的
                    lastDrawnPoint = lastDrawnPoint || new Point();
                    //这只x与y的坐标
                    lastDrawnPoint.set(x, y);
                }
            }
            //按下后 可进行移动
            function pointerDown(event) {
                dragging = true;
                pointerMove(event);
            }
            // 松开后两个配置都为空
            function pointerUp(event) {
                dragging = false;
                lastDrawnPoint = null;
            }
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state2 = !state2">{{state2?"关闭展示":"开启展示"}}</button>
<div v-if="state2">
    <iframe src="/note-front/animation/pixi/example/html/10.html" width="850" height="650"></iframe>
</div>

## 2.3 星空

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        import { Application, Assets, Sprite } from "../js/pixi.mjs";

        (async () => {
            // 创建应用程序
            const app = new Application();

            // 初始化应用程序
            await app.init({ 
                height:600,
                width:800, 
            });

            // 应用程序添加到页面上
            document.body.appendChild(app.canvas);

            // 加载星星纹理
            const starTexture = await Assets.load("../assets/images/star.png");

            //星星数量
            const starAmount = 1000;
            //摄像机z轴
            let cameraZ = 0;
            //视厂
            const fov = 20;
            //基础速度
            const baseSpeed = 0.025;
            //速度
            let speed = 0;
            //曲速
            let warpSpeed = 0;
            // 星星伸展
            const starStretch = 5;
            // 星星基础大小
            const starBaseSize = 0.05;

            // 创建星星集合
            const stars = [];

            for (let i = 0; i < starAmount; i++) {
                // star 精灵对象
                const star = {
                    sprite: new Sprite(starTexture),
                    z: 0,
                    x: 0,
                    y: 0,
                };
                //设置精灵的锚点
                star.sprite.anchor.x = 0.5;
                star.sprite.anchor.y = 0.7;
                //放入随机位置
                randomizeStar(star, true);
                //将每个star精灵添加到画布上
                app.stage.addChild(star.sprite);
                //将star 添加集合中
                stars.push(star);
            }
            //星星的随机位置
            function randomizeStar(star, initial) {
                //z轴 如果为true 开始随机0-2000 之内的数据 否则摄像机轴 加上0-1000 加上2000
                star.z = initial ? Math.random() * 2000 : cameraZ + Math.random() * 1000 + 2000;

                // 放射性随机的坐标来确认star位置 ，这样没有star撞到相机
                // 角度 0 到 6.28.. 之间
                const deg = Math.random() * Math.PI * 2;
                // 距离
                const distance = Math.random() * 50 + 1;
                //正弦 余弦 都在 -1到1 之间
                star.x = Math.cos(deg) * distance;
                star.y = Math.sin(deg) * distance;
            }

            // 每5秒更改一次飞行速度
            setInterval(() => {
                //五秒钟等于0 五秒钟等于1
                warpSpeed = warpSpeed > 0 ? 0 : 1;
            }, 5000);

            // 监听动画更新
            app.ticker.add(time => {
                // 简单的缓缓移动 当用于真实时，应将其更改为适当的慢动功能
                // 第一次  warpSpeed等于1 speed越来越接近1
                // 第二次  由接近1的数 开始无线接近于0 会出现 4.662602347812701e-9 这样的数 其实这个数比0.0000010177704155697795 更小
                speed += (warpSpeed - speed) / 20;
                //判断摄像机的z轴 默认是0 一直再变大
                // 如果 time.deltaTime 等于1 最大加的值 12.5  最小加的值 2.5
                // warpSpeed 是1的时候 cameraZ增长的快 是0的时候 cameraZ增长的慢
                cameraZ += time.deltaTime * 10 * (speed + baseSpeed);

                //循环一千颗星星
                for (let i = 0; i < starAmount; i++) {
                    // 每一颗星星的对象
                    const star = stars[i];
                    //当前星星的z轴小于摄像机的z轴  重新设定位置
                    // 由于摄像机一直会增大 star的z轴也会变化
                    if (star.z < cameraZ) randomizeStar(star);

                    // 用非常简单的投影将star的三维位置映射到二维
                    // 这个z 调整后 1-1000  + 2000 距离
                    // 随着 cameraZ慢慢增大 得到的结果又会慢慢缩小 达到某个阈值又会从头开始
                    const z = star.z - cameraZ;

                    // 第一次x 与y 都在 -1 到1 之间 星星对象中精灵的位置 都在中心一个点上
                    // 视厂 屏幕距离 (fov / z) * app.renderer.screen.width 其实就是判断距离屏幕眼镜的z轴距离，这个应该学习图形学的时候会学到吧
                    star.sprite.x = star.x * (fov / z) * app.renderer.screen.width + app.renderer.screen.width / 2;
                    star.sprite.y = star.y * (fov / z) * app.renderer.screen.width + app.renderer.screen.height / 2;

                    // 计算star的尺度和自转。
                    const dxCenter = star.sprite.x - app.renderer.screen.width / 2;
                    const dyCenter = star.sprite.y - app.renderer.screen.height / 2;
                    //距离中心点 sqrt平方根
                    const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);
                    if (i % 1000 == 0) {
                        console.log(speed, distanceCenter);
                    }

                    //距离比例
                    const distanceScale = Math.max(0, (2000 - z) / 2000);

                    //x 的比例 星星基础比例 x 距离比例
                    star.sprite.scale.x = distanceScale * starBaseSize;

                    //恒星朝向中心，因此y轴朝向中心。
                    //根据我们移动的速度和拉伸系数来缩放恒星
                    //取决于它离中心有多远。

                    // y轴比例 星星基础比例 x 距离比例
                    // speed越来越接近1 y轴会边长
                    // distanceCenter speed越接近0变化越小 speed越接近1变化越大
                    star.sprite.scale.y = distanceScale * starBaseSize + (distanceScale * speed * starStretch * distanceCenter) / app.renderer.screen.width;
                    //atan2 返回值再 -PI与PI之间 代表旋转的角度在0度与360度之间
                    star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;
                }
            });
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state3 = !state3">{{state3?"关闭展示":"开启展示"}}</button>
<div v-if="state3">
    <iframe src="/note-front/animation/pixi/example/html/11.html" width="850" height="650"></iframe>
</div>

## 2.4 结合three.js

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        // 从PixiJS和Three.js导入所需类
        import { Container, Graphics, Text, WebGLRenderer } from "../js/pixi.mjs";
        import * as THREE from "../js/three.mjs";

        // 自执行异步函数用于设置演示场景
        (async () => {
            // 初始化窗口尺寸
            let WIDTH = 800;
            let HEIGHT = 600;

            // === THREE.JS 设置 ===
            // 创建带抗锯齿和模板缓冲的Three.js WebGL渲染器
            const threeRenderer = new THREE.WebGLRenderer({ antialias: true, stencil: true });

            // 配置Three.js渲染器尺寸和背景色
            threeRenderer.setSize(WIDTH, HEIGHT);
            threeRenderer.setClearColor(0xdddddd, 1); // 浅灰色背景
            document.body.appendChild(threeRenderer.domElement);

            // 创建Three.js场景
            const scene = new THREE.Scene();

            // 设置70°视野的透视相机
            const threeCamera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT);

            threeCamera.position.z = 50; // 将相机后移以查看场景
            scene.add(threeCamera);

            // 创建立方体网格
            const boxGeometry = new THREE.BoxGeometry(30, 30, 30);
            const basicMaterial = new THREE.MeshBasicMaterial({ color: 0x0095dd }); // 蓝色材质
            const cube = new THREE.Mesh(boxGeometry, basicMaterial);

            scene.add(cube);

            // === PIXI.JS 设置 ===
            // 创建与Three.js共享WebGL上下文的PixiJS渲染器
            const pixiRenderer = new WebGLRenderer();

            // 使用共享上下文初始化PixiJS渲染器
            await pixiRenderer.init({
                context: threeRenderer.getContext(),
                width: WIDTH,
                height: HEIGHT,
                clearBeforeRender: false, // 不清空画布，由Three.js处理
            });

            // 创建PixiJS场景图
            const stage = new Container();

            // 创建黄色圆角矩形UI元素
            const uiLayer = new Graphics().roundRect(20, 80, 300, 300, 20).fill(0xffff00);

            // 添加文字覆盖层
            const text = new Text({ text: "Pixi and Three.js", style: { fontFamily: "Arial", fontSize: 24, fill: "black" } });

            uiLayer.addChild(text);
            stage.addChild(uiLayer);

            // 动画循环
            function loop() {
                // 持续旋转立方体
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

                // 使用正弦波动画化UI层位置
                uiLayer.y = ((Math.sin(Date.now() * 0.001) + 1) * 0.5 * WIDTH) / 2;

                // 渲染Three.js场景
                threeRenderer.resetState();
                threeRenderer.render(scene, threeCamera);

                // 渲染PixiJS场景
                pixiRenderer.resetState();
                pixiRenderer.render({ container: stage });

                // 继续动画循环
                requestAnimationFrame(loop);
            }

            // 启动动画循环
            requestAnimationFrame(loop);

            // 处理窗口大小调整
            window.addEventListener("resize", () => {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;

                // 更新Three.js渲染器
                threeRenderer.setSize(WIDTH, HEIGHT);
                // 更新Three.js相机宽高比确保正确渲染
                threeCamera.aspect = WIDTH / HEIGHT;
                threeCamera.updateProjectionMatrix();

                // 更新PixiJS渲染器
                pixiRenderer.resize(WIDTH, HEIGHT);
            });
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state4 = !state4">{{state4?"关闭展示":"开启展示"}}</button>
<div v-if="state4">
    <iframe src="/note-front/animation/pixi/example/html/12.html" width="850" height="650"></iframe>
</div>

## 2.5 鼠标轨迹

- 代码

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
  <body>
  <script type="module">
    import { Application, Assets, Point, MeshRope } from "../js/pixi.mjs";

    (async () => {
      // 创建应用程序
      const app = new Application();

      // 初始化应用程序
      await app.init({ 
          background: "#1099bb", 
          height:600,
          width:800, 
      });

      // 将应用程序添加到页面上
      document.body.appendChild(app.canvas);

      // 加载图片到纹理上
      const trailTexture = await Assets.load("../assets/images/trail.png");

      const historyX = [];
      const historyY = [];
      // historySize决定了足迹的长度
      const historySize = 20;
      // ropeSize决定了步道的平滑程度
      const ropeSize = 100;
      const points = [];

      // 创建历史集合
      for (let i = 0; i < historySize; i++) {
        //历史x点于历史y点都为20个
        historyX.push(0);
        historyY.push(0);
      }
      // 创建轨迹点集合
      for (let i = 0; i < ropeSize; i++) {
        points.push(new Point(0, 0));
      }

      //创建一个网绳
      const rope = new MeshRope({ texture: trailTexture, points });

      // 应用于混合模式
      rope.blendmode = "add";

      app.stage.addChild(rope);

      let mouseposition = null;

      //开启事件装填是
      app.stage.eventMode = "static";
      //点击范围
      app.stage.hitArea = app.screen;
      //鼠标移动
      app.stage.on("mousemove", (event) => {
        //判断是否为空 如果为空设定为0
        mouseposition = mouseposition || { x: 0, y: 0 };
        //鼠标的x轴 于鼠标的y轴
        mouseposition.x = event.global.x;
        mouseposition.y = event.global.y;
      });

      // 监听动画并更新
      app.ticker.add(() => {
        if (!mouseposition) return;

        // 更新鼠标的值对于历史数据
        // 每次鼠标移动都会留有x与y值
        // 每帧都会获取对应的x与y轴

        //删除最后一个
        historyX.pop();
        //添加开头
        historyX.unshift(mouseposition.x);
        historyY.pop();
        historyY.unshift(mouseposition.y);

        // 由于图片是个轨迹状的图片  变形后也是有尾迹的
        //下面的三次插值 为了轨迹更平滑弄出的计算公式 只需调用即可

        // 更新这些点以与历史记录相对应。
        for (let i = 0; i < ropeSize; i++) {
          const p = points[i];

          // 使用三次插值平滑曲线，以防止出现锐边。
          const ix = cubicInterpolation(historyX, (i / ropeSize) * historySize);
          const iy = cubicInterpolation(historyY, (i / ropeSize) * historySize);

          //当前点 等于计算出来的点
          p.x = ix;
          p.y = iy;
        }
      });

      /**
       * 基于以下公式的三次插值 https://github.com/osuushi/Smooth.js
       */
      function clipInput(k, arr) {
        if (k < 0) k = 0;
        if (k > arr.length - 1) k = arr.length - 1;

        return arr[k];
      }

      function getTangent(k, factor, array) {
        return (factor * (clipInput(k + 1, array) - clipInput(k - 1, array))) / 2;
      }

      function cubicInterpolation(array, t, tangentFactor = 1) {
        const k = Math.floor(t);
        const m = [getTangent(k, tangentFactor, array), getTangent(k + 1, tangentFactor, array)];
        const p = [clipInput(k, array), clipInput(k + 1, array)];

        t -= k;
        const t2 = t * t;
        const t3 = t * t2;

        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
      }
    })();
  </script>
</body>
</html>
```

- 示例

<button @click="state5 = !state5">{{state5?"关闭展示":"开启展示"}}</button>
<div v-if="state5">
    <iframe src="/note-front/animation/pixi/example/html/13.html" width="850" height="650"></iframe>
</div>


## 2.6 屏幕截图

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        import { Application, Assets, Container, Sprite, Text, TextStyle } from "../js/pixi.mjs";

        (async () => {
            // 创建应用程序
            const app = new Application();

            // 初始化应用程序
            await app.init({
                background: "#111",
                height: 600,
                width: 800,
            });

            // 添加用用程序画布到桌面上
            document.body.appendChild(app.canvas);

            // 创建一个新的应用程序
            const container = new Container();
            // 创建容器框架
            const containerFrame = new Container();
            // 将第一个容器添加到容器框架中
            containerFrame.addChild(container);
            // 应用框架添加到舞台上
            app.stage.addChild(containerFrame);

            // 加载兔子图片纹理
            const texture = await Assets.load("../assets/images/bunny.png");

            // 创建5x5的兔子网格在容器上
            for (let i = 0; i < 25; i++) {
                //纹理添加到精灵里
                const bunny = new Sprite(texture);

                bunny.x = (i % 5) * 40;
                bunny.y = Math.floor(i / 5) * 40;
                container.addChild(bunny);
            }

            // 移动框架容器到屏幕中央
            containerFrame.x = app.screen.width / 2;
            containerFrame.y = app.screen.height / 2;

            // 将兔子精灵居中放置在本地容器坐标中
            // pivot 此显示对象在其局部空间中的旋转、缩放和倾斜中心。该位置是枢轴在父对象局部空间中的投影。
            container.pivot.x = container.width / 2;
            container.pivot.y = container.height / 2;

            // 监听动画更新
            app.ticker.add(time => {
                //不断旋转容器！
                //*使用delta创建与帧无关的变换*
                container.rotation -= 0.01 * time.deltaTime;
            });

            let screenshot;

            // 截取截图并下载
            async function takeScreenshot() {
                //如果对象不为空 直接清理
                if (screenshot !== undefined) {
                    screenshot.remove();
                }
                //渲染停止
                app.stop();
                //当前东起转换成base64数据
                const url = await app.renderer.extract.base64(containerFrame);

                // 创建a标签
                screenshot = document.createElement("a");
                // a标签加入
                document.body.append(screenshot);
                // a标签的位置
                screenshot.style.position = "fixed";
                screenshot.style.top = "20px";
                screenshot.style.left = "20px";
                screenshot.download = "screenshot";
                //给予其赋值 如果点击就会下载
                screenshot.href = url;

                //创建图片对象
                const image = new Image();
                //宽度为屏幕的五分之一
                image.width = app.screen.width / 5;
                //设置url
                image.src = url;
                //将image的html代码 放入到截屏标签中
                screenshot.innerHTML = image.outerHTML;
                // 设置渲染开始
                app.start();
            }
            // 设置可以监控
            app.stage.eventMode = "static";
            // 点击页面大小，整个页面
            app.stage.hitArea = app.screen;
            // 用户按下鼠标时 执行截图方法
            app.stage.on("pointerdown", takeScreenshot);

            // 新增文本风格
            const style = new TextStyle({
                fontFamily: "Roboto",
                fill: "#999",
            });
            // 创建截屏文字
            const screenshotText = new Text({ text: "点击可以截屏", style });
            // 截屏文字x位置 屏幕的宽度减去文字宽度的一半    y位置 文字高度的一半
            screenshotText.x = Math.round((app.screen.width - screenshotText.width) / 2);
            screenshotText.y = Math.round(screenshotText.height / 2);
            // 将文本添加到舞台上
            app.stage.addChild(screenshotText);
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state6 = !state6">{{state6?"关闭展示":"开启展示"}}</button>
<div v-if="state6">
    <iframe src="/note-front/animation/pixi/example/html/14.html" width="850" height="650"></iframe>
</div>

## 2.7 碰撞检测

- 代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <script type="module">
        import { Application, Assets, Point, Sprite, Texture } from "../js/pixi.mjs";

        // 基于下面这篇文章
        // https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics
        (async () => {
            // 创建应用程序
            const app = new Application();

            // 初始化应用程序
            await app.init({
                background: "#111",
                height: 600,
                width: 800,
            });

            // 应用程序画布加载到页面上
            document.body.appendChild(app.canvas);

            // 对象交互的反应

            // 红色方块的移动速度
            const movementSpeed = 0.05;

            // 两个物体之间的冲击力
            const impulsePower = 5;

            //命中测试
            //两个不同方格之间的基本AABB检查
            //object1 绿色方块 object2 红色方块
            function testForAABB(object1, object2) {
                const bounds1 = object1.getBounds();
                const bounds2 = object2.getBounds();

                // 四个条件都满足才是出现碰撞
                return (
                    bounds1.x < bounds2.x + bounds2.width &&
                    bounds1.x + bounds1.width > bounds2.x &&
                    bounds1.y < bounds2.y + bounds2.height &&
                    bounds1.y + bounds1.height > bounds2.y
                );
            }

            //计算碰撞的结果，使我们能够给出一个脉冲将物体铲开
            // object1 绿色方块 object2 红色方块
            function collisionResponse(object1, object2) {
                // 都不存在 直接返回0点位置
                if (!object1 || !object2) {
                    return new Point(0);
                }
                // 碰撞位置
                const vCollision = new Point(object2.x - object1.x, object2.y - object1.y);
                // 斜线距离
                const distance = Math.sqrt((object2.x - object1.x) * (object2.x - object1.x) + (object2.y - object1.y) * (object2.y - object1.y));
                // 碰撞规范 直角边/斜边
                const vCollisionNorm = new Point(vCollision.x / distance, vCollision.y / distance);
                // 相对速度
                const vRelativeVelocity = new Point(object1.acceleration.x - object2.acceleration.x, object1.acceleration.y - object2.acceleration.y);
                // 速度
                const speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;
                // 推动
                const impulse = (impulsePower * speed) / (object1.mass + object2.mass);

                return new Point(impulse * vCollisionNorm.x, impulse * vCollisionNorm.y);
            }

            //计算两个给定点之间的距离
            // p1当前鼠标的x轴与y值的值，p2红色方块中心点的位置
            function distanceBetweenTwoPoints(p1, p2) {
                const a = p1.x - p2.x;
                const b = p1.y - p2.y;
                //  Math.hypot函数返回所有参数的平方和的平方根，
                return Math.hypot(a, b);
            }

            // 我们要移动的绿色方块
            const greenSquare = new Sprite(Texture.WHITE);

            // 设置精灵所在的位置
            greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);
            greenSquare.width = 100;
            greenSquare.height = 100;
            // 给精灵涂上颜色
            greenSquare.tint = 0x00ff00;

            // 非精灵自带的值 加速
            greenSquare.acceleration = new Point(0);
            // 质量
            greenSquare.mass = 3;

            // 你移动的方块
            const redSquare = new Sprite(Texture.WHITE);

            redSquare.position.set(0, 0);
            redSquare.width = 100;
            redSquare.height = 100;
            redSquare.tint = 0xff0000;
            redSquare.acceleration = new Point(0);
            redSquare.mass = 1;

            const mouseCoords = { x: 0, y: 0 };

            app.stage.eventMode = "static";
            //设置可以点击的大小
            app.stage.hitArea = app.screen;
            //一直检测鼠标位置 并赋值
            app.stage.on("mousemove", event => {
                mouseCoords.x = event.global.x;
                mouseCoords.y = event.global.y;
            });

            // 监听动画更新
            app.ticker.add(time => {
                const delta = time.deltaTime;

                // 对两个方块应用减速，每次循环将加速度减少0.01%
                // 这个点会越来越低
                redSquare.acceleration.set(redSquare.acceleration.x * 0.99, redSquare.acceleration.y * 0.99);
                greenSquare.acceleration.set(greenSquare.acceleration.x * 0.99, greenSquare.acceleration.y * 0.99);

                console.log(redSquare.acceleration, greenSquare.acceleration);

                // 检查绿色方块是否移出屏幕 如果是这样，则沿该方向反向加速
                //如果x轴 超过两侧
                if (greenSquare.x < 0 || greenSquare.x > app.screen.width - 100) {
                    greenSquare.acceleration.x = -greenSquare.acceleration.x;
                }
                // 如果y轴超过两侧
                if (greenSquare.y < 0 || greenSquare.y > app.screen.height - 100) {
                    greenSquare.acceleration.y = -greenSquare.acceleration.y;
                }

                // 如果绿色方块跳出警戒线，它会弹回到中间
                if (greenSquare.x < -30 || greenSquare.x > app.screen.width + 30 || greenSquare.y < -30 || greenSquare.y > app.screen.height + 30) {
                    greenSquare.position.set((app.screen.width - 100) / 2, (app.screen.height - 100) / 2);
                }

                // 在屏幕内执行下列动作（如果鼠标不在屏幕上，则不再更新）
                if (app.screen.width > mouseCoords.x || mouseCoords.x > 0 || app.screen.height > mouseCoords.y || mouseCoords.y > 0) {
                    // 获取红色方块的中心点
                    const redSquareCenterPosition = new Point(redSquare.x + redSquare.width * 0.5, redSquare.y + redSquare.height * 0.5);

                    // 计算鼠标指针和红色方块
                    const toMouseDirection = new Point(mouseCoords.x - redSquareCenterPosition.x, mouseCoords.y - redSquareCenterPosition.y);

                    // 使用上述方法计算出方向的角度  atan2 返回值再 -PI与PI之间 代表旋转的角度在0度与360度之间
                    const angleToMouse = Math.atan2(toMouseDirection.y, toMouseDirection.x);

                    // 计算出方块应该行驶的速度，作为红色方块距离鼠标指针多远的函数
                    // 算出方块中的斜线
                    const distMouseRedSquare = distanceBetweenTwoPoints(mouseCoords, redSquareCenterPosition);
                    // 获取新的速度
                    const redSpeed = distMouseRedSquare * movementSpeed;

                    // 计算红色方块的加速度
                    redSquare.acceleration.set(Math.cos(angleToMouse) * redSpeed, Math.sin(angleToMouse) * redSpeed);
                }

                // 如果两个方块相撞
                if (testForAABB(greenSquare, redSquare)) {
                    //计算以下两种情况之间应发生的加速度变化
                    //每个方块都是碰撞的结果
                    const collisionPush = collisionResponse(greenSquare, redSquare);

                    // 设置两个方块的加速度变化
                    redSquare.acceleration.set(collisionPush.x * greenSquare.mass, collisionPush.y * greenSquare.mass);
                    // 绿色获取相反的加速度
                    greenSquare.acceleration.set(-(collisionPush.x * redSquare.mass), -(collisionPush.y * redSquare.mass));
                }
                // 加速度会一直消减的
                //x位置 随着加速度一直变化
                greenSquare.x += greenSquare.acceleration.x * delta;
                greenSquare.y += greenSquare.acceleration.y * delta;
                //红色方块也是一样
                redSquare.x += redSquare.acceleration.x * delta;
                redSquare.y += redSquare.acceleration.y * delta;
            });

            // 加载到舞台上
            app.stage.addChild(redSquare, greenSquare);
        })();
    </script>
</body>
</html>
```

- 示例

<button @click="state7 = !state7">{{state7?"关闭展示":"开启展示"}}</button>
<div v-if="state7">
    <iframe src="/note-front/animation/pixi/example/html/15.html" width="850" height="650"></iframe>
</div>


## 2.8 旋转器

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
<script type="module">
    import { Application, Assets, Container, Graphics, Point, Sprite } from "../js/pixi.mjs";

    (async () => {
        // 创建新的PixiJS应用实例
        const app = new Application();

        // 初始化应用配置（开启抗锯齿/设置背景色/自动适应窗口）
        await app.init({ 
            antialias: true, 
            background: "#1099bb", 
            width: 600,
            height: 200,
        });

        // 将应用画布添加到网页body中
        document.body.appendChild(app.canvas);

        // 加载纹理资源（旋转背景图/圆形元素图）
        await Assets.load([
            "../assets/images/bg_scene_rotate.jpg", 
            "../assets/images/bg_rotate.jpg", 
            "../assets/images/circle.png"
        ]);

        /* ---------------------------------------
        变化形式1 正方形径向变化
        -------------------------------------- */
        const generateSpinner1 = position => {
            // 新建一个容器
            const container = new Container();

            //容器的位置
            container.position = position;
            //将容器加载到页面上
            app.stage.addChild(container);

            //上面展示图片
            const base = Sprite.from("../assets/images/bg_scene_rotate.jpg");
            const size = 100;

            base.width = size;
            base.height = size;

            //下面展示图片
            const bottom = Sprite.from("../assets/images/bg_rotate.jpg");

            bottom.width = size;
            bottom.height = size;

            const mask = new Graphics();

            mask.position.set(size / 2, size / 2);
            //基础精灵加载上遮罩
            base.mask = mask;
            //整个页面也加上纹理
            window.mask = mask;

            //容器中将三者都加入子元素中
            container.addChild(bottom);
            //这个精灵在上面 但是mask 并没有大小 还是显示的是这个精灵  后续如果增大 会将整个纹理覆盖 只会显示下面的精灵
            container.addChild(base);
            container.addChild(mask);

            // 阶段
            let phase = 0;

            //改变的是mask遮罩，这个数据以自身为中心点，所以会有负值 以坐标轴为原点调整要展示的数据
            return delta => {
                // 更新阶段
                // 每次加上每帧时间的的60分之一
                phase += delta / 60;
                // 阶段每次除以360度 如果能除下 phase会第一次等于0
                phase %= Math.PI * 2;

                // 计算目标点
                //通过正弦与余弦计算 位置

                // 2π 一个循环
                // 开始值(phase - Math.PI / 2)  负二分之一π 值为0
                // sin 0 到1 1到-1 -1到0
                const x = Math.cos(phase - Math.PI / 2) * size;
                // 2π 一个循环
                // 开始值(phase - Math.PI / 2)  负二分之一π 值为-1
                // sin -1 到1 然后1到-1
                const y = Math.sin(phase - Math.PI / 2) * size;
                // console.log(delta, phase, phase - Math.PI / 2, x, y);

                // 四个边 每两个数字是一个点
                const segments = [
                    [-size / 2, -size / 2, size / 2, -size / 2], // 上部
                    [size / 2, -size / 2, size / 2, size / 2], // 右边
                    [-size / 2, size / 2, size / 2, size / 2], // 下边
                    [-size / 2, -size / 2, -size / 2, size / 2], // 左边
                ];

                // 找到线段相交的点
                let intersection = null;
                //弯曲值为0
                let winding = 0;

                // 每次循环都按照顺时针循环
                // 循环中每次都按照 每条边进行循环
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    //获取相交的x与y点
                    const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);

                    //如果相交点存在
                    if (hit) {
                        intersection = hit;
                        //判断如果相交的点为负数 就是第五部分
                        // 从最上边的中间开始走到末尾 winding等于0
                        // 从最上边开始走到中间 winding 等于 4
                        if (i === 0) winding = hit.x > 0 ? 0 : 4;
                        else winding = i;
                        break;
                    }
                }

                //角度
                const corners = [
                    size / 2,
                    -size / 2, // 右上角
                    size / 2,
                    size / 2, // 右下角
                    -size / 2,
                    size / 2, // 左下角
                    -size / 2,
                    -size / 2, // 左上角
                    0,
                    -size / 2, // 结束点
                ];

                // 重绘遮罩
                mask.clear()
                    .moveTo(0, -size / 2)
                    .lineTo(0, 0)
                    .lineTo(intersection.x, intersection.y);

                // 充满角
                // 直接连接可以连接的每个点 越往后连接的越少
                // 开始值为0 形成一个 缺少（0度 - 45度）的多边形
                // 值为1 形成一个 缺少0度到135度的多边形
                // 值为2 形成一个 缺少0度到225度的多边形
                // 值为3 形成一个 缺少0度到315度的多边形
                // 值为4 形成一个 缺少0度到360度的多边形

                for (let i = winding; i < corners.length / 2; i++) {
                    //连接x与y点
                    mask.lineTo(corners[i * 2], corners[i * 2 + 1]);
                }

                //填充红色 只要填充颜色都会展示数据
                mask.fill({ color: 0xff0000 });
            };
        };

        /* -----------------------
        Spinner. 3 缩放球
        ---------------------- */
        const generateSpinner2 = position => {
            //新建一个容器
            const container = new Container();

            //容器位置判断
            container.position = position;
            //在舞台上添加
            app.stage.addChild(container);

            //设置大小
            const size = 100;
            //小球数量
            const ballAmount = 7;
            //球的集合
            const balls = [];

            //数量循环
            for (let i = 0; i < ballAmount; i++) {
                //加载纹理
                const ball = Sprite.from("../assets/images/circle.png");

                //设置锚点
                ball.anchor.set(0.5);
                //加入舞台上
                container.addChild(ball);
                //设置球的位置
                //通过余弦与正弦设置x与y 环绕着中心点放位置
                //(i / ballAmount) * Math.PI * 2  
                // 计算结果: 0  2π/7（约0.88） 4π/7（约1.76） 6π/7（约2.64） 8π/7（约3.52） 10π/7（约4.40） 12π/7（约5.28）
                //cos 1 0.62 -0.22 -0.90 -0.90 -0.22 0.62
                //sin 0 0.78 0.97 0.43 -0.43 -0.97 -0.78
                //最后除以3 防止超过设定的值的二分之一
                //以size/2为坐标轴原点，所有的数据围绕着这个点循环

                //最终的x与y的坐标   83.3 50   70.7 76.0   42.5 82.4   19.9 64.4   19.9 35.5   42.5 17.5   70.7 23.9
                ball.position.set(
                    size / 2 + (Math.cos((i / ballAmount) * Math.PI * 2) * size) / 3, 
                    size / 2 + (Math.sin((i / ballAmount) * Math.PI * 2) * size) / 3
                );

                //加入集合
                balls.push(ball);
            }

            // 阶段
            let phase = 0;

            return delta => {
                // 更新阶段
                phase += delta / 60;
                phase %= Math.PI * 2;

                // 修改球的大小
                balls.forEach((b, i) => {
                    //根据页面缓缓增大
                    //使用这些数据 0  π/7  2π/7  3π/7 4π/7  5π/7  6π/7 减去一个0-2π的值
                    // 最后值都在-1到1之间循环
                    //因为减去的相同，都是按照曲线获取的值 相隔一个π/7
                    const sin = Math.sin((i / ballAmount) * Math.PI - phase);

                    // 将sin与自身相乘，得到更陡峭的边缘。
                    // 0.5 - 0.9 再0.9 - 0.5 定期修改
                    // 最低是0.5 也是值为0的时候
                    // Math.abs 计算数据的绝对值，不管是什么最后都等于正数
                    b.scale.set(Math.abs(sin * sin * sin * 0.5) + 0.5);
                });
            };
        };

        /* ---------------------
        Spinner 3. 径向遮罩
        -------------------- */
        const generateSpinner3 = position => {
            //新建一个容器
            const container = new Container();

            //判断位置
            container.position = position;
            //容器加载到舞台上
            app.stage.addChild(container);

            //加载精灵
            const base = Sprite.from("../assets/images/bg_scene_rotate.jpg");
            const size = 100;

            //设置大小
            base.width = size;
            base.height = size;

            //设置遮罩
            const mask = new Graphics();

            //遮罩中心位置
            mask.position.set(size / 2, size / 2);
            //设置遮罩
            base.mask = mask;
            //也是整个页面的遮罩
            window.mask = mask;

            //精灵与遮罩都加入到容器中
            container.addChild(base);
            container.addChild(mask);

            //阶段
            let phase = 0;

            return delta => {
                // 更新阶段 phase 是一个不断增大的数 如果大于2π 就会重新开始
                phase += delta / 60;
                phase %= Math.PI * 2;

                //开始角度 -90°  -0.44 也是坐标轴上方的竖线
                const angleStart = 0 - Math.PI / 2;
                //角度
                const angle = phase + angleStart;
                //圆角
                const radius = 50;

                // x1与y1 根据余弦与正弦获取正确的数据
                const x1 = Math.cos(angleStart) * radius;
                const y1 = Math.sin(angleStart) * radius;

                // 重新绘制遮罩
                // 从0点开始 目标点x1与y1 不停变化的数据
                // arc 前两个参数 弧的中心点 弧度的半径  弧度的开始点 弧度的结束点 是否逆时针(false代表顺时针)
                // 代表先从原点画 画到目标点 连接一个弧线  再次连接到原点 形成一个扇形  最后加入颜色
                mask.clear()
                    .moveTo(0, 0)
                    .lineTo(x1, y1)
                    .arc(0, 0, radius, angleStart, angle, false)
                    .lineTo(0, 0)
                    .fill({ color: 0xff0000 });
            };
        };

        /* ---------------------------------
        Spinner 4. 围绕正方形的边
        ------------------------------- */
        const generateSpinner4 = position => {
            //新建一个容器
            const container = new Container();

            //容器的位置
            container.position = position;
            app.stage.addChild(container);

            const size = 100;
            //圆弧半径
            const arcRadius = 15;

            //初始化精灵
            const base = Sprite.from("../assets/images/bg_scene_rotate.jpg");

            //宽度与高度
            base.width = size;
            base.height = size;

            // 为了获得更好的性能，预先对资产进行设定比遮罩要好。
            const roundingMask = new Graphics();

            // 围绕的遮罩 这个遮罩有颜色 会一直展示
            roundingMask.roundRect(0, 0, size, size, arcRadius).fill({ color: 0x0 });
            base.mask = roundingMask;

            // 边缘也可以用图像代替
            const lineSize = 5;
            const edge = new Graphics();

            //创建一个圆角边 是边框(stroke)类型的，外部是红色
            edge.roundRect(0, 0, size, size, arcRadius).stroke({ width: lineSize, color: 0xff0000 });

            //此示例中的Mask的工作方式与示例1基本相同。
            //除了它被反转并在边缘中以直线计算遮罩。
            const mask = new Graphics();

            //内部的遮罩
            mask.position.set(size / 2, size / 2);
            edge.mask = mask;

            container.addChild(base);
            container.addChild(roundingMask);
            container.addChild(edge);
            container.addChild(mask);

            let phase = 0;

            return delta => {
                // 更新阶段
                // 除以160 需要更长的时间去获取
                phase += delta / 160;
                phase %= Math.PI * 2;

                // 随时间变化 通过余弦与正弦确认x y变化 计算目标点
                const x = Math.cos(phase - Math.PI / 2) * size;
                const y = Math.sin(phase - Math.PI / 2) * size;
                // 线段计算 四个边
                const segments = [
                    [-size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize, -size / 2 + lineSize], // 上边
                    [size / 2 - lineSize, -size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize], // 右边
                    [-size / 2 + lineSize, size / 2 - lineSize, size / 2 - lineSize, size / 2 - lineSize], // 下边
                    [-size / 2 + lineSize, -size / 2 + lineSize, -size / 2 + lineSize, size / 2 - lineSize], // 左边
                ];
                // 在每个分段处，应屏蔽到哪个目录继续
                let outDir = [
                    [0, -1],
                    [1, 0],
                    [0, 1],
                    [-1, 0],
                ];

                // 找到线段相交的点
                let intersection = null;
                let winding = 0;
                //在找到撞击后，在撞击线尺寸之前，线应该继续朝哪个方向前进
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    //相交的点
                    const hit = intersect(0, 0, x, y, segment[0], segment[1], segment[2], segment[3]);

                    if (hit) {
                        intersection = hit;
                        if (i === 0) winding = hit.x < 0 ? 0 : 4;
                        else winding = 4 - i; //这里发生了变动 1与3调换位置
                        //判断 屏蔽目录
                        outDir = outDir[i];
                        break;
                    }
                }

                //角度
                const corners = [
                    -size / 2 - lineSize,
                    -size / 2 - lineSize, // 左上角,
                    -size / 2 - lineSize,
                    size / 2 + lineSize, // 左下角
                    size / 2 + lineSize,
                    size / 2 + lineSize, // 右下角
                    size / 2 + lineSize,
                    -size / 2 - lineSize, // 左上角
                ];

                // 重绘遮罩
                // 这些形成一条直线，是竖着的一条线
                mask.clear()
                    .moveTo(0, 0)
                    .moveTo(0, -size / 2 - lineSize);

                // 填充角度
                for (let i = 0; i < winding; i++) {
                    //循环中连接不同的角
                    mask.lineTo(corners[i * 2], corners[i * 2 + 1]);
                }

                //首先连接短线的上边与下边
                //然后连接到原点
                //最后填充颜色
                mask.lineTo(intersection.x + outDir[0] * lineSize * 2, intersection.y + outDir[1] * lineSize * 2)
                    .lineTo(intersection.x, intersection.y)
                    .lineTo(0, 0)
                    .fill({ color: 0xff0000 });
            };
        };

        /* ---------------------
        Spinner 5. 圆矩形定长旋转器
        -------------------- */
        const generateSpinner5 = position => {
            //创建容器
            const container = new Container();

            //设置位置
            container.position = position;
            app.stage.addChild(container);

            //设置半个圆 颜色红色
            const halfCircle = new Graphics().arc(0, 0, 100, 0, Math.PI).fill({ color: 0xff0000 });

            //设置位置的中心点
            halfCircle.position.set(50, 50);

            //设置圆角矩形 白色
            const rectangle = new Graphics().roundRect(0, 0, 100, 100, 16).stroke({ width: 2, color: 0xffffff });

            //圆角矩形的遮罩使用半圆
            rectangle.mask = halfCircle;

            //再容器中添加圆角矩形与半圆遮罩
            container.addChild(rectangle);
            container.addChild(halfCircle);

            //阶段
            let phase = 0;

            return delta => {
                // 更新阶段
                phase += delta / 6;
                phase %= Math.PI * 2;

                //设置旋转角度，每次角度变化 都会将数据改变
                halfCircle.rotation = phase;
            };
        };

        const onTick = [
            generateSpinner1(new Point(50, 50)),
            generateSpinner2(new Point(160, 50)),
            generateSpinner3(new Point(270, 50)),
            generateSpinner4(new Point(380, 50)),
            generateSpinner5(new Point(490, 50)),
        ];

        // Listen for animate update
        app.ticker.add(time => {
            // Call tick handling for each spinner.
            onTick.forEach(cb => {
                cb(time.deltaTime);
            });
        });

        /**
         * 帮助方法

                Paul Bourke的线截距数学http://paulbourke.net/geometry/pointlineplane/
                确定两条线段的交点
                如果线条不相交，则返回FALSE
                对原始代码进行了修改，以匹配pixi示例的linting规则。

                前四个参数与后四个参数都代表 一条线
                每两个参数代表一个点 
        */
        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            // 检查每条线的起始位置是否相同 如果相同是个点 不符合判断 直接返回false
            if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
                return false;
            }

            // 分母
            const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

            // 线条是平行的
            if (denominator === 0) {
                return false;
            }

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

            // 是沿线段的交点
            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
                return false;
            }

            // 返回一个具有交点x和y坐标的对象
            const x = x1 + ua * (x2 - x1);
            const y = y1 + ua * (y2 - y1);

            return { x, y };
        }
    })();
</script>
</body>
</html>
```

- 示例

<button @click="state8 = !state8">{{state8?"关闭展示":"开启展示"}}</button>
<div v-if="state8">
    <iframe src="/note-front/animation/pixi/example/html/16.html" width="850" height="650"></iframe>
</div>