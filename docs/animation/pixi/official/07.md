
# 七、场景相关

在PixiJS中，场景对象是应用程序显示层次结构的构建块。它们包括容器、精灵、文本、图形和其他构成场景图形的可绘制实体——决定渲染什么、如何渲染以及以什么顺序渲染的树状结构。


## 7.1 场景对象

### 7.1.1 容器与叶节点

PixiJS中的场景对象可以分为容器和叶子节点：

1. 容器

`Container` 是v8中所有场景对象的基类（取代旧的 `DisplayObject` ）。

*   可以生孩子。
*   通常用于对对象进行分组并对组应用转换（位置、缩放、旋转）。
*   例如： `Application.stage` ，自定义组。

```ts
const group = new Container();
group.addChild(spriteA);
group.addChild(spriteB);
```

2. 叶节点

叶节点是可渲染的对象，不应该有子节点。在v8中，只有容器才应该有子容器。

叶节点的例子包括：

*   `Sprite`
*   `Text`
*   `Graphics`
*   `Mesh`
*   `TilingSprite`
*   `HTMLText`

尝试向叶节点添加子节点不会导致运行时错误，但是，您可能会遇到意外的呈现行为。因此，如果需要嵌套，则将叶节点包裹在 `Container` 中。

**v8之前（在v8中无效）：**

```ts
const sprite = new Sprite();
sprite.addChild(anotherSprite); // ❌ Invalid in v8
```

**v8的方法:**

```ts
const group = new Container();
group.addChild(sprite);
group.addChild(anotherSprite); // ✅ Valid
```

### 7.1.2 转换

PixiJS中的所有场景对象都有几个属性来控制它们的位置、旋转、比例和alpha。这些属性由子对象继承，允许您轻松地对对象组应用转换。

您将经常使用这些属性来定位和动画场景中的对象。

| 财产  | 描述  |
| --- | --- |
| **位置** | X和y位置以像素为单位给出，并改变对象相对于其父对象的位置，也可以直接使用 `object.x`  /  `object.y` |
| **旋转** | 旋转以弧度为单位指定，并顺时针旋转对象（0.0 - 2 \* Math.PI） |
| **角** | 角度是旋转的别名，以度而不是弧度指定（0.0 - 360.0） |
| **主** | 对象旋转的点，以像素为单位-也为子对象设置原点 |
| **α** | 不透明度从0.0（完全透明）到1.0（完全不透明），由子继承 |
| **规模** | Scale被指定为百分比，1.0为100%或实际大小，并且可以为x和y轴独立设置 |
| **斜** | Skew在x和y方向变换对象，类似于CSS Skew（）函数，并以弧度指定 |
| **锚吗?** | 锚点是一个基于百分比的精灵位置和旋转偏移量。这与 `pivot` 属性不同，后者是基于像素的偏移量。 |

**锚点vs枢轴**

一些叶节点有一个名为 `anchor` 的附加属性，这是节点位置和旋转的基于百分比的偏移量。这与 `pivot` 属性不同，后者是基于像素的偏移量。在定位或旋转节点时，理解锚点和枢轴点之间的区别至关重要。


>设置枢轴或锚点可以可视化地移动节点。这与CSS不同，在CSS中， `transform-origin` 不会影响元素的位置。

1.  锚点

    *   仅在 `Sprite`上可用
    *   定义为规范化值 `(0.0 to 1.0)`
    *   `(0, 0)` 为左上方， `(0.5, 0.5)` 为中心
    *   改变位置和旋转原点

    ```ts
    sprite.anchor.set(0.5); // center
    sprite.rotation = Math.PI / 4; // Rotate 45 degrees around the center
    ```

2. 枢轴

    *   在所有 `Container` 服务器上可用
    *   以像素定义，未规范化

    ```ts
    const sprite = new Sprite(texture);
    sprite.width = 100;
    sprite.height = 100;
    sprite.pivot.set(50, 50); // Center of the container
    container.rotation = Math.PI / 4; // Rotate 45 degrees around the pivot
    ```

### 7.1.3 测量范围

在PixiJS中有两种类型的边界：

*   局部边界表示对象在其自身坐标空间中的尺寸。使用 `getLocalBounds()` 。
*   全局边界用世界坐标表示对象的边界框。使用 `getBounds()` 。

```ts
const local = container.getLocalBounds();
const global = container.getBounds();
```

如果性能很重要，您还可以提供自定义 `boundsArea` ，以完全避免每个子节点的度量。

**改变大小**

要更改容器的大小，可以使用 `width` 和 `height` 属性。这将缩放容器以适应指定的尺寸：

```ts
const container = new Container();
container.width = 100;
container.height = 200;
```

分别设置 `width` 和 `height` 可能是一个昂贵的操作，因为它需要重新计算容器及其子容器的边界。为了避免这种情况，你可以使用 `setSize()` 同时设置两个属性：

```ts
const container = new Container();
container.setSize(100, 200);
const size = container.getSize(); // { width: 100, height: 200 }
```

这种方法比单独设置 `width` 和 `height` 更有效，因为它只需要计算一次边界。

### 7.1.4 遮罩场景对象

PixiJS支持遮罩，允许您根据另一个对象的形状限制场景对象的可见区域。 这对于创建裁剪、显示或隐藏场景部分等效果非常有用。

1. 遮罩的类型

    *   基于图形的蒙版：使用 `Graphics` 对象来定义形状。
    *   基于精灵的蒙版：使用 `Sprite` 或其他可渲染对象。

    ```ts
    const shape = new Graphics().circle(100, 100, 50).fill(0x000000);

    const maskedSprite = new Sprite(texture);
    maskedSprite.mask = shape;

    stage.addChild(shape);
    stage.addChild(maskedSprite);
    ```

2. 反向遮罩

    要创建一个反向掩码，您可以使用 `setMask` 属性并将其 `inverse` 选项设置为 `true` 。这将渲染蒙版以外的所有内容。

    ```ts
    const inverseMask = new Graphics().rect(0, 0, 200, 200).fill(0x000000);
    const maskedContainer = new Container();
    maskedContainer.setMask({ mask: inverseMask, inverse: true });
    maskedContainer.addChild(sprite);
    stage.addChild(inverseMask);
    stage.addChild(maskedContainer);
    ```

3. 遮罩注意事项

    *   不渲染遮罩；它只用于定义可见区域。但是，必须将其添加到显示列表中。
    *   每个对象只能分配一个遮罩。
    *   对于高级混合，使用alpha蒙版或滤镜。

### 7.1.5 过滤器

容器对象的另一个常见用途是作为过滤内容的宿主。滤镜是一个高级的WebGL/ webgpu功能，允许PixiJS执行逐像素效果，如模糊和位移。通过在容器上设置过滤器，在容器的内容呈现之后，过滤器将处理容器所包含的屏幕区域。

```ts
const container = new Container();
const sprite = new Sprite(texture);
const filter = new BlurFilter({ strength: 8, quality: 4, kernelSize: 5 });
container.filters = [filter];
container.addChild(sprite);
```

>过滤器的使用应该有所节制。如果在场景中过于频繁地使用，它们可能会降低性能并增加内存使用。

以下是PixiJS中默认可用的过滤器列表。但是，有一个包含更多过滤器的社区存储库。

| 过滤器 | 描述  |
| --- | --- |
| AlphaFilter | 类似于设置 `alpha` 属性，但将Container扁平化，而不是单独应用于子元素。 |
| BlurFilter | 应用模糊效果 |
| ColorMatrixFilter | 颜色矩阵是一种灵活的方法，可以应用更复杂的色调或颜色变换（例如，棕褐色色调）。 |
| DisplacementFilter | 位移贴图创建视觉偏移像素，例如创建波浪水效果。 |
| NoiseFilter | 创建随机噪声（例如，颗粒效果）。 |

实际上，我们提供的每个Filter都是用glsl（用于WebGL）和wgsl（用于WebGPU）编写的。这意味着所有的过滤器都应该在两个渲染器上工作。

### 7.1.6 着色

你可以通过设置 `tint` 属性来着色任何场景对象。它修改渲染像素的颜色，类似于在对象上增加色彩。

```ts
const sprite = new Sprite(texture);
sprite.tint = 0xff0000; // Red tint
sprite.tint = 'red'; // Red tint
```

 `tint` 由子对象继承，除非它们自己指定。如果你的场景只有一部分需要着色，把它放在一个单独的容器中。

 `0xFFFFFF` 禁用着色。

```ts
const sprite = new Sprite(texture);
sprite.tint = 0x00ff00; // Green tint
sprite.tint = 0xffffff; // No tint
```

PixiJS支持多种颜色格式，您可以从color文档中找到更多信息。

### 7.1.7 混合模式

混合模式决定了重叠物体的颜色如何组合。PixiJS支持多种混合模式，包括：

*   `normal` ：默认混合模式。
*   `add` ：添加源像素和目标像素的颜色。
*   `multiply` ：将源像素和目标像素的颜色相乘。
*   `screen` ：将颜色反转，将它们相乘，然后再次反转。

我们还支持许多更高级的混合模式，如 `subtract` ,  `difference` ,  `overlay` 。你可以在混合模式文档中找到混合模式的完整列表。

```ts
const sprite = new Sprite(texture);
sprite.blendMode = 'multiply'; // Multiply blend mode
```

### 7.1.8 交互

PixiJS提供了一个强大的交互系统，允许您处理用户输入事件，如点击/悬停。要在场景对象上启用交互，可以简单地将其 `interactive` 属性设置为 `true` 。

```ts
const sprite = new Sprite(texture);
sprite.interactive = true;
sprite.on('click', (event) => {
    console.log('Sprite clicked!', event);
});
```

我们有一个关于交互的详细指南，涵盖了如何设置和管理交互，包括命中测试、指针事件等等。我们强烈建议大家去看看。

### 7.1.9 使用 `onRender` 

 `onRender` 回调允许您在渲染场景对象时每帧运行逻辑。这对于轻量级动画和更新逻辑很有用：

```ts
const container = new Container();
container.onRender = () => {
    container.rotation += 0.01;
};
```

>注意：在PixiJS v8中，这取代了常见的v7模式重写 `updateTransform` ，不再每帧运行。 `onRender` 函数注册到容器所属的渲染组。

删除回调函数：

```ts
container.onRender = null;
```


## 7.2 容器

 `Container` 类是PixiJS场景图系统的基础。容器充当场景对象组，允许您构建复杂的层次结构，组织渲染层，并对对象组应用转换或效果。

### 7.2.1 什么是容器？​

 `Container` 是一个通用节点，可以容纳其他显示对象，包括其他容器。它用于构建场景、应用转换、管理渲染和交互。

容器不会直接呈现。相反，他们把渲染委托给他们的子项。

```ts
import { Container, Sprite } from 'pixi.js';

const group = new Container();
const sprite = Sprite.from('bunny.png');

group.addChild(sprite);
```

### 7.2.2 管理子项

PixiJS提供了一个强大的API来添加、删除、重新排序和交换容器中的子节点：

```ts
const container = new Container();
const child1 = new Container();
const child2 = new Container();

container.addChild(child1, child2);
container.removeChild(child1);
container.addChildAt(child1, 0);
container.swapChildren(child1, child2);
```

您还可以通过索引删除子节点或删除范围内的所有子节点：

```ts
container.removeChildAt(0);
container.removeChildren(0, 2);
```

当移动到另一个容器时保持child的world变换，使用 `reparentChild` 或 `reparentChildAt` ：

```ts
otherContainer.reparentChild(child);
```

- 事件

    当添加或删除子容器时，容器会发出事件：

    ```ts
    group.on('childAdded', (child, parent, index) => { ... });
    group.on('childRemoved', (child, parent, index) => { ... });
    ```

-  发现孩子

    容器支持使用相关方法通过 `label` 搜索子节点：

    ```ts
    const child = new Container({ label: 'enemy' });
    container.addChild(child);
    container.getChildByLabel('enemy');
    container.getChildrenByLabel(/^enemy/); // all children whose label starts with "enemy"
    ```

    设置 `deep = true` 递归地搜索所有后代。

    ```ts
    container.getChildByLabel('ui', true);
    ```

- 排序的孩子

    使用 `zIndex` 和 `sortableChildren` 来控制容器内的渲染顺序：

    ```ts
    child1.zIndex = 1;
    child2.zIndex = 10;
    container.sortableChildren = true;
    ```

    调用 `sortChildren()` 手动重新排序。

    ```ts
    container.sortChildren();
    ```


    >要谨慎地使用这个特性，因为对于大量的子节点来说，排序可能会很昂贵。
                                                                
### 7.2.3 使用渲染组进行优化

容器可以通过设置 `isRenderGroup = true` 或调用 `enableRenderGroup()` 来提升呈现组。

对UI层、粒子系统或大型移动子树使用渲染组。 请参阅渲染组指南了解更多细节。

```ts
const uiLayer = new Container({ isRenderGroup: true });
```

### 7.2.4 缓存为纹理

PixiJS中的 `cacheAsTexture` 函数是优化应用程序渲染的强大工具。通过将容器及其子容器渲染为纹理， `cacheAsTexture` 可以显著提高静态或不经常更新的容器的性能。

当你设置 `container.cacheAsTexture()` 时，容器被渲染为纹理。后续渲染重用此纹理，而不是渲染容器的所有子元素。这种方法对于具有许多静态元素的容器特别有用，因为它减少了呈现工作负载。

请注意

`cacheAsTexture` 是PixiJS v8的等效先前的 `cacheAsBitmap` 功能。如果从v7或更早版本迁移，只需将代码中的 `cacheAsBitmap` 替换为 `cacheAsTexture` 。

```ts
const container = new Container();
const sprite = Sprite.from('bunny.png');
container.addChild(sprite);

// 启用缓存作为纹理
container.cacheAsTexture();

// 如果容器发生变化，则更新纹理
container.updateCacheTexture();

// 禁用缓存作为纹理
container.cacheAsTexture(false);

```



### 7.2.4 缓存为纹理具体使用

#### 7.2.4.1 在PixiJS中使用 `cacheAsTexture` 

PixiJS中的 `cacheAsTexture` 函数是优化应用程序渲染的强大工具。通过将容器及其子容器渲染为纹理， `cacheAsTexture` 可以显著提高静态或不经常更新的容器的性能。让我们探讨一下如何有效地使用它，以及它的好处和注意事项。

请注意

`cacheAsTexture` 是PixiJS v8的等效先前的 `cacheAsBitmap` 功能。如果从v7或更早版本迁移，只需将代码中的 `cacheAsBitmap` 替换为 `cacheAsTexture` 。

* * *

#### 7.2.4.2 `cacheAsTexture` 是什么？​

当你设置 `container.cacheAsTexture()` 时，容器被渲染为纹理。后续渲染重用此纹理，而不是渲染容器的所有子元素。这种方法对于具有许多静态元素的容器特别有用，因为它减少了呈现工作负载。

要在改变容器后更新纹理，调用：

```javascript
container.updateCacheTexture();
```

要关闭它，请拨打：

```javascript
container.cacheAsTexture(false);
```

* * *

#### 7.2.4.3 基本用法

下面的例子演示了如何使用 `cacheAsTexture` ：

```javascript
import * as PIXI from 'pixi.js';

(async () =>
{
    // Create a new application
    const app = new Application();

    // Initialize the application
    await app.init({ background: '#1099bb', resizeTo: window });

    // Append the application canvas to the document body
    document.body.appendChild(app.canvas);

    // load sprite sheet..
    await Assets.load('https://pixijs.com/assets/spritesheet/monsters.json');

    // holder to store aliens
    const aliens = [];
    const alienFrames = ['eggHead.png', 'flowerTop.png', 'helmlok.png', 'skully.png'];

    let count = 0;

    // create an empty container
    const alienContainer = new Container();

    alienContainer.x = 400;
    alienContainer.y = 300;

    app.stage.addChild(alienContainer);

    // add a bunch of aliens with textures from image paths
    for (let i = 0; i < 100; i++)
    {
        const frameName = alienFrames[i % 4];

        // create an alien using the frame name..
        const alien = Sprite.from(frameName);

        alien.tint = Math.random() * 0xffffff;

        alien.x = Math.random() * 800 - 400;
        alien.y = Math.random() * 600 - 300;
        alien.anchor.x = 0.5;
        alien.anchor.y = 0.5;
        aliens.push(alien);
        alienContainer.addChild(alien);
    }

    // this will cache the container and its children as a single texture
    // so instead of drawing 100 sprites, it will draw a single texture!
    alienContainer.cacheAsTexture()
})();
```

在这个例子中， `container` 及其子纹理被渲染为单个纹理，减少了绘制场景时的渲染开销。

试试这里的例子。

#### 7.2.4.4 高级用法

你可以传递一个与纹理源选项非常相似的配置对象，而不是使用true来启用cacheAsTexture。

```typescript
container.cacheAsTexture({
    resolution: 2,
    antialias: true,
});
```

*   `resolution` 是纹理的分辨率。默认情况下，这与您的渲染器或应用程序相同。
*   `antialias` 是用于纹理的抗混叠模式。就像分辨率一样，这默认为渲染器或应用程序的抗混叠模式。

* * *

#### 7.2.4.5 `cacheAsTexture` 的好处

*   性能提升：将复杂的容器渲染为单个纹理，避免了在每一帧中单独处理每个子元素的需要。
*   针对静态内容进行了优化：非常适合具有静态或很少更新的子元素的容器。

* * *

#### 7.2.4.6 先进的细节

*   内存权衡：每个缓存纹理都需要GPU内存。使用 `cacheAsTexture` 以增加内存使用换取渲染速度。
*   GPU限制：如果你的容器太大（例如，超过4096x4096像素），纹理可能无法缓存，这取决于GPU限制。

* * *

#### 7.2.4.7 它是如何在内部工作的

在底层， `cacheAsTexture` 将容器转换为渲染组并将其渲染为纹理。它使用与过滤器相同的纹理缓存机制：

```javascript
container.enableRenderGroup();
container.renderGroup.cacheAsTexture = true;
```

一旦纹理被缓存，通过 `updateCacheTexture()` 更新它是有效的，并且产生最小的开销。它和正常渲染容器一样快。

* * *

#### 7.2.4.8 最佳实践

- 需要做的

    *   用于静态内容：将 `cacheAsTexture` 应用于具有不经常更改元素的容器，例如具有静态装饰的UI面板。
    *   利用性能：使用 `cacheAsTexture` 将复杂的容器渲染为单个纹理，减少每帧单独处理每个子元素的开销。这对于包含昂贵效果（如过滤器）的容器尤其有用。
    *   反锯齿开关：将反锯齿设置为false可以略微提高性能，但纹理可能会在其子边缘周围看起来更像素化。
    *   分辨率：根据你的情况调整分辨率，如果有些东西被缩小了，你可以使用更低的分辨率。如果某些东西按比例放大，您可能需要使用更高的分辨率。但请注意，分辨率越高，纹理和内存占用就越大。

-  不需要做的

    *   适用于非常大的容器：避免在太大的容器上使用 `cacheAsTexture` （例如，超过4096x4096像素），因为它们可能由于GPU限制而无法缓存。相反，把它们分成更小的容器。
    *   过度使用动态内容：在容器上频繁地打开/关闭 `cacheAsTexture` ，因为这会导致不断地重新缓存，从而抵消其好处。它最好缓存为纹理当你一次，然后使用 `updateCacheTexture` 更新它。
    *   适用于稀疏内容：对于元素很少或内容稀疏的容器，不要使用 `cacheAsTexture` ，性能提升可以忽略。
    *   忽略内存影响：注意GPU内存的使用。每个缓存的纹理都会消耗内存，因此过度使用 `cacheAsTexture` 可能会导致资源限制。


#### 7.2.4.9 陷阱

*   渲染依赖于场景可见性：缓存仅在包含场景被渲染时更新。在设置 `cacheAsTexture` 后修改布局，但在渲染场景之前将反映在缓存中。
    
*   容器不进行转换：缓存项按其实际大小进行渲染，忽略缩放等转换。例如，一个物品按比例缩小50%，它的纹理将被缓存为100%大小，然后根据场景按比例缩小。
    
*   缓存和过滤器： `cacheAsTexture` 时，过滤器的行为可能不像预期的那样。要缓存过滤器效果，将项目封装在父容器中，并对父容器应用 `cacheAsTexture` 。
    
*   重用纹理：如果你想基于容器创建一个新的纹理，最好使用 `const texture = renderer.generateTexture(container)` 并在你的对象中共享！
    


## 7.3 精灵


### 7.3.1 原始精灵(Sprite)

精灵是PixiJS的基本视觉元素。它们代表要在屏幕上显示的单个图像。每个精灵都包含一个要绘制的纹理，以及场景图形中所需的所有转换和显示状态。

```ts
import { Assets, Sprite } from 'pixi.js';

const texture = await Assets.load('path/to/image.png');
const sprite = new Sprite(texture);

sprite.anchor.set(0.5);
sprite.position.set(100, 100);
sprite.scale.set(2);
sprite.rotation = Math.PI / 4; // 旋转45度
```

#### 7.3.1.1 更新纹理

如果你改变精灵的纹理，它会自动：

*   为纹理更新重新绑定侦听器
*   重新计算宽度/高度，如果设置，使视觉大小保持不变
*   触发视觉更新

```ts
const texture = Assets.get('path/to/image.png');
sprite.texture = texture;
```

#### 7.3.2.2 比例vs宽度/高度

精灵从 `Container` 继承 `scale` ，允许基于百分比的调整大小：

```ts
sprite.scale.set(2); // 尺寸翻倍
```

精灵也有 `width` 和 `height` 属性，作为 `scale` 的方便设置，基于纹理的尺寸：

```ts
sprite.width = 100; // 自动更新比例width
sprite.scale.x=100  // sprite.texture.org.width；
```

#### 7.3.2.2 实例

-  代码

```html
```

-  运行结果图

![](/animation/pixi/official/image/009.png)

### 7.3.2 九宫格精灵


`NineSliceSprite` 是一个特殊类型的 `Sprite` ，允许纹理在保留角和边缘的情况下调整大小。它对于构建可扩展的UI元素（如带有圆形或装饰边框的按钮、面板或窗口）特别有用。

```ts
import { NineSliceSprite, Texture } from 'pixi.js';

const nineSlice = new NineSliceSprite({
    texture: Texture.from('button.png'),
    leftWidth: 15,
    topHeight: 15,
    rightWidth: 15,
    bottomHeight: 15,
    width: 200,
    height: 80,
});

app.stage.addChild(nineSlice);
```

你也可以只传递一个纹理，切片值将回落到默认值或从纹理 `defaultBorders` 推断。

#### 7.3.2.1 ninesslice是如何工作的

下面是9片纹理的划分方式：

```js
    A                          B
  +---+----------------------+---+
C | 1 |          2           | 3 |
  +---+----------------------+---+
  |   |                      |   |
  | 4 |          5           | 6 |
  |   |                      |   |
  +---+----------------------+---+
D | 7 |          8           | 9 |
  +---+----------------------+---+

Areas:
  - 1, 3, 7, 9: 角 (保持未缩放)
  - 2, 8: Top/Bottom 中心 (水平拉伸)
  - 4, 6: Left/Right 中心 (垂直拉伸)
  - 5: 中心 (双向拉伸)
```

这确保了装饰性的角被保留，中心的内容可以根据需要缩放。

#### 7.3.2.2 宽度和高度行为

在a  `NineSliceSprite` 上设置 `.width` 和 `.height` 更新几何顶点，而不是纹理uv。这允许纹理根据切片区域正确地重复或拉伸。这也意味着 `width` 和 `height` 属性与 `scale` 属性不同。

```ts
// 纹理将拉伸以适应新的尺寸
nineSlice.width = 300;
nineSlice.height = 100;

// 九个切片的大小将均匀增加
nineSlice.scale.set(2); // Doubles the size
```

**原始宽度和高度**

如果需要知道9片的原始大小，可以通过 `originalWidth` 和 `originalHeight` 属性访问它。这些值是在创建 `NineSliceSprite` 时设置的，并在应用任何缩放或调整大小之前表示纹理的尺寸。

```ts
console.log(nineSlice.originalWidth);
console.log(nineSlice.originalHeight);
```

#### 7.3.2.3 动态更新

您可以在运行时更改切片的尺寸或大小：

```ts
nineSlice.leftWidth = 20;
nineSlice.topHeight = 25;
```

每个setter触发一个几何更新来反映更改。


#### 7.3.2.4 实例代码


-  代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="../js/pixi8.js"></script>
</head>
<body>
    <script type="module">
        const app = new PIXI.Application();

        await app.init({
            width: 600,                 // 宽度
            height: 400,                // 高度
            backgroundColor: 0x1099bb,  // 画布颜色
            backgroundAlpha:0.3         // 画布透明度
        });

        document.body.appendChild(app.canvas);

        const texture = await PIXI.Assets.load('../assest/sample1.png');
        const nineSlice = new PIXI.NineSliceSprite({
            texture: texture,
            leftWidth: 20,
            topHeight: 20,
            rightWidth: 20,
            bottomHeight: 20,
            width: 200,
            height: 80,
        });

        app.stage.addChild(nineSlice);
    </script>
</body>
</html>
```

-  运行结果图

![](/animation/pixi/official/image/010.png)

### 7.3.3 Tiling精灵



A  `TilingSprite` 是一种高性能的在矩形区域上渲染重复纹理的方法。它不是拉伸纹理，而是重复（贴图）它来填充给定的空间，使其成为背景，视差效果，地形和UI面板的理想选择。

```ts
import { TilingSprite, Texture } from 'pixi.js';

const tilingSprite = new TilingSprite({
    texture: Texture.from('assets/tile.png'),
    width: 400,
    height: 300,
});

app.stage.addChild(tilingSprite);
```

#### 7.3.3.1 什么是TilingSprite？​

*   它在一个已定义的区域重复绘制纹理。
*   默认情况下，纹理不会缩放，除非你调整 `tileScale` 。
*   精灵的整体 `width` 和 `height` 决定贴图填充的面积，与纹理的原始大小无关。
*   模式的偏移量、比例和旋转可以独立于对象的变换来控制。

#### 7.3.3.2 关键属性

| 财产  | 描述  |
| --- | --- |
| `texture` | 纹理在重复 |
| `tilePosition` | `ObservablePoint` 平铺图案的控制偏移量 |
| `tileScale` | `ObservablePoint` 控制每个贴图的缩放 |
| `tileRotation` | 数字控制瓷砖图案的旋转 |
| `width` / `height` | 要用瓷砖填充的区域的大小 |
| `anchor` | 调整TilingSprite的原点 |
| `applyAnchorToTexture` | 如果 `true` ，则锚会影响平铺图案的起点 |
| `clampMargin` | 调整边距以避免边缘伪影（默认值： `0.5` ） |

#### 7.3.3.3 宽度和高度vs比例

与 `Sprite` 不同，在a  `TilingSprite` 中设置 `width` 和 `height` 直接改变可见平铺区域。它不影响瓷砖的尺度。

```ts
// 使tiling面积更大
tilingSprite.width = 800;
tilingSprite.height = 600;

// 保持瓷砖大小不变，只是瓷砖数量更多
```

要缩放瓷砖图案本身，使用 `tileScale` ：

```ts
// 使每个图块看起来更大
tilingSprite.tileScale.set(2, 2);
```

#### 7.3.3.4 锚和applyAnchorToTexture

*   `anchor` 设置定位TilingSprite的枢轴/原点。
*   如果 `applyAnchorToTexture`   `true` ，则锚也会影响瓷砖图案开始的位置。
*   默认情况下，无论锚点如何，tile模式都从本地空间的（0,0）处开始。


#### 7.3.3.5 实例代码

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="../js/pixi8.js"></script>
</head>
<body>
    <script type="module">
        const app = new PIXI.Application();

        await app.init({
            width: 600,                 // 宽度
            height: 400,                // 高度
            backgroundColor: 0x1099bb,  // 画布颜色
            backgroundAlpha:0.3         // 画布透明度
        });

        document.body.appendChild(app.canvas);

        const texture = await PIXI.Assets.load('../assest/sample1.png');
        const tilingSprite = new PIXI.TilingSprite({
            texture: texture,       // 纹理
            height: 400,            // 填充区域的高度
            width: 600,             // 填充区域的宽度

        });

        // 缩放tilingSprite本身
        tilingSprite.tileScale.set(0.1, 0.1);

        app.ticker.add((ticker) => {
            tilingSprite.tilePosition.x -= 1;
        });

        app.stage.addChild(tilingSprite);
    </script>
</body>
</html>
```

- 示例

<iframe src="/note-front/animation/pixi/official/html/07.html" width="650" height="450"></iframe>


### 7.3.4 动画精灵

AnimatedSprite是一种显示由纹理列表描绘的动画的简单方法。

```js
import { AnimatedSprite, Texture } from 'pixi.js';

const alienImages = [
    'image_sequence_01.png',
    'image_sequence_02.png',
    'image_sequence_03.png',
    'image_sequence_04.png',
];
const textureArray = [];

for (let i = 0; i < 4; i++)
{
    const texture = Texture.from(alienImages[i]);
    textureArray.push(texture);
}

const animatedSprite = new AnimatedSprite(textureArray);
```


#### 7.3.4.1 使用纹理数组创建动画精灵的方法

```js
new PIXI.AnimatedSprite(textures, autoUpdate);
```

- 参数 :

| 名称         | 类型      | 默认值                | 描述                                    |
|------------|---------|--------------------|---------------------------------------|
| textures   | array   | 用一系列略有不同的图像做的纹理数组。 |                                       |
| autoUpdate | boolean | TRUE               | 用来判断是否使用 PIXI.ticker.shared 自动更新动画时间。 |


- 返回值：

返回一个对象，对象会有一些属性和方法，用于控制动画精灵。

- 返回值对象的属性：

| 名称             | 类型          | 描述                           |
|----------------|-------------|------------------------------|
| animationSpeed | number      | 动画精灵的播放速度。越高越快，越低越慢，默认值是1    |
| currentFrame   | number（只读）  | 正在显示的当前帧编号                   |
| onComplete     | function    | 当loop属性为false时，一个动画精灵完成播放时调用 |
| playing        | Boolean     | 确定当前动画精灵是否正在播放               |
| onFrameChange  | function    | 当一个动画精灵更改要呈现的纹理时调用           |
| loop           | boolean     | 动画精灵是否在播放后重复播放               |
| onLoop         | function    | 当loop属性为true时调用的函数           |
| textures       | array       | 用于这个动画精灵的纹理数组                |
| totalFrames    | number （只读） | 动画中的帧总数                      |


- 返回值对象的方法：

| 名称          | 参数                          | 描述              |
|-------------|-----------------------------|-----------------|
| play        | 播放动画精灵                      |                 |
| gotoAndPlay | frameNumber，number类型，开始帧的索引 | 转到特定的帧并开始播放动画精灵 |
| stop        | 停止播放动画精灵                    |                 |
| gotoAndStop | frameNumber，number类型，停止帧的索引 | 转到特定的帧并停止播放动画精灵 |



使用返回值中的这些属性和方法，我们就可以控制动画精灵了，比如播放动画精灵，设置动画的速度，设置是否循环播放等，除此之外，还要知道就是 PIXI.extras.AnimatedSprite 方法继承自 PIXI.Sprite 方法，所以动画精灵也可以用普通精灵的属性和方法，比如x，y，width，height，scale，rotation 。

#### 7.3.4.2 实例-纹理

- 代码

```html

好的，我们开始试试这个方法。
<!DOCTYPE html>
<html lang="zn">
    <head>
        <meta charset="UTF-8" />
        <title>动画精灵</title>
        <script src="../js/pixi8.js"></script>
    </head>
    <body>
        <div id="px-render"></div>
        <script type="module">
            // 创建一个 Pixi应用
            let app = new PIXI.Application();
            // 创建一个 Pixi应用 需要的一些参数
            let option = {
                width: 400,
                height: 300,
                transparent: true,
            };
            // 初始化应用程序
            await app.init(option);
            let playground = document.getElementById("px-render");
            // 把 Pixi 创建的 canvas 添加到页面上
            playground.appendChild(app.canvas);
            //需要加载的雪碧图
            const texture = await PIXI.Assets.load("../assest/dnf.png");
            //第一个纹理
            let texture0 = new PIXI.Texture({
                source: texture,
                frame: new PIXI.Rectangle(0, 0, 80, 143),
            });
            //第二个纹理
            let texture1 = new PIXI.Texture({ 
                source: texture, 
                frame: new PIXI.Rectangle(80, 0, 80, 143) 
            });
            //第三个纹理
            let texture2 = new PIXI.Texture({ 
                source: texture, 
                frame: new PIXI.Rectangle(160, 0, 80, 143) 
            });
            //第四个纹理
            let texture3 = new PIXI.Texture({ 
                source: texture, 
                frame: new PIXI.Rectangle(240, 0, 80, 143) 
            });
            //创建纹理数组
            let textures = [texture0, texture1, texture2, texture3];
            //创建动画精灵
            let anim = new PIXI.AnimatedSprite(textures);
            // 设置位置与锚点
            anim.x = app.screen.width / 2;
            anim.y = app.screen.height / 2;
            anim.anchor.set(0.5);
            //设置速度与播放
            anim.animationSpeed = 0.1;
            anim.play();
            //将其添加到舞台上
            app.stage.addChild(anim);
        </script>
    </body>
</html>
```

- 示例

<iframe src="/note-front/animation/pixi/official/html/08.html" width="450" height="350"></iframe>


#### 7.3.4.3 实例-精灵表

- 代码

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>动画精灵</title>
  </head>
  <body>
    <div id="px-render"></div>
  </body>
  <script type="module">
    import { Application, Assets, AnimatedSprite, Texture } from "../js/pixi.mjs";

    (async () => {
      // 创建应用程序
      const app = new Application();

      // 初始化应用程序
      await app.init({
        width: 400,
        height: 300,
      });

      let playground = document.getElementById("px-render");

      // 把 Pixi 创建的 canvas 添加到页面上
      playground.appendChild(app.canvas);

      // 加载动画精灵页
      const texture = await Assets.load("../spritesheet/gunner_texture.json");

      // 创建一个数组填充仓库中的精灵
      const gunnerTextures = [];

      // 数据放入纹理集合中
      for (let i = 0; i < 4; i++) {
        const texture = Texture.from(`gunner_${i + 1}.jpg`);

        gunnerTextures.push(texture);
      }
      console.log(gunnerTextures);

      //创建动画精灵
      let anim = new AnimatedSprite(gunnerTextures);
      // 设置位置与锚点
      anim.x = app.screen.width / 2;
      anim.y = app.screen.height / 2;
      anim.anchor.set(0.5);

      //设置速度与播放
      anim.animationSpeed = 0.1;
      anim.play();

      //将其添加到舞台上
      app.stage.addChild(anim);
    })();
  </script>
</html>
```

- 示例

<iframe src="/note-front/animation/pixi/official/html/08.html" width="450" height="350"></iframe>


## 7.4 图形


### 7.4.1 基础应用

图形是一种强大而灵活的工具，用于渲染矩形、圆形、星形和自定义多边形等形状。它还可以通过组合多个原语来创建复杂的形状，并且它支持渐变，纹理和蒙版等高级功能。

```js
import { Graphics } from 'pixi.js';

const graphics = new Graphics()
  .rect(50, 50, 100, 100)
  .fill(0xff0000);
```

#### 7.4.1.1 基础图形

```ts
const graphics = new Graphics()
    .rect(50, 50, 100, 100)
    .fill(0xff0000)
    .circle(200, 200, 50)
    .stroke(0x00ff00)
    .lineStyle(5)
    .moveTo(300, 300)
    .lineTo(400, 400);
```

#### 7.4.1.2 SVG支持

您还可以加载SVG路径数据，但由于Pixi的性能优化三角测量系统，复杂的孔几何形状可能呈现不准确。

```ts
let shape = new Graphics().svg(`
  <svg>
    <path d="M 100 350 q 150 -300 300 0" stroke="blue" />
  </svg>
`);
```

### 7.4.2 GraphicsContext

 `GraphicsContext` 类是PixiJS新图形模型的核心。它保存了所有的绘图命令和样式，允许相同的形状数据被多个 `Graphics` 实例重用：

```ts
const context = new GraphicsContext().circle(100, 100, 50).fill('red');

const shapeA = new Graphics(context);
const shapeB = new Graphics(context); // Shares the same geometry
```

这种模式在渲染重复或动画形状时特别有效，例如基于帧的SVG交换：

```ts
let frames = [
    new GraphicsContext().circle(100, 100, 50).fill('red'),
    new GraphicsContext().rect(0, 0, 100, 100).fill('red'),
];

let graphic = new Graphics(frames[0]);

function update() {
    graphic.context = frames[1]; // Very cheap operation
}
```

>如果在创建 `Graphics` 对象时没有显式传递 `GraphicsContext` ，那么在内部，它将有自己的上下文，可以通过 `myGraphics.context` 访问。

**销毁GraphicsContext**

当您销毁 `GraphicsContext` 时，共享它的所有 `Graphics` 实例也将被销毁。记住这一点很重要，因为如果你不小心，可能会导致意想不到的行为。

```ts
const context = new GraphicsContext().circle(100, 100, 50).fill('red');
const shapeA = new Graphics(context);
const shapeB = new Graphics(context); // Shares the same geometry

shapeA.destroy({ context: true }); // Destroys both shapeA and shapeB
```

### 7.4.3 cut 孔

使用 `.cut()` 从前一个形状中删除一个形状：

```ts
const g = new Graphics()
  .rect(0, 0, 100, 100)
  .fill(0x00ff00)
  .circle(50, 50, 20)
  .cut(); // Creates a hole in the green rectangle
```

确保孔完全封闭在形状内，以避免三角测量误差。

### 7.4.4 注意点

1. 图像是关于构建，而不是绘画

    尽管术语函数如 `.rect()` 或 `.circle()` ,  `Graphics` 不会立即绘制任何东西。相反，每个方法构建一个存储在 `GraphicsContext` 中的几何原语列表。然后，当对象被绘制到屏幕上或在另一个上下文中（如蒙版）使用时，渲染这些内容。

    ```ts
    const graphic = new Graphics().rect(0, 0, 200, 100).fill(0xff0000);

    app.stage.addChild(graphic); // The rendering happens here
    ```

    你可以把 `Graphics` 看作一个蓝图构建器：它定义了绘制什么，但不定义何时绘制。这就是为什么 `Graphics` 对象可以被重用、克隆、屏蔽和转换，而不会产生额外的计算，直到它们实际呈现。

2. 性能最佳实践

    *   不要每帧都清除和重建图形。如果您的内容是动态的，最好交换预构建的 `GraphicsContext` 对象，而不是重新创建它们。
    *   完成后使用 `Graphics.destroy()` 进行清理。共享上下文不会自动销毁。
    *   在一个复杂的对象上使用多个简单的 `Graphics` 对象来维护GPU批处理。
    *   避免透明重叠，除非你了解混合模式；重叠的半透明原语将在每个原语之间进行交互，而不是在组合后进行交互。

3. 注意事项和陷阱

    *   内存泄漏：当不再需要时调用 `.destroy()` 。
    *   SVG和孔洞：并非所有SVG孔洞路径都能正确三角化。
    *   改变几何形状：谨慎使用 `.clear()` 。更喜欢交换上下文。
    *   透明度和混合模式：这些适用于每个原语。使用 `RenderTexture` 如果你想平坦的效果。


### 7.4.5 图形填充

#### 7.4.5.1 基础填充

1. 基本颜色填充

当创建 `Graphics` 对象时，您可以使用 `fill()` 方法轻松地用颜色填充它。这里有一个简单的例子：

```ts
const obj = new Graphics()
  .rect(0, 0, 200, 100) // 矩形
  .fill('red'); // 填充红色
```

![](/animation/pixi/official/image/011.png)


这将创建一个红色矩形。PixiJS支持 `fill()` 方法的多种颜色格式。开发人员可以根据自己的需要选择一种格式。例如，CSS颜色字符串用户友好且易读，十六进制字符串紧凑且在设计工具中广泛使用，数字在编程中使用效率高。数组和颜色对象提供精确的控制，使它们成为高级图形的理想选择。

*   CSS颜色字符串（例如，‘red’， ‘blue’）
*   十六进制字符串（例如，‘#ff0000’）
*   数字（例如 `0xff0000` ）
*   数组（例如 `[255, 0, 0]` ）
*   颜色对象进行精确的颜色控制

**例子**

```ts
// 使用数字
const obj1 = new Graphics().rect(0, 0, 100, 100).fill(0xff0000);

// 使用十六禁止字符串
const obj2 = new Graphics().rect(0, 0, 100, 100).fill('#ff0000');

// 使用rgb数组
const obj3 = new Graphics().rect(0, 0, 100, 100).fill([255, 0, 0]);

// 使用颜色对象
const color = new Color();
const obj4 = new Graphics().rect(0, 0, 100, 100).fill(color);
```

2. 填充一个样式对象

对于更高级的填充，您可以使用 `FillStyle` 对象。这允许额外的定制，比如设置不透明度：

```ts
const obj = new Graphics().rect(0, 0, 100, 100)
  .fill({
    color: 'red',
    alpha: 0.5, // 50% opacity
  });
```

![](/animation/pixi/official/image/012.png)


3. 填充纹理

用纹理填充形状也很简单：

```ts
const texture = await Assets.load('assets/image.png');
const obj = new Graphics().rect(0, 0, 100, 100)
  .fill(texture);
```

![](/animation/pixi/official/image/013.png)

#### 7.4.5.2 纹理空间

1. 局部与全局纹理空间

纹理可以在两个坐标空间中应用：

*   局部空间（默认）：纹理坐标相对于形状的尺寸和位置进行映射。纹理坐标使用标准化坐标系，其中（0,0）是形状的左上角，（1,1）是形状的右下角，而不考虑其实际像素尺寸。例如，如果你有一个300x200像素的纹理填充一个100x100像素的形状，那么纹理将被缩放到正好适合这100x100像素。纹理的左上角（0,0）将与形状的左上角对齐，纹理的右下角（1,1）将与形状的右下角对齐，根据需要拉伸或压缩纹理。

```ts
const shapes = new PIXI.Graphics()
    .rect(50,50,100, 100)
    .circle(250,100,50)
    .star(400,100,6,60,40)
    .roundRect(500,50,100,100,10)
    .fill({
        texture,
        textureSpace:'local' // default!
    });
```

![](/animation/pixi/official/image/014.png)


*   全局空间：设置 `textureSpace: 'global'` 使纹理位置和比例相对于图形对象的坐标系。尽管名称如此，但这并不是真正的“全局”——纹理相对于图形对象本身保持固定，即使对象移动或缩放也保持其位置。看看图片是如何在所有的形状（在相同的图形）下面：

```ts
const shapes = new PIXI.Graphics()
    .rect(50,50,100, 100)
    .circle(250,100,50)
    .star(400,100,6,60,40)
    .roundRect(500,50,100,100,10)
    .fill({
        texture,
        textureSpace:'global'
    });
```

![](/animation/pixi/official/image/015.png)


2. 使用矩阵和纹理

要修改纹理坐标，可以应用变换矩阵，这是一种用于缩放、旋转或平移纹理的数学工具。如果你不熟悉变换矩阵，它们允许精确控制纹理的渲染方式，你可以在这里探索更多关于它们的信息。

```ts
const matrix = new Matrix().scale(0.5, 0.5);

const obj = new Graphics().rect(0, 0, 100, 100)
  .fill({
    texture: texture,
    matrix: matrix, // scale the texture down by 2
  });
```

![](/animation/pixi/official/image/016.png)


3. 结构问题的

    1.  精灵表：如果使用精灵表中的纹理，则会使用整个源纹理。要使用一个特定的帧，创建一个新的纹理：

    ```ts
    const spriteSheetTexture = Texture.from('assets/my-sprite-sheet.png');
    const newTexture = renderer.generateTexture(Sprite.from(spriteSheetTexture));

    const obj = new Graphics().rect(0, 0, 100, 100)
    .fill(newTexture);
    ```

    2.  两个纹理的力量：纹理应该是在WebGL1中正确平铺的二维力量（WebGL2和WebGPU都可以）。

#### 7.4.5.3 用渐变填充

PixiJS支持线性和径向梯度，可以使用 `FillGradient` 类创建。渐变对于为形状和文本添加视觉深度和动态样式特别有用。

1. 线性渐变

线性渐变沿着直线创建平滑的颜色过渡。下面是一个简单线性梯度的例子：

```ts
const gradient = new FillGradient({
  type: 'linear',
  colorStops: [
    { offset: 0, color: 'yellow' },
    { offset: 1, color: 'green' },
  ],
});

const obj = new Graphics().rect(0, 0, 100, 100)
  .fill(gradient);
```

![](/animation/pixi/official/image/017.png)

你可以用以下属性来控制渐变方向：

*   `start {x, y}` ：这些定义了梯度的起点。例如，在线性渐变中，这是第一个颜色停止的位置。这些值通常以相对坐标（0到1）表示，其中 `0` 代表形状的左/上边缘， `1` 代表形状的右/下边缘。
    
*   `end {x, y}` ：这些定义了梯度的终点。与 `start {x, y}` 类似，这些值指定最后一个颜色停止在形状的本地坐标系中的位置。
    

使用这些属性，您可以创建各种渐变效果，例如水平、垂直或对角过渡。例如，将 `start` 设置为 `{x: 0, y: 0}` ，并将 `end` 至 `{x: 1, y: 1}` 设置为从形状的左上角到右下角的对角线渐变。

```ts
const diagonalGradient = new FillGradient({
  type: 'linear',
  start: { x: 0, y: 0 },
  end: { x: 1, y: 1 },
  colorStops: [
    { offset: 0, color: 'yellow' },
    { offset: 1, color: 'green' },
  ],
});
```

![](/animation/pixi/official/image/018.png)

2. 径向渐变

径向渐变在圆形图案中创建平滑的颜色过渡。与线性渐变不同，它们将颜色从一个圆圈混合到另一个圆圈。下面是一个简单的径向梯度的例子：

```ts
const gradient = new FillGradient({
  type: 'radial',
  colorStops: [
    { offset: 0, color: 'yellow' },
    { offset: 1, color: 'green' },
  ],
});

const obj = new Graphics().rect(0, 0, 100, 100)
  .fill(gradient);
```

![](/animation/pixi/official/image/019.png)


你可以使用以下属性来控制渐变的形状和大小：

*   `center {x, y}` ：这些定义了渐变开始的内圆的中心。通常，这些值以相对坐标（0到1）表示，其中 `0.5` 表示形状的中心。
    
*   `innerRadius` ：内圆半径。这决定了梯度起始点的大小。
    
*   `outerCenter {x, y}` ：这些定义了渐变结束的外圆的中心。与 `center {x, y}` 一样，这些值也是相对坐标。
    
*   `outerRadius` ：外圆半径。这决定了梯度终点的大小。
    

通过调整这些属性，您可以创建各种效果，例如小的、集中的梯度或大的、扩展的梯度。例如，设置一个小的 `r0` 和一个大的 `r1` 将创建一个渐变，直到达到内圆半径才开始过渡。

```ts
const radialGradient = new FillGradient({
  type: 'radial',
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0.25,
  outerCenter: { x: 0.5, y: 0.5 },
  outerRadius: 0.5,
  colorStops: [
    { offset: 0, color: 'blue' },
    { offset: 1, color: 'red' },
  ],
});

const obj = new Graphics().rect(0, 0, 100, 100)
  .fill(gradient);
```

![](/animation/pixi/official/image/020.png)


- 梯度问题的

    1.  内存管理：当不再需要梯度时，使用 `fillGradient.destroy()` 来释放资源。
        
    2.  动画：更新现有的渐变，而不是创建新的渐变，以获得更好的性能。
        
    3.  自定义着色器：对于复杂的动画，自定义着色器可能更有效。
        
    4.  纹理和矩阵限制：在底层，渐变填充在内部设置纹理和矩阵属性。这意味着你不能同时使用纹理填充或矩阵变换作为渐变填充。
        

#### 7.4.5.4 结合纹理和颜色

您可以将纹理或渐变与颜色色调和alpha相结合，以实现更复杂和更具视觉吸引力的效果。这允许你在纹理或渐变上叠加颜色，用alpha值调整透明度。

```ts

const gradient = new FillGradient({
    colorStops: [
        { offset: 0, color: 'blue' },
        { offset: 1, color: 'red' },
    ]
});

const obj = new Graphics().rect(0, 0, 100, 100)
  .fill({
    fill: gradient,
    color: 'yellow',
    alpha: 0.5,
  });
```

![](/animation/pixi/official/image/021.png)

```ts
const obj = new Graphics().rect(0, 0, 100, 100)
  .fill({
    texture: texture,
    color: 'yellow',
    alpha: 0.5,
  });
```


![](/animation/pixi/official/image/022.png)

### 7.4.6 图形像素线


#### 7.4.6.1 如何使用 `pixelLine` ？​

这里有一个简单的例子：

```ts
// Create a Graphics object and draw a pixel-perfect line
let graphics = new Graphics()
  .moveTo(0, 0)
  .lineTo(100, 100)
  .stroke({ color: 0xff0000, pixelLine: true });

// Add it to the stage
app.stage.addChild(graphics);

// Even if we scale the Graphics object, the line remains 1 pixel wide
graphics.scale.set(2);
```

在本例中，无论您如何变换或缩放 `Graphics` 对象，红色线条将始终在屏幕上显示为1像素厚。

* * *

#### 7.4.6.2 为什么使用 `pixelLine` ？​

像素完美的线条在各种场景中都非常有用。下面是一些常见的用例：

1. 复古或像素艺术游戏

    *   像素美术游戏很大程度上依赖于保持清晰、精确的视觉效果。 `pixelLine` 属性确保线条不会模糊或缩放与其他像素元素不一致。
    *   示例：为基于瓷砖的地图绘制像素完美的网格。

    ```ts
    // 创建由垂直线和水平线组成的网格
    const grid = new Graphics();

    // 绘制10条间距为10像素的垂直线
    // 绘制垂直线
    for (let i = 0; i < 10; i++) {
        // 移动到每条线的顶部 (x = i10, y = 0)
        grid.moveTo(i * 10, 0)
        // 向下绘制到底部 (x = i10, y = 100)
        .lineTo(i * 10, 100);
    }

    // 绘制水平线
    for (let i = 0; i < 10; i++) {
        // 移动到每条线的起点 (x = 0, y = i10)
        grid.moveTo(0, i * 10)
        // 向右绘制到终点 (x = 100, y = i10)
        .lineTo(100, i * 10);
    }

    // 以白色描边所有线条，并启用像素完美宽度
    grid.stroke({ color: 0xffffff, pixelLine: true });

    ```



2. UI和HUD元素
        
    *   对于UI元素，如边框、分隔符或下划线，一致的1像素厚度可以提供专业、干净的外观。
    *   示例：在菜单或进度条边框中绘制分隔线。

    ```ts
    // 创建一条始终为1像素宽的分隔线
    const separator = new Graphics()
        // 起始点坐标 (x=0, y=50)
        .moveTo(0, 50)
        // 向右绘制200像素长的水平线
        .lineTo(200, 50)
        // 使用绿色描边，并保持像素完美1px宽度
        .stroke({ color: 0x00ff00, pixelLine: true });
    ```



3. 调试和原型制作

*   使用像素完美的线条来调试布局、碰撞框或网格。由于线条不能伸缩，它们在开发过程中提供了一致的参考点。
*   例子：在基于物理的游戏中显示碰撞边界。

```ts

// 创建带像素完美描边的调试框
const graphicsBox = new Graphics()
    .rect(0, 0, 100, 100)
    .stroke({ color: 0xff00ff, pixelLine: true });

/**
   * 更新调试框以匹配给定对象的边界
   * @param {Container} obj - 需要绘制边界的对象
*/
function drawDebugBounds(obj) {
    // 获取对象的边界矩形
    let bounds = obj.getBounds().rectangle;

    // 调整调试框位置和缩放以匹配边界
    // 这比每帧使用moveTo和lineTo更高效！
    graphicsBox.position.set(bounds.x, bounds.y);
    graphicsBox.scale.set(bounds.width / 100, bounds.height / 100);
}
```

#### 7.4.6.3 它是如何工作的

当 `pixelLine` 被设置为 `true` 时，这是使用WebGL或WebGPU的本机行渲染方法实现的。

有趣的是，画像素线比画普通线要快。这是因为两个主要因素：

1.  更简单的绘图过程：在PixiJS中的规则线（当 `pixelLine`   `false` ）需要额外的步骤来绘制。PixiJS必须计算出线的厚度，并创建一个看起来像线但实际上由三角形组成的形状。
    
2.  直线绘制：当使用 `pixelLine` 时，我们可以告诉显卡“只要从a点到B点画一条线”，它就知道该怎么做。这比创建和填充形状简单得多，也快得多。
    

把它想象成在纸上画一条线—— `pixelLine` 就像用钢笔画一条直线，而规则线就像必须仔细地在一个薄矩形上上色。笔法自然更快更简单！


#### 7.4.6.4 注意事项和陷阱

虽然 `pixelLine` 属性非常有用，但有一些限制和需要记住的事情：

1. 1px厚，就是这样！​

    *   线总是1px厚，没有办法改变这一点，因为它使用GPU来绘制线。

2. 硬件可能呈现不同

    *   不同的gpu和图形硬件可能会因为处理线光栅化的方式不同而呈现线条略有不同。例如，一些gpu可能会稍微不同地定位线或应用不同的抗混叠技术。这是GPU线条渲染的固有限制，超出了PixiJS的控制范围。

3. 扩展行为

    *   当线粗细保持不变时，其他属性（例如，位置或开始/结束点）仍然受到缩放的影响。如果与其他缩放对象结合使用，有时会产生意想不到的结果。这是一个功能，而不是一个bug:

**示例：具有像素完美描边的框**

下面是一个填充框的例子，具有像素完美的描边。框本身缩放和增长，但描边保持1像素宽：

```ts
// 创建Graphics对象并绘制带像素完美描边的填充矩形
let box = new Graphics()
    .rect(0, 0, 100, 100)
    .fill('white')
    .stroke({ color: 0xff0000, pixelLine: true });

// 将矩形添加到舞台
app.stage.addChild(box);

// 缩放矩形
box.scale.set(2);
```

在这个例子中，蓝色框随着它的缩放而增长，但是红色描边保持在1像素的厚度，提供了一个清晰的轮廓，无论缩放。



**何时避免使用 `pixelLine`**

*   你想要的线条厚度不是1px：不要使用 `pixelLine` 。
*   您希望该行可伸缩：不要使用 `pixelLine`

## 7.5 文本

### 7.5.1 基础文本


PixiJS中的 `Text` 类允许您在场景中渲染样式，动态字符串作为显示对象。在底层，PixiJS使用浏览器的画布文本API对文本进行光栅化，然后将其转换为纹理。这使得 `Text` 对象表现得像精灵：它们可以移动，旋转，缩放，遮罩和有效渲染。

```ts
import { Text, TextStyle, Assets } from 'pixi.js';

// Load font before use
await Assets.load({
    src: 'my-font.woff2',
    data: {
        family: 'MyFont', // optional
    }
});


const myText = new Text({
    text: 'Hello PixiJS!',
    style: {
      fill: '#ffffff',
      fontSize: 36,
      fontFamily: 'MyFont',
    }
    anchor: 0.5
});

app.stage.addChild(myText);
```

#### 7.5.1.1 文本样式

 `TextStyle` 类允许您自定义文本的外观。您可以设置如下属性：

*   `fontFamily`
*   `fontSize`
*   `fontWeight`
*   `fill` (颜色)
*   `align`
*   `stroke` (大纲)

更多细节请参见TextStyle指南。

#### 7.5.1.2 动态更改文本

你可以在运行时更新文本字符串或其样式：

```ts
text.text = 'Updated!';
text.style.fontSize = 40; // Triggers re-render
```

警告

更改文本或样式可重新光栅化对象。除非必要，否则避免每帧都这样做。

#### 7.5.1.3 文本解析

 `Text` 类的 `resolution` 属性决定了渲染文本的像素密度。默认情况下，它使用渲染器的分辨率。

但是，您可以独立于渲染器设置文本分辨率，以获得更清晰的文本，特别是在高dpi显示器上。

```ts
const myText = new Text('Hello', {
    resolution: 2, // 更高分辨率以获得更清晰的文本显示
});

// 修改分辨率
myText.resolution = 1; // 重置为默认值
```

#### 7.5.1.4 字体加载

PixiJS支持通过 `Assets`  API加载自定义字体。它支持许多常见的字体格式：

*   `woff`
*   `woff2`
*   `ttf`
*   `otf`

为了获得最佳的性能和压缩效果，建议使用 `woff2` 。

```js
await Assets.load({
    src: 'my-font.woff2',
    data: {}
});
```

下面是在加载字体时，你可以在 `data` 对象中传递的属性列表：

| 财产  | 描述  |
| --- | --- |
| **家庭** | 字体族名称。 |
| **显示** | FontFace接口的显示属性。 |
| **featureSettings** | FontFace接口的featureSettings属性。 |
| **拉伸** | FontFace接口的拉伸属性。 |
| **风格** | FontFace接口的样式属性。 |
| **unicodeRange** | FontFace接口的unicodeRange属性。 |
| **变体** | FontFace接口的变体属性。 |
| **权重** | FontFace接口的权重属性。 |



### 7.5.2 位图文本


`BitmapText` 是PixiJS中的高性能文本渲染解决方案。与 `Text` 类不同， `BitmapText` 从预生成的纹理图集中绘制字符。这种设计允许您以最小的开销呈现数以万计的文本对象。

```ts
import { Assets, BitmapText } from 'pixi.js';

await Assets.load('fonts/MyFont.fnt');

const text = new BitmapText({
    text: 'Loaded font!',
    style: {
        fontFamily: 'MyFont',
        fontSize: 32,
        fill: '#ffcc00',
    },
});
```

#### 7.5.2.1 为什么使用 `BitmapText` ？​

*   快速渲染：完美的hud，得分计数器，计时器等。
*   没有逐帧光栅化：文本更改很便宜。
*   有效的内存使用：在所有实例中共享字形纹理。
*   支持MSDF/SDF字体：清晰缩放而不模糊。

理想用例：

*   频繁更新文本
*   大量的文本实例
*   高性能或移动项目

#### 7.5.2.2 如何加载和使用位图字体

1. 字体加载

PixiJS支持AngelCode BMFont格式和msdf兼容的 `.fnt` 和 `.xml` 文件。您可以使用 `Assets`  API加载这些文件。

加载后，您可以使用 `fontFamily` 属性创建一个带有加载字体的 `BitmapText` 实例。

```ts
import { Assets, BitmapText } from 'pixi.js';

await Assets.load('fonts/MyFont.fnt');

const text = new BitmapText({
    text: 'Loaded font!',
    style: {
        fontFamily: 'MyFont',
        fontSize: 32,
        fill: '#ffcc00',
    },
});
```

2. MSDF和SDF字体

PixiJS支持MSDF（多通道签名距离字段）和SDF格式的清晰，分辨率无关的文本。这些字体在任何大小和比例下都保持清晰。

您可以使用AssetPack等工具生成MSDF/SDF字体，该工具可以采用 `.ttf` 或 `.otf` 字体，并生成具有MSDF/SDF支持的位图字体图集。

使用MSDF/SDF字体类似于使用普通的位图字体，只需要你加载适当的字体文件：

```ts
import { Assets, BitmapText } from 'pixi.js';

await Assets.load('fonts/MyMSDFFont.fnt');

const text = new BitmapText({
    text: 'Loaded MSDF font!',
    style: {
        fontFamily: 'MyMSDFFont',
    },
});
```

#### 7.5.2.3 限制和注意事项

1. 无法更新分辨率

`BitmapText.resolution` 不可变。必须由 `BitmapFont`处理

```ts
text.resolution = 2;
// [BitmapText] dynamically updating the resolution is not supported.
```

2. 大字符集不实用

位图字体受纹理大小的限制。CJK或表情符号丰富的集合可能需要太多的内存。使用 `Text` 或 `HTMLText` 来支持动态国际化或表情符号。



### 7.5.3 HMTL文本



`HTMLText` 使样式化，格式化的HTML字符串作为PixiJS场景图形的一部分呈现。它使用SVG  `<foreignObject>` 来将浏览器原生的HTML嵌入到WebGL画布中。

这使得它非常适合渲染复杂的排版、内联格式、表情符号和布局效果，这些都是使用传统的画布渲染文本难以复制的。

```ts
import { HTMLText } from 'pixi.js';

const html = new HTMLText({
    text: '<strong>Hello</strong> <em>PixiJS</em>!',
    style: {
        fontFamily: 'Arial',
        fontSize: 24,
        fill: '#ff1010',
        align: 'center',
    },
});

app.stage.addChild(html);
```

1. 为什么使用 `HTMLText` ？​

*   支持行内标签像 `<b>` ,  `<i>` ,  `<span>` ,等等。
*   兼容表情符号，Unicode和RTL文本
*   通过CSS的细粒度布局控制
*   标签样式覆盖( `<warning>` ,  `<link>` ,等等)。

2. 异步渲染行为

HTML文本使用SVG  `<foreignObject>` 在画布内绘制HTML。结果是：

*   呈现是异步发生的。通常在下一帧之后。
*   文本内容在实例化后不会立即可见。

3. **Styling HTMLText**

`HTMLTextStyle` extends `TextStyle` and adds:

*   **HTML-aware tag-based styles** via `tagStyles`
*   **CSS override support** via `cssOverrides`

```ts
const fancy = new HTMLText({
    text: '<red>Red</red>, <blue>Blue</blue>',
    style: {
        fontFamily: 'DM Sans',
        fontSize: 32,
        fill: '#ffffff',
        tagStyles: {
            red: { fill: 'red' },
            blue: { fill: 'blue' },
        },
    },
});
```

4. CSS Overrides

您可以使用`cssOverrides`属性将CSS样式应用于文本。这允许您设置“文本阴影”、“文本装饰”等属性。

```ts
fancy.style.addOverride('text-shadow: 2px 2px 4px rgba(0,0,0,0.5)');
```


### 7.5.4 文本样式

1. 样式

 `TextStyle` 类封装了文本的所有视觉样式属性。您可以定义颜色、字体系列、笔画、阴影、对齐、行间距、换行等等。

一个 `TextStyle` 实例可以跨多个 `Text` 对象重用，从而使代码更简洁并提高内存效率。

```ts
import { TextStyle } from 'pixi.js';

const style = new TextStyle({
    fontFamily: 'Arial',
    fontSize: 30,
    fill: '#ffffff',
    stroke: '#000000',
    strokeThickness: 3,
    dropShadow: {
        color: '#000000',
        blur: 5,
        distance: 4,
        angle: Math.PI / 4,
        alpha: 0.5,
    },
});

const label = new Text({
    text: 'Score: 1234',
    style,
});
```

2. 填充和描边

使用填充和笔画与 `Graphics` 类相同。您可以在图形填充部分找到有关它们的更多详细信息。

```ts
// 使用数字颜色
const fill = 0xff0000;

// 使用十六禁止颜色
const fill = '#ff0000';

// 使用rgb 颜色
const fill = [255, 0, 0];

// 使用颜色对象
const color = new Color();
const obj4 = color;

// 使用渐变
const fill = new FillGradient({
    type: 'linear',
    colorStops: [
        { offset: 0, color: 'yellow' },
        { offset: 1, color: 'green' },
    ],
});

// 使用图案
const txt = await Assets.load<Texture>('https://pixijs.com/assets/bg_scene_rotate.jpg');
const fill = new FillPattern(txt, 'repeat');

// 在TextStyle中使用填充
const style = new TextStyle({
    fontSize: 48,
    fill: fill,
    stroke: {
        fill,
        width: 4,
    },
});
```

3. 阴影

在v8中 `dropShadow` 和它的属性现在是对象。要更新投影，您可以直接在 `dropShadow` 对象上设置属性。

```ts
const style = new TextStyle({
    dropShadow: {
        color: '#000000',
        alpha: 0.5,
        angle: Math.PI / 4,
        blur: 5,
        distance: 4,
    },
});

style.dropShadow.color = '#ff0000'; // Change shadow color
```

## 7.6 Mesh 


PixiJS v8提供了一个强大的 `Mesh` 系统，提供了对几何图形、uv、索引、着色器和WebGL/WebGPU状态的完全控制。网格是自定义渲染效果、高级失真、透视操作或性能调整渲染管道的理想选择。

```ts
import { Texture, Mesh, MeshGeometry, Shader } from 'pixi.js';

const geometry = new MeshGeometry({
    positions: new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
    uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
});

const shader = Shader.from({
    gl: {
        vertex: `
            attribute vec2 aPosition;
            attribute vec2 aUV;
            varying vec2 vUV;
            void main() {
                gl_Position = vec4(aPosition / 100.0 - 1.0, 0.0, 1.0);
                vUV = aUV;
            }
        `,
        fragment: `
            precision mediump float;
            varying vec2 vUV;
            uniform sampler2D uSampler;
            void main() {
                gl_FragColor = texture2D(uSampler, vUV);
            }
        `,
    },
    resources: {
        uSampler: Texture.from('image.png').source,
    },
});

const mesh = new Mesh({ geometry, shader });
app.stage.addChild(mesh);
```

### 7.6.1 什么是Mesh？​

Mesh是由以下元素组成的低级渲染原语：

*   几何：顶点位置、uv、索引和其他属性
*   Shader：一个定义几何图形如何渲染的GPU程序
*   状态：GPU状态配置（如混合、深度、模板）

有了这些元素，你可以构建任何东西，从简单的四边形到曲面和程序效果。

### 7.6.2 MeshGeometry

PixiJS中的所有网格都是使用 `MeshGeometry` 类构建的。这个类允许你定义顶点位置，UV坐标，以及描述网格形状和纹理映射的索引。

```ts
const geometry = new MeshGeometry({
    positions: Float32Array, // 2 floats per vertex
    uvs: Float32Array, // matching number of floats
    indices: Uint32Array, // 3 indices per triangle
    topology: 'triangle-list',
});
```

你可以直接访问和修改缓冲区：

```ts
geometry.positions[0] = 50;
geometry.uvs[0] = 0.5;
geometry.indices[0] = 1;
```

### 7.6.3 内置网格类型

1. MeshSimple

 `Mesh` 的最小包装器，直接接受顶点、UV和索引数组。适用于快速静态或动态网格。

```ts
const mesh = new MeshSimple({
    texture: Texture.from('image.png'),
    vertices: new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
    uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
});
```

*   使用 `autoUpdate = true` 来更新每帧的几何图形。
*   Access  `mesh.vertices` 读写数据。

2. MeshRope

沿着一系列控制点弯曲纹理，通常用于小径，蛇和动画丝带。

```ts
const points = [new Point(0, 0), new Point(100, 0), new Point(200, 50)];
const rope = new MeshRope({
    texture: Texture.from('snake.png'),
    points,
    textureScale: 1, // optional
});
```

*   `textureScale > 0` 重复纹理； `0` 拉伸它。
*   `autoUpdate = true` 每帧重新计算几何。

3. MeshPlane

一种灵活的细分四边形网格，适用于扭曲或基于网格的翘曲。

```ts
const plane = new MeshPlane({
    texture: Texture.from('image.png'),
    verticesX: 10,
    verticesY: 10,
});
```

*   当 `autoResize = true` 时，自动调整纹理更新的大小。

4. PerspectiveMesh

 `MeshPlane` 的特殊子类，通过转换uv应用透视校正。

```ts
const mesh = new PerspectiveMesh({
    texture: Texture.from('image.png'),
    verticesX: 20,
    verticesY: 20,
    x0: 0,
    y0: 0,
    x1: 300,
    y1: 30,
    x2: 280,
    y2: 300,
    x3: 20,
    y3: 280,
});
```

*   通过 `setCorners(...)` 设置角坐标。
*   理想的模拟3D投影在2D。



## 7.7 ParticleContainer


ixiJS v8通过 `ParticleContainer` 和 `Particle` 类引入了高性能粒子系统。专为渲染大量轻量级视觉效果而设计，如火花、气泡、兔子或爆炸，该系统通过剥离所有不必要的开销来提供原始速度。

**实验性空气污染指数公告**

粒子API是稳定的，但只是实验性的。它的界面可能会在未来的PixiJS版本中发展。我们欢迎反馈意见，以帮助指导其发展。

```ts
import { ParticleContainer, Particle, Texture } from 'pixi.js';

const texture = Texture.from('bunny.png');

const container = new ParticleContainer({
    dynamicProperties: {
        position: true, // default
        scale: false,
        rotation: false,
        color: false,
    },
});

for (let i = 0; i < 100000; i++) {
    const particle = new Particle({
        texture,
        x: Math.random() * 800,
        y: Math.random() * 600,
    });

    container.addParticle(particle);
}

app.stage.addChild(container);
```

### 7.7.1 为什么要使用粒子容器？​

*   极致性能：以高FPS渲染数十万甚至数百万个粒子。
*   轻量级设计：粒子比 `Sprite` 更有效，缺少子、事件或过滤器等额外功能。
*   细粒度控制：通过声明哪些属性是动态的（每帧更新）或静态的（设置一次）来优化呈现。

**性能提示：静态vs.动态**

*   动态属性每帧上传到GPU。
*   只有在调用 `update()` 时才上传静态属性。

明确声明你的需求：

```ts
const container = new ParticleContainer({
    dynamicProperties: {
        position: true,
        rotation: true,
        scale: false,
        color: false,
    },
});
```

如果以后修改静态属性或粒子列表，必须调用：

```ts
container.update();
```

### 7.7.2 限制和API差异

`ParticleContainer` 是为了速度和简单而设计的。因此，它不支持完整的 `Container`  API：

1. 不可用：

*   `addChild()` 、 `removeChild()`
*   `getChildAt()` 、 `setChildIndex()`
*   `swapChildren()` 、 `reparentChild()`

2. 代替使用：

*   `addParticle(particle)`
*   `removeParticle(particle)`
*   `removeParticles(beginIndex, endIndex)`
*   `addParticleAt(particle, index)`
*   `removeParticleAt(index)`

这些方法对 `.particleChildren` 数组进行操作，并正确维护内部GPU缓冲区。

### 7.7.3 创建粒子

A  `Particle` 支持键显示属性，效率远高于 `Sprite` 。

1. 粒子的例子

```ts
const particle = new Particle({
    texture: Texture.from('spark.png'),
    x: 200,
    y: 100,
    scaleX: 0.8,
    scaleY: 0.8,
    rotation: Math.PI / 4,
    tint: 0xff0000,
    alpha: 0.5,
});
```

你也可以使用简写：

```ts
const particle = new Particle(Texture.from('spark.png'));
```
