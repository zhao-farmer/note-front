# 一、复习typescript

## 1.1 变量与常量

```ts
// TypeScript JavaScript
// 1. 类型 2.面向对象

// 声明变量 字母数字下划线 字母下划线 驼峰
var personName:string = "李逍遥110";
personName = "王小虎";
// 声明常量
const tmp:number = 111.1;
document.writeln(personName)
```

## 1.2 变量类型

```ts
// number:数字类型
let type01:number = 333;
// string：字符类型
let type02:string = "你好";
// undefined:未赋值
let type03:undefined;
// null:空值
let type04:null;
// boolean:布尔值
let type05:boolean = true;
// any：类型
let type06:any = 1>2?"任意类型":22
// Array:数组类型
let type07:Array<number> = [1,2,3]
let type08:string[] = ["王小虎","李逍遥"]
// Object:对象类型
let type09:object = {"名字":"李逍遥"}
let type10:{} = {"名字":"王小虎"}
// 联合类型
let type11:number | string = 0
type11 = "李逍遥"


// 类型验证
let x = 30;
console.log(typeof x); // number

// 类型别名
type newNumber = number | string
let a:newNumber = 70
let b:newNumber = "70"
console.log(typeof a); // number
```

## 1.3 枚举

```ts
// 枚举 自己定义一个属于自己的类型
let color1:number = 0; //0白色 1黑色
let state1:number = 0; //0战力 1跑步 2死亡 3攻击


enum Color{
    red,
    blue,
    green
}

// 代表颜色
let color2:Color = Color.red

enum State{
    idle,
    run,
    death,
    attack
}
// 代表人物状态
let state2:State = State.idle
```

## 1.4 运算符 

```ts
// 运算符
// 1. 算术运算符
// + 0 * / %
let num1 = 10 % 3;
console.log(num1); //1

// 2. 自增自减
// ++ -- 
let num2 = 10;
num2++; // num2 = num2 + 1
num2--; // num2 = num2 - 1

// 先使用，再自增 num++
console.log(num2++ + "");
// 先自增，再使用 ++num
console.log(++num2 + "");

// 3. 比较运算符 > < >= <= == === != !==
let res1:boolean = 5 > 3
let res2:boolean = 5 <= 3
// == 值相同 === 值与类型都相同
let res3:boolean = "5" == 5
let res4:boolean = "5" === 5
let res5:boolean = "5" != 5
let res6:boolean = "5" !== 5


// 4. 逻辑运算符  && 并且 || 或者  ! 非
let num3 = 5
// && 都为真
let res7:boolean = num3 > 3 && num3 < 10
// || 任意一个为真
let res8:boolean = num3 > 3 || num3 < 10
// ! 非
let res9:boolean = !(num3 > 3)

// 5. 赋值运算符 = += -= *=

// 右边赋值给左边
let num4:number = 3
// 下面两行相等
num4 = num4 + 1
num4 += 1
```

## 1.5 条件控制语句

```ts
// 条件控制语句 
// 1. 判断语句
let score = 20;
if(score >= 0 && score < 60){
    console.log("不合格");
}else if(score >=60 && score < 80){
    console.log("合格");
}else if(score >= 80 && score <= 100){
    console.log("优秀");
}else{
    console.log("出错");
}



// 2. 三目运算符 条件?值1:值2
let num = 105
// 直接进行判断
num = num>100?100:num


// switch 语句
enum State2{
    idle,
    run,
    attack,
    die
}

let state:State2 = State2.idle

switch(state){
    case State2.die:
        console.log("站立");
        break;
    case State2.run:
        console.log("跑步");
        break;
    case State2.attack:
        console.log("攻击");
        break;
    default:
        console.log("死亡");      
}
```

## 1.6 循环控制语句

```ts
// 循环控制语句

// 1. while循环
let i: number = 0;
while (i < 5) {
    console.log("hello");
    i++;
}

// 2. do while 循环
let a1:number = 0;
do{
    console.log("hello");
}while(a1<5)

// while 与 do while 区别
// do while 判断前先执行代码


// 3. for循环
for (let b = 0; b < 3; b++) {
   console.log("hello" + b);
}

// 4. for of 判断
let names:string[] = ["王小虎","李逍遥","赵灵儿"];
for  (let tempName of names) {
    console.log(tempName);
}

// 5. for in 循环
for (const index in names) {
    console.log(names[index]);
}

// 6. 跳出循环
for (let c = 0; c < 10; c++) {
   if(i<5){
        // 跳过本次循环
        continue;
   }else if(i>8){
        // 直接跳出循环
        break;
   }    
}
```

## 1.7 函数

```ts
// 函数 流水线 -> 输入 输出
// 输入：参数  输出：返回值
function func(char:string){
    let arr :string[] = ['a','b','c','d','e'];
    for (let i = 0; i < 5; i++) {
        if(char === arr[i]){
            if(char === arr[i]){
                console.log("当前是第" + i + "个字符");
                
            }
        }
    }
}

func("a");
func("b");
func("c");

function add(num1:number,num2:number):string{
    let num = num1 + num2;
    return num + "";
}
let test = add(3,4)

// 可以写返回值 :void 与 return
function add2(num1:number,num2:number):void{
    let num = num1 + num2;
    return ;
}

// 也可以这样写
let add3 = function(){

}
// 箭头函数
let add4 = () =>{

}
```

## 1.8 面向对象

```ts
// 面向对象编程

let eName:string = "令狐冲"
let eAge:number = 20;
let aScore:number = 80;


let bName:string = "岳不群";
let bAge:number = 40;
let bScore:number = 80;

// 说话
function say(name:string,age:number){
    console.log("大家好，我叫" + name + ",今年" + age);
}

say(eName,eAge)

// 跑步
function run(name:string){
    console.log(name + "正在跑步");
}

run(eName);
run(bName)


// 对象与对象
// 类：磨具，抽象
// 对象：存在的物体

// 类：人 对象：令狐冲、岳不群
// 属性 方法
class Person{
    name:string  = "默认"
    age:number = 0;
    say(){
        console.log(this.name);
    }
}

// 实例化对象
let person1 = new Person();
person1.name = "令狐冲";
person1.age = 20;
person1.say()


let person2 = new Person();
person2.name = "岳不群"
person2.age = 40;
person2.say()
```

## 1.9 构造与静态

```ts

// 成员属性 成员方法
// 静态属性 静态方法
class Person2{
    // 静态属性
    static des:string = "这是一个Person类"

    name:string = "默认";
    age:number = 0;

    // 构造方法
    constructor(name:string,age:number){
        this.name = name 
        this.age = age 
    }

    say(){
        console.log(this.name + "说话");
    }
    // 静态方法
    static run(){
        console.log("测试跑步");
    }
}

// 使用构造方法创建类
let c = new Person2("令狐冲",20);
let d = new Person2("岳不群",40);
c.say()
d.say()

// 静态属性使用
console.log(Person2.des);
Person2.run()
```

## 1.10 继承与抽象类

```ts
// 继承
class Person3{
    name:string = "";

    say(){
        console.log("我是人类，叫做" +  this.name);
    }
}

class Student extends Person3{
    num:number = 0;
    score:number = 0;

    say(): void {
        console.log("学生说的我的分数是" + this.score);   
    }
}

let student = new Student()
student.name = "aaa"
student.say()


// 抽象类
abstract class Person4{
    name:string = "";
    abstract say():void
}

class Teacher extends Person4{
    say(){
        console.log("教师类实现抽象类方法");
    }
}

let teather:Person4 = new Teacher()
teather.say()
```

## 1.11 接口与私有化

```ts
// 接口
// 人 狼 狼人：人，狼

class Person5{
    name:string
}

interface IWolf{
    attack():void;
}
interface IDog{
    eat():void
}


class WolfMan extends Person5 implements IWolf,IDog{
     attack(){

     }
     eat(){

     }
}


// 属性寄存器
class Person6{
    _hp:number = 100;

    // 取值
    get hp(){
        return this._hp;
    }

    // 赋值
    set hp(value){
        if(value < 0){
            this._hp = 0
        }else{
            this._hp = value;
        }
    }
}

let p1 = new Person6();
p1.hp -= 100;
console.log(p1.hp + "");
```

## 1.12 名称空间

```ts
// 相同的类可以使用不同的名称空间 
// 解决类的命名冲突问题
namespace aa{
    export class Person{
        name:string;
    }
}
namespace bb{
    export class Person{
        //
    }
}

let p2 = new aa.Person();
let p3 = new bb.Person();
```

## 1.13 泛型

```ts
function add5(num:any):any{
    if(typeof num == "number"){
        num++;
        return num;
    }
    return num;
}

console.log(add5("3"),add5(3));


// 使用泛型
function add6<T>(num:T):T{
    if(typeof num == "number"){
        num++;
        return num;
    }
    return num;
}

// number类型
add6<number>(3)
// string类型
add6<string>("3")
```

## 1.14 元组数据字典

```ts
// 元组
let hero:[string,number] = ["超人",100]
hero[0] = "蝙蝠侠"

// 数组
let array1:number[] = [1,2,3]
let array2:Array<number> = new Array<number>();

// 数组遍历
for (let i = 0; i < array1.length; i++) {
    console.log(array1[i]);
}

// 在数组后面追加元素
array1.push(4);
// 在数组前面添加元素
array1.unshift(0)
// 删除最后面的元素
array1.pop()
// 从第几位开始删除几个
array1.splice(0,1)

// 合并两个数组
array1 = array1.concat(array2)
// 查找元素位置
let index = array1.indexOf(1)
// 排序
array1.sort()
// 倒序
array1.reverse()

console.log(array1 + "");


// 字典对象
let dic:{[key:string]:string} = {
    "name":"王小虎",
    "name2":"李逍遥"
}

dic["name3"] = "令狐冲"
console.log(dic["name3"]);
```

## 1.15 回调

```ts
// 函数传参
function func2(value:Function){
    //...
    value("nana")
}

// 定义参数函数
function test2(name:string){
    console.log("test");
}
func2(test2)


// 使用匿名函数
func2(function(name:string){
    console.log("test2");
})

// 使用箭头函数
func2((name:string)=>{
    console.log("test3");
})
```

## 1.16 正则表达式

```ts
let reg = /\d{4}-\d{7}/g
let str = "0345-1234567"
let res10 = reg.exec(str)

// 是否匹配到
console.log(res10?.length + "");
// 匹配到的内容
res10?.forEach(function(value,index) {
    console.log(value + " " + index); 
})
```

## 1.17 访问修饰符

```ts
// public访问修饰符
class Person8{
    public name:string;
    public say(){
        console.log("测试方法" + this.name);
    }
}

class Student2 extends Person8{
    constructor(){
        super()
    }
    run(){
        console.log(this.name);
    }
}

let p4 = new Person8();
p4.name = ""
p4.say()
let st4 = new Student2()
st4.say()


// protected 受保护的 只能在类内部访问
class Person9{
    protected name:string;
    protected say(){
        console.log("测试方法"+ this.name);
    }
}

class Student3 extends Person9{
    constructor(){
        super()
    }
    run(){
        console.log(this.name);
    }
}


let p5 = new Person9();
// p5.name = ""
// p5.say()
let st5 = new Student3()
// st5.say() 


// private 完全私有的 只有内部可以访问
class Person10{
    private name:string;
    private say(){
        console.log("测试方法"+ this.name);
    }
}

class Student4 extends Person10{
    constructor(){
        super()
    }
}
let p6 = new Person10();
// p5.name = ""
// p5.say()
let st6 = new Student4()
// st5.say() 



// 项目中真正经常用的 属于封装的概念
class Person11{
    private _name:string;
    set name(value:string){
        this._name = value
    }
    get name(){
        return this._name
    }
}

class Student5 extends Person11{
    constructor(){
        super()
        console.log(this.name);
    }
}
```

## 1.18 单例模式

```ts
// 单例
class SoundManager{
    static Instance = new SoundManager();
    private constructor(){

    }
}

// 使用声音管理类
SoundManager.Instance;




// 第二种懒加载 只用使用时才会产生
class SoundManager2{
    private static instance:SoundManager2;
    private constructor(){}

    static Instance(){
        // 当前单例是否产生
        if(!SoundManager2.instance){
            SoundManager2.instance = new SoundManager2()
        }
        return SoundManager2.instance
    }
}

SoundManager2.Instance()
```

## 1.19 代理模式

```ts
interface ICalc{
    calc(num1:number,num2:number):number;
}

class Npc1 implements ICalc{
    calc(num1: number, num2: number): number {
        return num1 + num2;
    }
}

class Npc2 implements ICalc{
    calc(num1: number, num2: number): number {
        return num1 - num2;
    }
}

class Person12{
    // 代理
    delegate:ICalc;
    // 计算数字
    GetNum(num1:number,num2:number){
        // 拿到num1和num2计算后的结果
        let num = this.delegate.calc(num1,num2);
        console.log(num + "");
        
    }
}

let p7 = new Person12();
// 设定一个代理
p7.delegate = new Npc1();
p7.GetNum(3,4)

p7.delegate = new Npc2();
p7.GetNum(3,4)
```

## 1.20 观察者模式

```ts
interface IObserver{
    nameChanged(newName:string):void;
}

class Person13{
    private _name:string;
    // 所有的观察者
    observers:Array<IObserver> = new Array<IObserver>();

    set name(value:string){
        this._name = value;
        // 发生变化
        // 遍历观察者数组，给所有的观察者发消息
        for(let observers of this.observers){
            observers.nameChanged(this._name);
        }
    }
    get name(){
        return this._name;
    }
}

class Test implements IObserver{
    nameChanged(newName:string){
        console.log("监听到变化，名字变为" + newName);
    }
}

let p8 = new Person13();
let t2 = new Test();

// 设置为监听对象
p8.name = "哈哈哈"
```

## 1.21 工厂模式

```ts
enum CarType{
    Bmw,
    Audi,
    Benz
}

class Car{
    name:string;
    // 工厂方法
    static Create(carType:CarType): Car{
        let car:Car;
        switch(carType){
            case CarType.Audi:
                car = new Audi()
                break;
            case CarType.Benz:
                car = new Benz()
                break;
            case CarType.Bmw:
                car = new Bmw()
                break;
        }
        return car;
    }
}

class Bmw extends Car{}
class Audi extends Car{}
class Benz extends Car{}

// 使用工厂创建对象
let bmw = Car.Create(CarType.Benz)
```

## 1.22 链表

```ts
class Person14{
    name:string;
    next:Person14;
    constructor(name:string){
        this.name = name
    }
}

let p9 = new Person14("李逍遥");
p9.next = new Person14("王小虎");
p9.next.next = new Person14("赵灵儿");

// 删除
p9.next = p9.next.next

// 添加
let tmpPerson = new Person14("赵四儿");
tmpPerson.next = p9.next
p9.next = tmpPerson

// 遍历
while(p9){
    console.log(p9.name);
    // 让节点向后移
    p9 = p9.next   
}
```