# 四、UI组件

## 4.1 canvas 画布

打开项目，点击canvas上，有两个特殊的组件

![](/application/cocos/base/102.png)


1. 锁定的 `UITransform` 组件

    ![](/application/cocos/base/105.png)

    - canvas组件的宽高可以在项目中设置
    - 可以让游戏自适应不同屏幕的大小
        
2. Canvas组件

    - CameraComponent：Canvas 关联的相机，此相机不一定会渲染 Canvas 下内容，可以与 AlignCanvasWithScreen 属性配合自动改变 Camera 的一些参数使其与 Canvas 对齐

    - AlignCanvasWithScreen：Canvas 关联的相机是否要与 Canvas 对齐，如果想要自己控制相机位置请勿勾选此选项（卷轴游戏等）


## 4.2 label 文本信息

1. 新建节点

    ![](/application/cocos/base/107.png)

2. 属性信息

    ![](/application/cocos/base/108.png)

    - Label 排版
        - NONE：Label 组件默认的排版模式，此模式不会进行自动换行。
        - CLAMP：文字尺寸不会根据 Content Size 的大小进行缩放。
        - SHRINK：文字尺寸会根据 Content Size 大小进行自动缩放。
        - RESIZE_HEIGHT：文本的 Content Size 会根据文字排版进行适配，这个状态下用户无法手动修改文本的高度，文本的高度由内部算法自动计算出来。

    - 文本缓存类型（Cache Mode）
        - NONE：默认值，Label 中的整段文本将生成一张位图。
        - BITMAP：选择后，Label 中的整段文本仍将生成一张位图，但是会尽量参与 动态合图。
        - CHAR：Label 将以“字”为单位将文本缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。能支持文本的频繁修改，对性能和内存最友好。也有更多限制，比如无法合成动图。
    - 使用字体

        ![](/application/cocos/base/109.png)
    - 其他与html一致


## 4.3 richText 富文本

1. 新建richText

    ![](/application/cocos/base/110.png)

2. 使用样式

    - 界面

        ![](/application/cocos/base/111.png)

    - 富文本

        ```xml
        我是<color=#ff0000>红色</color>,
        <size=60>大</size>号字体，
        <i>斜体</i>,
        <u>下划线</u>,
        <outline color=#ff0>描边</outline>
        ```
3. 触发事件

    - 界面

        ![](/application/cocos/base/112.png)

    -  富文本

        ```xml
        <color=red><on click="test">点击</on></color>调用
        ```
    - Test.ts 脚本

        ```ts
        import { _decorator, Component, Node } from 'cc';
        const { ccclass, property } = _decorator;

        @ccclass('Test')
        export class Test extends Component {
            start() {

            }

            update(deltaTime: number) {
                
            }

            test(){
                console.log("点击了");
            }
        }
        ```

    - 运行结果

        ![](/application/cocos/base/113.png)

4. 图文混排

    - 界面

        ![](/application/cocos/base/114.png)

    - 富文本

        ```xml
        这是一个地面<img src="land" click="test"/>吗
        ```


## 4.4 mask 遮罩 

1. 新建遮罩

    ![](/application/cocos/base/115.png)

2. mask属性

    | 属性       | 功能说明                                                       |
    |----------|------------------------------------------------------------|
    | Type     | 遮罩类型。包括 RECT、ELLIPSE、GRAPHICS_STENCIL、SPRITE_STENCIL 四种类型。 |
    | Segments | 椭圆遮罩的曲线细分数，只在遮罩类型设为 ELLIPSE 时生效                            |
    | Inverted | 反向遮罩                                                       |


    - RECT 矩形遮罩

        ![](/application/cocos/base/116.png)

    - ELLIPSE 椭圆遮罩

        - Segments 等于 3 - 20 机会都能看出是多边形

            - 值为3(值小于3都等于3，三角型)

                ![](/application/cocos/base/117.png)
            - 值为7(7边形)

                ![](/application/cocos/base/118.png)
        - Segments 大于20

            - 值为32

                ![](/application/cocos/base/119.png)
            - 值为64

                ![](/application/cocos/base/120.png)

    - GRAPHICS_STENCIL 自定义图形遮罩

        - 自定义遮罩界面

            ![](/application/cocos/base/121.png)
        - 脚本设置

            ```ts
            import { _decorator, Component, Mask, Graphics } from 'cc';
            const { ccclass, property } = _decorator;

            @ccclass('Test')
            export class Test extends Component {
                start() {
                    // 获取图形
                    const g = this.node.getComponent(Graphics);

                    // 遮罩的配置
                    g.lineWidth = 10;
                    g.fillColor.fromHEX('#ff0000');

                    // 移动位置，类似canvas
                    g.moveTo(-40, 0);
                    // 超出组件的大小
                    g.lineTo(0, -160);
                    g.lineTo(40, 0);
                    g.lineTo(0, 80);
                    g.close();
                    g.stroke();
                    g.fill();
                }

            }
            ```
        - 运行结果

            ![](/application/cocos/base/122.png)

    - SPRITE_STENCIL 自定义图片遮罩

        - 自定义图片需先删除图形

            ![](/application/cocos/base/123.png)

        - 自定义图片设置

            ![](/application/cocos/base/124.png)

## 4.5 widget 屏幕适配

1. 问题：当设定图片在画布的右上角，在不同的屏幕下，会呈现不同的效果

    - 界面

        ![](/application/cocos/base/125.png)

    - ipad 运行结果

        ![](/application/cocos/base/126.png)

2. 属性介绍

    - 新建 Widget 组件

        ![](/application/cocos/base/106.png)

    - 对齐属性
        - 说明
            - 下面两个类别都有五个按钮，是五个不同的属性，把鼠标放上按钮上，一秒后出现属性名
            - 默认对齐的是父节点的矩形边框
        - `Horizontal Alignment` 水平对齐
            - NONE: 没有对齐属性
            - left: 左对齐；出现 `left输入框`，是离左边框的距离
            - center: 中心对齐；出现 `center输入框`， 以中心点为准，左右距离
            - right: 右对齐；出现 `right输入框`，距离右边框的距离
            - Horizontal stretch: 水平拉伸；出现 `left输入框`与`right输入框`，默认会给出当前组件的正常拉伸，如果为零拉伸为整个父组件的水平大小

        - `Vertical Alignment` 垂直对齐
            - NONE: 没有对齐属性
            - top: 上对齐；出现 `top输入框`，是离上边框的距离
            - center: 中心对齐；出现 `center输入框`， 以中心点为准，上下距离
            - bottom: 下对齐；出现 `bottom输入框`，距离下边框的距离
            - Vertical stretch: 处置拉伸；出现 `top输入框`与`bottom输入框`，默认会给出当前组件的正常拉伸，如果为零拉伸为整个父组件的垂直大小
    - 其他属性
        - Target：对齐目标；指定对齐参照的节点，当这里未指定目标时会使用直接父级节点作为对齐目标
        - AlignMode: 指定 Widget 的对齐方式，用于决定运行时 Widget 应何时更新；	通常设置为 ALWAYS，每次节点产生变动时重新对齐。设置为 ONCE 时，仅在组件初始化时进行一次对齐。ON_WINDOW_RESIZE 时会在每次窗口变动时候更新一次

3. 屏幕适配

    - 界面

        ![](/application/cocos/base/127.png)

    - 项目自适应的宽、高，不能都选

        ![](/application/cocos/base/130.png)

    - ipad运行结果

        ![](/application/cocos/base/128.png)

    - 苹果手机设置

        ![](/application/cocos/base/129.png)

## 4.6 button 按钮

1. 界面中的button按钮

    ![](/application/cocos/base/131.png)

2. Button 属性

    - 属性说明

        | 属性 | 功能说明  |
        |--------------|-----------------|
        | Target       | Node 类型，当 Button 发生 Transition 的时候，会相应地修改 Target 节点的 SpriteFrame，颜色或者 Scale。  |
        | Interactable | 布尔类型，设为 false 时，则 Button 组件进入禁用状态。 |
        | Transition   | 枚举类型，包括 NONE、COLOR、SPRITE 和 SCALE。每种类型对应不同的 Transition 设置。详情见下方的 Button Transition 部分。 |
        | Click Event  | 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Button 点击事件 部分。   |

    - Transition属性
        - NONE: 无任何特殊效果
        - COlOR: 颜色变化
        - SPRITE：精灵变化
        - SCALE: 大小变化
      
        - 应用
            - 颜色变化
                - 界面设置

                    ![](/application/cocos/base/132.png)
                - 属性参数
                    - Normal：Button 在 Normal 状态下的颜色。
                    - Pressed：Button 在 Pressed 状态下的颜色。
                    - Hover：Button 在 Hover 状态下的颜色。
                    - Disabled：Button 在 Disabled 状态下的颜色。
                - 运行结果

                    ![](/application/cocos/base/133.gif)
            - 精灵变化
                - 界面设置

                    ![](/application/cocos/base/134.png)

                    >同时要取消label
                - 属性参数
                    - Normal：Button 在 Normal 状态下的SpriteFrame。
                    - Pressed：Button 在 Pressed 状态下的SpriteFrame。
                    - Hover：Button 在 Hover 状态下的SpriteFrame。
                    - Disabled：Button 在 Disabled 状态下的SpriteFrame。
                - 运行结果

                    ![](/application/cocos/base/135.gif)
            - 大小变化
                - 界面设置

                    ![](/application/cocos/base/136.png)
                - 属性参数
                    - Duration：Button 状态切换需要的时间间隔。
                    - ZoomScale：当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale，zoomScale 可以为负数

                - 运行结果

                    ![](/application/cocos/base/137.gif)
    - Click 与 脚本交互

        - 属性介绍

            | 属性              | 功能说明                              |
            |-----------------|-----------------------------------|
            | Target          | 带有脚本组件的节点。                        |
            | Component       | 脚本组件名称。                           |
            | Handler         | 指定一个回调函数，当用户点击 Button 并释放时会触发此函数。 |
            | CustomEventData | 用户指定任意的字符串作为事件回调的最后一个参数传入。        |

        - 界面设置

            ![](/application/cocos/base/138.png)

        - 脚本

            ```ts
            import import { _decorator, Component, EventTouch, Graphics } from 'cc';
            const { ccclass, property } = _decorator;

            @ccclass('Test')
            export class Test extends Component {
                start() {
                
                }
                test(event:EventTouch,param:number){
                    console.log("点击了",param);
                }

            }
            ```
        - 运行结果

            ![](/application/cocos/base/139.png)


## 4.7 layout 布局

1. 新建layout与模式

    ![](/application/cocos/base/140.png)

2. 四种模式

    1. NONE：没有模式，可以当成空节点使用
    2. HORIZONTAL：

        - 属性含义
            - `Aign Horizontal`: 水平对齐
            - `Resize Mode`: 缩放模式
            - `Padding Left`: 距离边框内边距-左
            - `Padding Right`: 距离边框内边距-右
            - `Spacing X`: 水平方向子节点之间的距离，类似html中gap
            - `Horizontal Directior`: 水平方向，靠左还是靠右展示
            - `Affected By Scale`: 子节点缩放影响整体布局

        - 调用展示

             ![](/application/cocos/base/142.gif)
    3. VERTICAL：
        - 属性含义
            - `Align Vertical`: 垂直对齐
            - `Resize Mode`: 缩放模式
            - `Padding Top`: 距离边框内边距-上
            - `Padding Bottom`: 距离边框内边距-下
            - `Spacing Y`: 垂直方向子节点之间的距离，类似html中gap
            - `Vertical Direction`: 垂直方向，靠上还是靠下展示
            - `Affected By Scale`: 子节点缩放影响整体布局

        - 调用展示

            ![](/application/cocos/base/143.gif)
    4. GRID(网格类似css的grid布局)：

        - 属性含义（综合了水平方向与垂直方向）
        - 调用展示

            ![](/application/cocos/base/143.gif)

    5. 两种模式

        - ResizeMode 模式：
            - 设置为 NONE 时，子物体和容器的大小变化互不影响。
            - 设置为 CHILDREN 时，子物体大小会随着容器的大小而变化。
            - 设置为 CONTAINER 时，容器的大小会随着子物体的大小变化。
        >所有的排列都是根据容器大小进行计算的，如果需要固定排序，可以将 Type 设置为 GRID，然后设置 Constraint 和 ConstraintNum 来固定排序。

        - Constraint 模式：
            - 设置为 NONE 时，自由布局。
            - 设置为 FIXED_ROW 时，固定行数，搭配 ConstraintNum 使用。
            - 设置为 FIXED_COL 时，固定列数，搭配 ConstraintNum 使用。
        >注意：Layout 设置后的结果需要到下一帧才会更新，除非你设置完以后手动调用 updateLayout API。

## 4.8 ScrollView 滑动组件

1. 界面的滑动组件

    ![](/application/cocos/base/145.png)

2. ScrollView 属性

    | 属性                  | 功能说明                                                             |
    |---------------------|------------------------------------------------------------------|
    | content             | 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。             |
    | Horizontal          | 布尔值，是否允许横向滚动。                                                    |
    | Vertical            | 布尔值，是否允许纵向滚动。                                                    |
    | Inertia             | 滚动的时候是否有加速度。                                                     |
    | Brake               | 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。 |
    | Elastic             | 布尔值，是否回弹。                                                        |
    | BounceDuration      | 浮点数，回弹所需要的时间。取值范围是 0-10。                                         |
    | HorizontalScrollBar | 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。                         |
    | VerticalScrollBar   | 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置                          |
    | ScrollEvents        | 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 ScrollView 事件     |
    | CancelInnerEvents   | 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。                |

3. 运行结果

    ![](/application/cocos/base/146.gif)

## 4.9 PageView 分页布局(轮播图)

1. 界面中的分页布局

    ![](/application/cocos/base/147.png)

2. PageView 属性

    | 属性                       | 功能说明                                                                   |
    |--------------------------|------------------------------------------------------------------------|
    | SizeMode                 | 页面视图中每个页面大小类型，目前有 Unified 和 Free 类型。                                   |
    | Content                  | 它是一个节点引用，用来创建 PageView 的可滚动内容                                          |
    | Direction                | 页面视图滚动方向                                                               |
    | ScrollThreshold          | 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原                              |
    | AutoPageTurningThreshold | 快速滑动翻页临界值，当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，该值与此临界值相比较，如果大于临界值，则进行自动翻页 |
    | Inertia                  | 否开启滚动惯性                                                                |
    | Brake                    | 开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止                                 |
    | Elastic                  | 布尔值，是否回弹                                                               |
    | Bounce Duration          | 浮点数，回弹所需要的时间。取值范围是 0-10                                                |
    | Indicator                | 页面视图指示器组件                                                              |
    | PageTurningEventTiming   | 设置 PageView、PageTurning 事件的发送时机                                        |
    | PageEvents               | 数组，滚动视图的事件回调函数                                                         |
    | CancelInnerEvents        | 布尔值，是否在滚动行为时取消子节点上注册的触摸事件                                              |

3. 运行结果

    ![](/application/cocos/base/148.gif)

## 4.10 ProgressBar 进度条

1. 界面中的进度条

    ![](/application/cocos/base/149.png)

2. ProgressBar 属性

    | 属性           | 功能说明      |
    |--------------|----------------|
    | Bar Sprite   | 进度条渲染所需要的 Sprite 组件，可以通过拖拽一个带有 Sprite 组件的节点到该属性上来建立关联。                                           |
    | Mode         | 支持 HORIZONTAL（水平）、VERTICAL（垂直）和 FILLED（填充）三种模式，可以通过配合 reverse 属性来改变起始方向。                         |
    | Total Length | 当进度条为 100% 时 Bar Sprite 的总长度/总宽度。在 FILLED 模式下 Total Length 表示取 Bar Sprite 总显示范围的百分比，取值范围从 0 ~ 1。 |
    | Progress     | 浮点，取值范围是 0~1，不允许输入之外的数值。                                                                         |
    | Reverse      | 布尔值，默认的填充方向是从左至右/从下到上，开启后变成从右到左/从上到下。                                                            |

3. 设置脚本运行

    - 脚本

        ```ts
        import { _decorator, Component, ProgressBar } from 'cc';
        const { ccclass, property } = _decorator;

        @ccclass('Test')
        export class Test extends Component {
            start() {
                let progressBar = this.node.getComponent(ProgressBar);
                progressBar.progress = 0;

                // 0.3 秒 进度条 进 百分百之五
                this.schedule(()=>{
                    if(progressBar.progress<1){
                        progressBar.progress += 0.05
                    }
                },0.3)
            }
        
        }
        ```

    - 运行结果

        ![](/application/cocos/base/150.gif)

## 4.11 Slider 滑动条

1. 界面中的滑动条 

    ![](/application/cocos/base/151.png)
2. Slider 属性

    | 属性          | 功能说明                             |
    |-------------|----------------------------------|
    | handle      | 滑块按钮部件，可以通过该按钮进行滑动调节 Slider 数值大小 |
    | direction   | 滑动器的方向，分为横向和竖向                   |
    | progress    | 当前进度值，该数值的区间是 0-1 之间             |
    | slideEvents | 滑动器组件事件回调函数                      |

3. 运行结果

    ![](/application/cocos/base/114.png)

## 4.12 EditBox 输入框

1. 界面中的输入框

    ![](/application/cocos/base/153.png)

2. EditBox 属性

    | 属性                   | 功能说明                                        |
    |----------------------|---------------------------------------------|
    | BackgroundImage      | 输入框背景节点上挂载的 Sprite 组件对象                     |
    | FontColor            | 输入框文本的颜色                                    |
    | FontSize             | 输入框文本的字体大小                                  |
    | InputFlag            | 指定输入标识：可以指定输入方式为密码或者单词首字母大写（仅支持 Android 平台） |
    | InputMode            | 指定输入模式：ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。  |
    | LineHeight           | 输入框文本的行高                                    |
    | MaxLength            | 输入框最大允许输入的字符个数                              |
    | Placeholder          | 输入框占位符的文本内容                                 |
    | PlaceholderFontColor | 输入框占位符的文本字体颜色                               |
    | PlaceholderFontSize  | 输入框占位符的文本字体大小                               |
    | PlaceholderLabel     | 输入框占位符节点上挂载的 Label 组件对象                     |
    | ReturnType           | 指定移动设备上面回车按钮的样式                             |
    | String               | 输入框的初始输入内容，如果为空则会显示占位符的文本                   |
    | TabIndex             | 修改 DOM 输入元素的 tabIndex，这个属性只有在 Web 上面修改有意义。  |
    | TextLabel            | 输入框输入文本节点上挂载的 Label 组件对象                    |

3. 运行结果

    ![](/application/cocos/base/154.gif)

## 4.13 toggle 复选框

1. 界面中的复选框

    ![](/application/cocos/base/155.png)

2. toggle 属性

    | 属性           | 功能说明                                                              |
    |--------------|-------------------------------------------------------------------|
    | isChecked    | 布尔类型，如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。 |
    | checkMark    | Sprite 类型，Toggle 处于选中状态时显示的图片                                     |
    | Check Events | 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Toggle 事件 部分       |


    >注意：因为 Toggle 继承自 Button，所以关于 Toggle 的 Button 相关属性的详细说明和用法请参考 Button 组件。

3. 运行结果

    ![](/application/cocos/base/156.gif)

## 4.14 ToggleContainer 单选框

1. 界面中的单选框

    ![](/application/cocos/base/157.png)

2. ToggleContainer 属性

    | 属性             | 功能说明                                          |
    |----------------|-----------------------------------------------|
    | AllowSwitchOff | 如果这个设置为 true，那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。 |
    | CheckEvents    | 选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。 |

3. 运行结果

    ![](/application/cocos/base/158.gif)


## 4.15 VideoPlayer 视频组件

1. 界面中的视频组件

    ![](/application/cocos/base/159.png)

2. VideoPlayer 属性

    | Resource Type        | 视频来源的类型，目前支持本地（LOCAL）视频和远程（REMOTE）视频 URL       |
    |----------------------|------------------------------------------------|
    | Remote URL           | 当 Resource Type 为 REMOTE 时显示的字段，填入远程视频的 URL    |
    | Clip                 | 当 Resource Type 为 LOCAL 时显示的字段，拖拽本地视频的资源到此处来使用 |
    | Play On Awake        | 视频加载后是否自动开始播放？                                 |
    | Current Time         | 指定从哪个时间点开始播放视频                                 |
    | Volume               | 视频的音量（0.0 ~ 1.0）                               |
    | Mute                 | 是否静音视频。静音时设置音量为 0，取消静音时恢复原来的音量                 |
    | Keep Aspect Ratio    | 是否保持视频原来的宽高比                                   |
    | Full Screen On Awake | 是否全屏播放视频                                       |
    | Stay On Bottom       | 永远在游戏视图最底层（该属性仅在 Web 平台生效）                     |
    | Video Player Event   | 视频播放回调函数，该回调函数会在特定情况被触发，比如播放中，暂时，停止和完成播放。      |

3. 设置脚本运行

    - 脚本

        ```ts
        import { _decorator, Component, VideoPlayer  } from 'cc';
        const { ccclass, property } = _decorator;

        @ccclass('Test')
        export class Test extends Component {
            start() {
                let videoPlayer  = this.node.getComponent(VideoPlayer);
                videoPlayer.play()
            }
        
        }
        ```
    - 运行结果

        ![](/application/cocos/base/160.gif)

## 4.16 WebView 网页视图

1. 界面中的视频组件

    ![](/application/cocos/base/161.png)

2. WebView 属性

    | 属性             | 功能说明                                                     |
    |----------------|----------------------------------------------------------|
    | Url            | 指定一个 URL 地址，这个地址以 http 或者 https 开头，请填写一个有效的 URL 地址。      |
    | WebView Events | WebView 的回调事件，当 webview 在加载网页过程中，加载网页结束后或者加载网页出错时会调用此函数。 |

3. 运行结果

    ![](/application/cocos/base/162.png)

## 4.17 对话框练习

1. 资源加载与页面布局
    
    - 基础布局
    
        ![](/application/cocos/base/163.png)
    - 对话框中content节点 

        ![](/application/cocos/base/164.png)

2. 脚本相关

    - 脚本设置
    
        ![](/application/cocos/base/165.png)

    - PaojieControl.ts

        ```ts
        import { _decorator, Component, resources,Sprite,SpriteFrame } from 'cc';
        const { ccclass, property } = _decorator;

        @ccclass('PaojieControl')
        export class PaojieControl extends Component {

            // 设置表情
            setImage(face:string,mouth:string){
                // 加载素材
                resources.load(face + "/spriteFrame", SpriteFrame, (err, sp) => {
                this.node.children[0].getComponent(Sprite).spriteFrame = sp;
                });
                resources.load(mouth+"/spriteFrame",SpriteFrame,(err,sp)=>{
                    this.node.children[1].getComponent(Sprite).spriteFrame = sp;
                })
            }
        }
        ```

    - MsgControl.ts

        ```ts
        import { _decorator, Component, Label } from 'cc';
        const { ccclass, property } = _decorator;

        @ccclass('MsgControl')
        export class MsgControl extends Component {

            // 刷新消息
            setMessage(name:string,content:string){
                this.node.children[0].getComponent(Label).string = name;
                this.node.children[1].getComponent(Label).string = content;
            }
        }
        ```
    - BgControl.ts

        ```ts
        import { _decorator, Component, Label, Input } from 'cc';
        import { PaojieControl } from './PaojieControl';
        import { MsgControl } from './MsgControl';
        const { ccclass, property } = _decorator;

        // 新建消息类
        class Message{
            name:string;
            content:string;
            face:string;
            mouth:string;

            constructor(name: string,content: string,face: string,mouth: string){
                this.name = name;
                this.content = content;
                this.face = face;
                this.mouth = mouth;
            }
        }



        @ccclass('BgControl')
        export class BgControl extends Component {
            // 人物和消息的控制器
            @property({type:PaojieControl})
            paojieControl: PaojieControl = null;
            @property(MsgControl)
            msgControl: MsgControl = null;


            // 消息数组
            msgs: Message[] = null;

            // 当前是第几条消息
            index: number = 0;

            start() {

                // 初始化数组
                this.msgs = [
                    new Message("御坂美琴","今天天气不错！","paojieface_02","paojiemouth_02"),
                    new Message("御坂美琴","来喝点饮料","paojieface_01","paojiemouth_01"),
                    new Message("御坂美琴","可以贩卖机又坏了","paojieface_02","paojiemouth_02")

                ]

                // 鼠标点击对话
                this.node.on(Input.EventType.TOUCH_START,()=>{
                    
                    if(this.index < this.msgs.length){
                        // 如果对话面板没显示，显示
                        if(this.msgControl.node.active == false){
                            this.msgControl.node.active = true;
                        }
                        // 读消息
                        let message =  this.msgs[this.index++];
                        // 显示消息
                        this.paojieControl.setImage(message.face,message.mouth);
                        this.msgControl.setMessage(message.name,message.content);

                    }
                })
            }

            update(deltaTime: number) {
                
            }

            // 刷新消息
            setMessage(name:string,content:string){
                this.node.children[0].getComponent(Label).string = name;
                this.node.children[1].getComponent(Label).string = content;
            }
        }
        ```
3. 运行结果

    ![](/application/cocos/base/166.gif)