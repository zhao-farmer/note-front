# 五、express

## 5.1 Express介绍与安装

### 5.1.1 什么是 Express？

Express 是一个基于 Node.js 的轻量级、灵活的 web 应用框架。它提供了一组强大的功能，帮助开发者快速构建 Web 应用和 API。Express 的设计理念是提供一组最小的核心功能，同时通过中间件和路由机制，使得开发者可以根据需要扩展其功能。自 2010 年由 TJ Holowaychuk 创建以来，Express 已经成为最流行的 Node.js 框架之一，广泛应用于各种规模的应用开发。


### 5.1.2 Express 的特点

1. 轻量级：
    - 核心功能精简：Express 的核心功能非常精简，只提供最基本的功能，如路由、中间件、模板引擎等。
    - 高性能：由于核心功能的精简，Express 的性能非常高，适合处理高并发请求。
2. 灵活性：
    - 中间件机制：Express 使用中间件来处理请求和响应，中间件可以是函数、路由处理程序或其他中间件。这种机制使得开发者可以轻松地添加和组合不同的功能。
    - 可扩展性：Express 本身并不强制使用特定的数据库、模板引擎或其他工具，开发者可以根据项目需求自由选择合适的工具和库。
3. 路由系统：
    - 简洁的路由定义：Express 提供了简洁的路由定义语法，使得开发者可以轻松地定义和管理路由。
    - RESTful API 支持：Express 非常适合构建 RESTful API，提供了丰富的 HTTP 方法和路径参数支持。
4. 模板引擎：
    - 多种模板引擎支持：Express 支持多种模板引擎，如 EJS、Pug、Handlebars 等，开发者可以根据项目需求选择合适的模板引擎。
    - 视图渲染：Express 提供了方便的视图渲染功能，可以将数据传递给模板引擎，生成 HTML 页面。
5. 错误处理：
    - 内置错误处理：Express 提供了内置的错误处理机制，可以捕获和处理未捕获的异常。
    - 自定义错误处理：开发者可以定义自己的错误处理中间件，处理特定类型的错误。
6. 社区支持：
    - 丰富的资源：Express 拥有庞大的开发者社区，提供了大量的文档、教程、插件和第三方库。
    - 活跃的生态系统：Express 生态系统非常活跃，不断有新的工具和库涌现，帮助开发者解决各种问题。


### 5.1.3 Express 的作用
1. 快速开发 Web 应用
    - 简化开发流程：Express 提供了丰富的功能和工具，使得开发者可以快速搭建和开发 Web 应用。
    - 减少重复工作：通过使用 Express 的路由、中间件和模板引擎，开发者可以避免重复编写常见的功能代码，专注于业务逻辑的实现。
2. 构建 RESTful API
    - 支持多种 HTTP 方法：Express 提供了对 GET、POST、PUT、DELETE 等 HTTP 方法的支持，非常适合构建 RESTful API。
    - 路径参数和查询参数：Express 支持路径参数和查询参数，使得开发者可以轻松地处理复杂的 URL 路径和查询条件。
3. 处理静态文件
    - 静态文件服务器：Express 内置了静态文件服务器功能，可以轻松地服务于静态文件，如 HTML、CSS、JavaScript 等。
    - 缓存控制：通过配置中间件，可以实现静态文件的缓存控制，提高性能。
4. 中间件机制
    - 请求处理：中间件可以处理请求，执行预处理任务，如解析请求体、设置响应头、记录日志等。
    - 响应处理：中间件可以处理响应，执行后处理任务，如压缩响应体、设置响应状态码等。
5. 错误处理
    - 全局错误处理：Express 提供了全局错误处理中间件，可以捕获和处理未捕获的异常，确保应用的稳定性。
    - 自定义错误页面：开发者可以定义自定义的错误页面，提供更好的用户体验。
    
    


### 5.1.4 举例说明

**创建一个简单的 Express 应用**

假设我们要创建一个简单的 Express 应用，包含一个主页和一个 RESTful API 接口。以下是实现步骤：

1. 安装 Express： 使用 npm 安装 Express。

```sh
npm install express
```

2. 创建应用文件： 创建一个名为 app.js 的文件，编写基本的 Express 应用代码。

```js
const express = require('express');
const app = express();
const port = 3000;
    
// 主页路由
app.get('/', (req, res) => {
    res.send('Hello, World!');
});
    
// RESTful API 接口
app.get('/api/users', (req, res) => {
    const users = [
        { id: 1, name: 'John Doe' },
        { id: 2, name: 'Jane Smith' }
    ];
    res.json(users);
});
    
// 启动服务器
app.listen(port, () => {
    console.log(`Server is running on http://localhost:${port}`);
});
```

3. 运行应用： 在终端中运行以下命令启动应用。

```sh
node app.js
```

4. 测试应用： 打开浏览器，访问 `http://localhost:3000`， 可以看到 "Hello, World!" 的欢迎消息。 使用 Postman 或浏览器访问 `http://localhost:3000/api/users`， 可以看到返回的用户列表 JSON 数据。



### 5.1.5 运行原理

底层：http模块

1. Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下

```js
var http = require("http");

var app = http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.end("Hello world!");
});
app.listen(3000, "localhost");
```

2. Express框架的核心是对http模块的再包装。上面的代码用Express改写如下

```js
var express = require('express');

var app = express();
app.get('/', function (req, res) {
  res.send('Hello world!');
});
app.listen(3000);
```


## 5.2 基本路由

路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。

路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, ·  `[callback...]`, callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。

下面是一个基本的路由示例：

```js
var express = require('express');
var app = express();

// respond with "hello world" when a GET request is made to the homepage
app.get('/', function(req, res) {
  res.send('hello world');
});
```


### 5.2.1 请求路径
路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。

1. 普通字符串

```js
// 匹配根路径的请求
app.get("/", function (req, res) {
    res.send("root");
});

// 匹配 /about 路径的请求
app.get("/about", function (req, res) {
    res.send("about");
});

// 匹配 /random.text 路径的请求
app.get("/random.text", function (req, res) {
    res.send("random.text");
});
```


2. 使用字符串模式的路由路径示例：

```js
// 匹配 acd 和 abcd
app.get("/ab?cd", function (req, res) {
    res.send("ab?cd");
});

// 匹配 /ab/******
app.get("/ab/:id", function (req, res) {
    res.send("aaaaaaa");
});

// 匹配 abcd、abbcd、abbbcd等
app.get("/ab+cd", function (req, res) {
    res.send("ab+cd");
});

// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get("/ab*cd", function (req, res) {
    res.send("ab*cd");
});

// 匹配 /abe 和 /abcde
app.get("/ab(cd)?e", function (req, res) {
    res.send("ab(cd)?e");
});
```


3. 使用正则表达式的路由路径示例：


```js
// 匹配任何路径中含有 a 的路径：
app.get(/a/, function (req, res) {
    res.send("/a/");
});

// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function (req, res) {
    res.send("/.*fly$/");
});
```


### 5.2.2 请求参数

可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next('route') 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。

```js
app.get('/example/a', function (req, res) {
    res.send('Hello from A!');
});

```

1. 使用多个回调函数处理路由（记得指定 next 对象）：

```js
app.get("/example/b",function (req, res, next) {
    console.log("response will be sent by the next function ...");
    next();
},function (req, res) {
    res.send("Hello from B!");
});
```

2. 使用回调函数数组处理路由：

```js
var cb0 = function (req, res, next) {
    console.log("CB0");
    next();
};

var cb1 = function (req, res, next) {
    console.log("CB1");
    next();
};

var cb2 = function (req, res) {
    res.send("Hello from C!");
};

app.get("/example/c", [cb0, cb1, cb2]);
```


3. 混合使用函数和函数数组处理路由：

```js
var cb0 = function (req, res, next) {
    console.log("CB0");
    next();
};

var cb1 = function (req, res, next) {
    console.log("CB1");
    next();
};

app.get("/example/d",[cb0, cb1],function (req, res, next) {
    console.log("response will be sent by the next function ...");
    next();
}, function (req, res) {
    res.send("Hello from D!");
});
```


## 5.3 Express 方法

### 5.3.1 Express路由简介

路由表示应用程序端点 (URI) 的定义以及响应客户端请求的方式。它包含一个请求方时（methods）、路径（path）和路由匹配时的函数（callback）;

```js
app.methods(path, callback);
```

### 5.3.2 Express路由方法

Express方法源于 HTTP 方法之一，附加到 express 类的实例。它可请求的方法包括：

get、post、put、head、delete、options、trace、copy、lock、mkcol、move、purge、propfind、proppatch、unlock、report、mkactivity、checkout、merge、m-search、notify、subscribe、unsubscribe、patch、search 和 connect。


路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。

>路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback...], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。

下面是一个基本的路由示例：

```js
var express = require('express');

var app = express();
// respond with "hello world" when a GET request is made to the homepage
app.get('/', function(req, res) {
  //写完一个send，后面所有跟路由有关的都不会执行
  //会自动响应对应的数据类型
  //   res.send([1, 2, 3]);
  //   res.send({ ok: 1 });
  //   res.json({ ok: 1 });
   // 使用混合使用函数数组处理时如果前面有res.send();那么后面和路由处理相关代码都不生效
  res.send('hello world');
  res.send(`
        <html>
            <h1>hello world</h2>
        </html>
    `);
});
```

路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。

### 5.3.3 all方法和HTTP动词方法

针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写

```js
var express = require("express");
var http = require("http");
var app = express();

app.all("*", function(request, response, next) {
  response.writeHead(200, { "Content-Type": "text/plain" });
  next();
});

app.get("/", function(request, response) {
  response.end("Welcome to the homepage!");
});

app.get("/about", function(request, response) {
  response.end("Welcome to the about page!");
});

app.get("*", function(request, response) {
  response.end("404!");
});

http.createServer(app).listen(1337);
```

- 上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了
- 除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法
- 这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配

```js
app.get("/hello/:who", function (req, res) {
    res.end("Hello, " + req.params.who + ".");
});
```


## 5.4 中间件

Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。

中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。

- 中间件的功能包括：
    - 执行任何代码。
    - 修改请求和响应对象。
    - 终结请求-响应循环。
    - 调用堆栈中的下一个中间件。

    如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。

- Express 应用可使用如下几种中间件：
    - 应用级中间件
    - 路由级中间件
    - 错误处理中间件
    - 内置中间件
    - 第三方中间件

    使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。


>注意: app.use 应用中间件必须在路由前方

### 5.4.1 应用级中间件
应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：

```js
var app = express()

// 没有挂载路径的中间件，应用的每个请求都会执行该中间件
app.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})

具体应用
const func1 = (req,res,next) =>{
    // 验证用户token过期，cookie过期
    console.log('验证token');
    
    const isValid = true
    if(isValid){
        res.kerwin = '这是func1计算的结果'
        next()
    }else{
        // 返回结果
        res.send('error')
    }
}
// 全局设置应用中间件
app.use(func1)
// 可以加参数限制
app.use('home',func1)
```

### 5.4.2 路由级中间件

路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。

```js
var router = express.Router()

var app = express()
var router = express.Router()

// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件
router.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})

// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息
router.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}, function (req, res, next) {
  console.log('Request Type:', req.method)
  next()
})

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
router.get('/user/:id', function (req, res, next) {
  // 如果 user id 为 0, 跳到下一个路由
  if (req.params.id == 0) next('route')
  // 负责将控制权交给栈中下一个中间件
  else next() //
}, function (req, res, next) {
  // 渲染常规页面
  res.render('regular')
})

// 处理 /user/:id， 渲染一个特殊页面
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id)
  res.render('special')
})

// 将路由挂载至应用
app.use('/', router)
```


路由组件挂载可以多种方式

```js
// 默认放的路径下
app.use("/",IndexRouter)
// 也可以加路径参数
app.use("/api",IndexRouter)

// 直接写上对应的路由类型
app.use("/home",HomeRouter)
app.use("/login",LoginRouter)

```



### 5.4.3 错误处理中间件
错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。

```js
app.use(function (err, req, res, next) {
    console.error(err.stack);
    res.status(500).send("Something broke!");
});
```

### 5.4.4 内置的中间件

express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。每个应用可有多个静态目录。

```js
app.use(express.static('public'))
app.use(express.static('uploads'))
app.use(express.static('files'))
```

### 5.4.5 第三方中间件

安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。
下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser

```sh
npm install cookie-parser
```

```js
var express = require('express')
var app = express()
var cookieParser = require('cookie-parser')

// 加载用于解析 cookie 的中间件
app.use(cookieParser())
```

## 5.5 获取请求参数

### 5.5.1 req.query

req.query()可以用来获取接口请求中拼接在链接"?"后边的参数，主要用于get请求，post请求也适用。 req.query()被express原生支持，并且会自动将参数转换为对象形式返回。
 
- 请求： `http://localhost:5050/server?p=user&q=password`

- express接口:

    ```js
    let express = require('express')
    let server = express()

    server.get('/server',(req,resp)=>{
        console.log(req.query);
        resp.send('')
    })

    server.listen(5050,()=>{
        console.log('服务器已就绪')
    })
    ```

- 请求后得到的结果：

    ![](/backend/senior/express/001.png)

### 5.5.2 req.params
req.params()有些特殊，它适用于在url链接上传递数据参数，需要后台接口用==:变量名==的写法发起请求。


- 请求：

    `http://localhost:5050/nums/1000`

- express接口:

    ```js
    let express = require('express')
    let server = express();
    server.get('/nums/:num', (req, resp) => {
    console.log(req.params);
    resp.send('')
    })
    server.listen(5050, () =>{
        console.log('服务器已就绪')
    })
    ```

- 请求后得到的结果：

    ![](/backend/senior/express/002.png)


3 req.body

req.body()被原生express所支持,可以直接使用req.body()获取post请求的表单数据。

- 请求:
    ```js
    fecth('http://localhost:5050/people',{
        method: 'post',
        headers: {
            'Content-Type': 'application/json'
        },
        body:{name: 'zhangsan', age: 15}
    })
    ```
- express接口：

    ```js
    const express = require('express');
    const server = express();

    //配置解析post参数的-不用下载第三方 ,内置
    //解析post参数-(url-ky格式) username=kerwin&password=1234
    // app.use(express.urlencoded({ extended: false }));
    //解析post参数-(json字符串) {name:"",age:100}
    app.use(express.json());
    server.post('/people', (req, resp) => {
    console.log(req.body);
    resp.send('')
    })
    server.listen(5050, () => console.log('服务器已就绪'))
    ```

- 请求后得到的结果：

        ![](/backend/senior/express/001.png)


### 5.5.3 response对象

| 方法               | 描述                          |
|------------------|-----------------------------|
| res.download()   | 提示要下载的文件。                   |
| res.end（）        | 结束响应过程。                     |
| res.json（）       | 发送JSON响应。                   |
| res.jsonp（）      | 发送带有JSONP支持的JSON响应。         |
| res.redirect（）   | 重定向请求。                      |
| res.render（）     | 渲染视图模板。                     |
| res.send（）       | 发送各种类型的响应。                  |
| res.sendFile（）   | 将文件作为八位字节流发送。               |
| res.sendStatus（） | 设置响应状态代码，并将其字符串表示形式发送为响应正文。 |



1. response.redirect方法
    ```js
    response.redirect("/hello/anime");
    response.redirect("http://www.example.com");
    response.redirect(301, "http://www.example.com"); 
    ```
2. response.sendFile方法
    
    response.sendFile方法用于发送文件
    
    ```js
    response.sendFile("/path/to/anime.mp4");
    ```

3. response.render方法

    response.render方法用于渲染网页模板。

    ```js
    //  使用render方法，将message变量传入index模板，渲染成HTML网页
    app.get("/", function(request, response) {
        response.render("index", { message: "Hello World" });
    });
    ```


## 5.6 静态资源

通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。
将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了。例如，假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以：

```js
//直接将public里的index.html当成/的网页
app.use(express.static('public'))
```


现在，public 目录下面的文件就可以访问了。

```
http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html
```

所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。
如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：

```js
app.use(express.static('public'))
app.use(express.static('files'))
```

访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。
如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：

```js
app.use('/static', express.static('public'))
```

现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。

```
http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html
```

静态资源种使用其他静态资源

```js
app.use(express.static('public'))
// 直接进行调用
<link rel="stylesheet" href="/css/index.css" />
    
app.use('/static', express.static('public'))
// 虚拟目录进行调用
<link rel="stylesheet" href="/static/css/index.css" />
```


## 5.7 Express服务端渲染（模板引擎）

在Web开发中，模板引擎是一个不可或缺的工具，它允许开发者将HTML模板与JavaScript代码分离，使得页面的渲染更加灵活和高效。Express作为Node.js的流行Web框架，支持多种模板引擎，其中EJS（Embedded JavaScript templating）因其简洁和易用性而广受欢迎。本文将深入解析Express中EJS模板引擎的原理，并通过代码示例展示如何使用EJS来渲染页面。

### 5.7.1 EJS模板引擎的基本原理

EJS是一种简单的模板语言，它允许开发者将JavaScript代码嵌入到HTML模板中。当Express应用接收到一个请求并需要渲染一个页面时，它会查找对应的EJS模板文件，执行其中的JavaScript代码，并将结果插入到HTML中，最终生成完整的HTML页面发送给客户端。

EJS模板使用特殊的标签来标记需要插入JavaScript代码的位置。例如，<% %>用于执行其中的JavaScript代码，<%= %>用于输出表达式的结果到模板中，而<%- %>则用于输出HTML转义的内容。

### 5.7.2 在Express中使用EJS

要在Express应用中使用EJS模板引擎，首先需要安装EJS并通过app.set()方法将其设置为应用的模板引擎。然后，可以通过res.render()方法来渲染EJS模板并发送响应给客户端。

1. 安装EJS

在Express项目中，通过npm安装EJS模板引擎：

```js
npm install ejs
```

2. 设置EJS为模板引擎

在Express应用中，使用app.set()方法将EJS设置为模板引擎：

```js
const express = require('express');
const ejs=require("ejs");
const app = express();

//引用ejs
app.set('views',"./views");  //设置视图的对应目录
app.set("view engine","ejs");       //设置默认的模板引擎
```

3. 创建EJS模板

在项目的views目录下创建一个EJS模板文件，例如index.ejs：

```html
<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
</head>
<body>
    <h1><%= message %></h1>
</body>
</html>
```


4. 渲染EJS模板

在路由处理函数中，使用res.render()方法来渲染EJS模板并发送响应：

```js
app.get('/', (req, res) => {
    res.render('index', { title: 'Express EJS', message: 'Hello, EJS!' });
});
```

当访问根路由时，Express会渲染index.ejs模板，并将title和message变量的值插入到模板中，最终生成完整的HTML页面发送给客户端。


### 5.7.3 EJS的高级用法

EJS不仅支持基本的变量替换和条件判断，还支持循环、包含其他模板、自定义函数等高级功能。这些功能使得EJS在处理复杂页面时更加灵活和强大。


1. 基础类型

app.js文件：

```js
const express=require("express");
const ejs=require("ejs");
const fs=require("fs");
var app=express();

//引用ejs
app.set('views',"./views");  //设置视图的对应目录
app.set("view engine","ejs");       //设置默认的模板引擎

app.get("/",function(req,res){
    res.render("index",{title: "<h4>express</h4>"});
    //会去找views目录下的index.ejs文件
});
app.listen(8080);
```

ejs文件：

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
    </head>
    <body>
        <% for(var i=0;i<10;i++){ %>
            <%= i %>
        <% } %>
        <!-- 获取变量 -->
        <div class="datas">
            <p>获取变量：</p>
            <%- title %>
            <%= title %>
        </div>
    </body>
</html>
```

由此可以知道：
- `<%xxx %>`：里面写入的是js语法，
- `<%=xxx %>`：里面是服务端发送给ejs模板转义后的变量，输出为原数据
- `<%-xxx %>`：里面也是服务端发送给ejs模板后的变量，解析html


如果写html的注释，那样会在源码中显示，下面这种ejs注释不会在源码中显示

```html
<%# 注释标签，不执行、不输出内容 %>
```

同理res.render()函数也是支持回调的：

```js
res.render('user', { name: 'Tobi' }, function(err, html) {
    console.log(html);
});
```

这样我们即可将看到html的内容。
 
2. 关于res.redirect()

```js
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.render('login', {
    isShow: false,
    error: '',
  });
});

router.post('/', (req, res) => {
  if (req.body.username === 'ds' && req.body.password === '123') {
    console.log('登录成功');
    // res.send("成功")
    // 重定向到home
    res.redirect('/index');
  } else {
    console.log('登录失败');
    res.render('login', { error: '用户名密码不匹配', isShow: true });
  }
});

module.exports = router;
```

3. ejs 标签各种含义

    - `<%`:'脚本'标签，用于流程控制，无输出。
    - `<%_`: 删除其前面的空格符
    - `<%=`: 输出数据到模板（输出是转义 HTML标签）
    - `<%-`: 输出非转义的数据到模板
    - `<%#`: 注释标签，不执行、不输出内容
    - `<%%`: 输出字符串 `<%`
    - `%>`: 一般结束标签
    - `-%>`: 删除紧随其后的换行符
    - `_%>`: 将结束标签后面的空格符删除


    - `<% %>`: 流程控制标签( 写的是if else，for)
    - `<%=%>`: 输出标签(原文输出HTML标签)
    - `<%- %>`: 输出标签(HTML会被浏览器解析)
    - `<%# %>`: 注释标签
    - `<%- include('user/show',{user: user})%>` 导入公共的模板内容

4. 导入公共模板样式

header.ejs

```js
<header>
    我是公共样式
    <div>
      <% if(isShowSchool) {%>
      <h1>校园招聘</h1>
      <% } %>
    </div>
</header>
```

index.ejs

```html
<%- include("./header.ejs",{ isShowSchool:true }) %> index <%# 我的注释 %>
```


## 5.8 Express脚手架

使用express-generator安装

使用命令行进入项目目录，依次执行：

```sh
npm i -g express-generator
```

可通过express -h查看命令行的指令含义

```sh
express -h
```

```
Options:
    --version        输出版本号
-e, --ejs            添加对 ejs 模板引擎的支持
    --pug            添加对 pug 模板引擎的支持
    --hbs            添加对 handlebars 模板引擎的支持
-H, --hogan          添加对 hogan.js 模板引擎的支持
-v, --view <engine>  添加对视图引擎（view） <engine> 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎）
    --no-view        创建不带视图引擎的项目
-c, --css <engine>   添加样式表引擎 <engine> 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件）
    --git            添加 .gitignore
-f, --force          强制在非空目录下创建
-h, --help           输出使用方法
```

创建了一个名为 myapp 的 Express 应用，并使用ejs模板引擎

```sh
express --view=ejs myapp
```

进入app，并安装依赖

```sh
# 进入目录
cd myapp
# 安装插件
npm install
```
查看启动命令：

![](/backend/senior/express/004.png)

命令为： `npm start`

![](/backend/senior/express/005.png)


