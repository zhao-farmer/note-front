# 十、Mocha单元测试


## 10.1 单元测试

1. 介绍

    - 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
    - 比如对函数abs()，我们可以编写出以下几个测试用例：
        - 输入正数，比如1、1.2、0.99，期待返回值与输入相同；
        - 输入负数，比如-1、-1.2、-0.99，期待返回值与输入相反；
        - 输入0，期待返回0；
        - 输入非数值类型，比如null、[]、{}，期待抛出Error。
        
        >把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。
    - 如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。
    - 单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。
    - 这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。

2. 测试框架

    mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。

    使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。

2. mocha的特点主要有：

    - 既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一；
    - 可以自动运行所有测试，也可以只运行特定的测试；
    - 可以支持before、after、beforeEach和afterEach来编写初始化代码。


## 10.2 编写测试

1. 准备工作

    - 安装插件

        ```sh
        npm init
        npm install mocha
        ```
    - 修改scripts命令 package.json

        ```json
        "scripts": {
            "test": "mocha"
        },
        ```

2. 被测试文件 sum.js

    ```js
    module.exports = function(...rest){
        var sum = 0;
        for (let i of rest) {
            sum+=i
        }
        return sum;
    }
    ```

3. 编写测试文件 test/test1.js

    ```js
    var sum = require("../sum")
    // 引入断言
    var assert = require("assert")

    // 内置的断言如果不相同 不会报错
    // assert.strictEqual(sum(),0)
    // assert.strictEqual(sum(1),1)
    // assert.strictEqual(sum(1,2),3)
    // assert.strictEqual(sum(1,2,3),6)
    // console.log(sum(1,2,3));

    // describe 一组测试，嵌套
    // it 一个测试

    describe("大的组1的测试",()=>{
        describe("小的组1测试",()=>{
            it("sum() 结果应该返回0",()=>{
                assert.strictEqual(sum(),0)
            })
            it("sum(1) 结果应该返回1",()=>{
                assert.strictEqual(sum(1),1)
            })
        })
        describe("小的组2测试",()=>{
            it("sum(1,2) 结果应该返回3",()=>{
                assert.strictEqual(sum(1,2),3)
            })
            it("sum(1,2,3)) 结果应该返回6",()=>{
                assert.strictEqual(sum(1,2,3),6)
            })
        })
    })

    describe("大的组1的测试",()=>{

    })
    ```

    >注意：mocha寻找根目录下的test.js 或 test文件夹

4. 运行结果

    ![](/backend/node/base/050.png)

## 10.3 chai断言库

1. 断言

    mocha允许你使用任意你喜欢的断言库，在上面的例子中，我们使用了Node.is的内置的断言模块作为断言。如果能够抛出一个错误，它就能够运行。这意味着你能使用下面的这些仓库，比如:

    - `should.js`-BDD风格贯穿始终
    - `expect.js`-expect()样式断声
    - `chai`-expect()、assert()和should风格的断言
    - `better-assert`-C风格的自文档化的assert()
    - `unexpected`-可扩展的BDD断言工具

2. 安装chai 断言库

    ```sh
    npm install chai
    ```
3. 使用 chai断言库

    - assest 类型

        ```js
        var chai = require('chai')
        var assert = chai.assert;

        describe('assert Demo', function () {
            it('use assert lib', function () {
                var value = "hello";
                assert.typeOf(value, 'string')
                assert.equal(value, 'hello')
                assert.lengthOf(value, 5)
            })
        })
        ```
    - should() 类型
        ```js
        var chai = require('chai');
        chai.should();

        describe('should Demo', function(){
            it('use should lib', function () {
                var value = 'hello'
                // 像一句话一样
                value.should.exist.and.equal('hello').and.have.length(5).and.be.a('string')
                // value.should.be.a('string')
                // value.should.equal('hello')
                // value.should.not.equal('hello2')
                // value.should.have.length(5);
            })
        });
        ```
    - expect 类型

        ```js
        var chai = require('chai');
        var expect = chai.expect;

        describe('expect Demo', function() {
            it('use expect lib', function () {
                var value = 'hello'
                var number = 3

                // 期望小于5
                expect(number).to.be.at.most(5)
                // 期望大于3
                expect(number).to.be.at.least(3)
                // 期望在1-4之间
                expect(number).to.be.within(1, 4)

                // 期望存在
                expect(value).to.exist
                expect(value).to.be.a('string')
                expect(value).to.equal('hello')
                expect(value).to.not.equal('您好')
                expect(value).to.have.length(5)
            })
        });
        ```


## 10.4 异步测试

1. 新建文件 hello.txt

    内容：hello

2. 测试文件

    ```js
    var assert = require("assert")
    const fs = require("fs")
    const fsp = fs.promises

    describe("异步测试1",()=>{
        it("异步1-读取文件",(done)=>{
            fs.readFile("./1.txt","utf8",(err,data)=>{
                if(err){
                    // 等待，调用完才是结束
                    done(err)
                }else{
                    assert.strictEqual(data,"hello")
                    done()
                }
            })
        })
    })

    describe("异步测试2",()=>{
        it("异步2-读取文件", async ()=>{
            var data = await fsp.readFile("./1.txt","utf8")
            assert.strictEqual(data,"hello")
        })
    })
    ```

## 10.5 http测试


### 10.5.1 启动后台测试

1. 安装插件

    ```sh
    npm install koa
    npm install axios
    ```
2. 启动类 app.js

    ```js
    const Koa = require("koa")
    const app = new Koa()

    app.use((ctx)=>{
        ctx.body = "<h1>hello</h1>"
    })

    app.listen(3000)
    ```
3. 测试文件

    ```js
    const  axios  = require("axios")
    const assert = require("assert")
    describe("测试接口",()=>{
        it("返回html代码片段测试", async ()=>{
            // axios axios.get

            var res = await axios.get("http://localhost:3000/")
            assert.strictEqual(res.data,"<h1>hello</h1>")
        })
    })
    ```

### 10.5.2 不启动后台测试

1. 安装插件

    ```sh
    npm install koa
    npm install supertest
    ```
2. 启动类 app.js

    ```js
    const Koa = require("koa")
    const app = new Koa()

    app.use((ctx)=>{
        ctx.body = "<h1>hello</h1>"
    })

    // 导出对象
    module.exports = app
    ```
3. 测试文件

    ```js
    var supertest = require("supertest")
    var app = require("../app")

    describe("测试接口2",()=>{
        // 启动端口
        let server =  app.listen(3000)

        it("返回html代码片段测试", async ()=>{
            await supertest(server).get("/")
            .expect("Content-Type",/text\/html/)
            .expect(200,"<h1>hello</h1>")
        })

        // 所有执行完毕 自动调用
        after(()=>{
            server.close()
        })
    })
    ```

## 10.6 钩子函数

```js
var supertest = require("supertest")
var assert = require("assert")
var app = require("../app")


describe("测试接口2",()=>{
    let server 

    it("返回html代码片段测试", async ()=>{
        await supertest(server).get("/")
        .expect("Content-Type",/text\/html/)
        .expect(200,"<h1>hello</h1>")
    })

    // 所有it执行前 调用
    before(()=>{
        server =  app.listen(3000)
    })

    // 所有it执行完毕 调用
    after(()=>{
        server.close()
    })
})


function sum(...rest){
    var sum = 0;
    for (let i of rest) {
        sum+=i
    }
    return sum;
}

describe("大的组1的测试",()=>{

     // 所有it执行前 调用
    before(function () {
        console.log('before:');
    });
    // 所有it执行后 调用
    after(function () {
        console.log('after.');
    });
    // 每个it执行后 调用
    beforeEach(function () {
        console.log('  beforeEach:');
    });
     // 每个it执行前 调用
    afterEach(function () {
        console.log('  afterEach.');
    });

    describe("小的组1测试",()=>{
        it("sum() 结果应该返回0",()=>{
            assert.strictEqual(sum(),0)
        })
        it("sum(1) 结果应该返回1",()=>{
            assert.strictEqual(sum(1),1)
        })
    })
    describe("小的组2测试",()=>{
        it("sum(1,2) 结果应该返回3",()=>{
            assert.strictEqual(sum(1,2),3)
        })
           it("sum(1,2,3)) 结果应该返回6",()=>{
            assert.strictEqual(sum(1,2,3),6)
        })
    })
})
````
