# 二、核心组件

HTTP调用图解

```
HTTP 请求
   ↓
路由(Router) → 匹配URL和方法
   ↓
中间件(Middleware) → 执行预处理
   ↓
控制器(Controller) → 协调请求和响应
   ↓
服务(Service) → 执行业务逻辑和数据访问
   ↓
返回响应
```

## 2.1 路由（Router）

### 2.1.1 基础认识

路由是请求的入口，负责将 HTTP 请求映射到对应的控制器(Controller)上。

1. 特点
    - URL 映射：定义 URL 路径与控制器方法的对应关系
    - HTTP 方法：支持 GET、POST、PUT、DELETE 等 HTTP 方法
    - 参数传递：支持路径参数、查询参数等
2. 工作流程
    - 接收 HTTP 请求
    - 根据 URL 和方法匹配路由规则
    - 执行路由对应的中间件(如果有)
    - 调用对应的控制器方法

3. 基础使用

    ```js
    // app/router.js
    module.exports = app => {
        const { router, controller } = app;
        
        // 基本路由
        router.get('/posts', controller.posts.index);
        
        // RESTful 资源路由
        router.resources('users', '/api/users', controller.users);
        
        // 带参数路由
        router.get('/user/:id', controller.user.show);
    };
    ```

使用示例

### 2.1.2 基础路由配置

```javascript
// app/router.js
module.exports = app => {
    const { router, controller } = app;
    
    // 基本GET路由
    router.get('/', controller.home.index);
    
    // 带参数的路由
    router.get('/user/:id', controller.user.show);
    
    // POST路由
    router.post('/user', controller.user.create);
    
    // PUT路由
    router.put('/user/:id', controller.user.update);
    
    // DELETE路由
    router.delete('/user/:id', controller.user.destroy);
    
    // 重定向路由
    router.redirect('/home', '/', 302);
};
```

### 2.1.3 RESTful 风格路由

```javascript
// app/router.js
module.exports = app => {
    const { router, controller } = app;
    
    // RESTful 资源路由
    router.resources('posts', '/api/posts', controller.posts);
    /*
        等同于:
        GET    /api/posts        - controller.posts.index
        GET    /api/posts/:id    - controller.posts.show
        POST   /api/posts        - controller.posts.create
        PUT    /api/posts/:id    - controller.posts.update
        DELETE /api/posts/:id    - controller.posts.destroy
    */
    
    // 自定义resources动作
    router.resources('users', '/api/v1/users', {
        middleware: ['auth'], // 中间件
        only: ['index', 'show', 'create'], // 只生成特定路由
    }, controller.users);
};
```

### 2.1.4 路由分组与模块化

- 总路由

    ```js
    // app/router.js
    module.exports = app => {
        require('./router/user')(app);
        require('./router/article')(app);
        require('./router/admin')(app);
    };
    ```
- 模块路由1

    ```js
    // app/router/user.js
    module.exports = app => {
        const { router, controller, middleware } = app;
        
        // 用户相关路由分组
        router.group('/user', user => {
            user.post('/register', controller.user.register);
            user.post('/login', controller.user.login);
            user.get('/info', middleware.auth(), controller.user.info);
            user.put('/password', middleware.auth(), controller.user.changePassword);
        });
    };
    ```
- 模块路由1

    ```js
    // app/router/article.js
    module.exports = app => {
        const { router, controller, middleware } = app;
        
        // 文章相关路由
        router.resources('articles', '/api/articles', middleware.auth(), controller.article);
        
        // 自定义动作
        router.post('/api/articles/:id/like', middleware.auth(), controller.article.like);
        router.get('/api/articles/tag/:tag', controller.article.findByTag);
    };
    ```

### 2.1.5 中间件在路由中的使用

```js
// app/router.js
module.exports = app => {
    const { router, controller, middleware } = app;
    
    // 全局中间件已在config中配置
    
    // 路由级别中间件
    router.get(
        '/api/protected', 
        middleware.auth(), // 认证中间件
        middleware.rateLimit(), // 限流中间件
        controller.user.protected
    );
    
    // 多个中间件
    router.post(
        '/api/upload',
        middleware.auth(),
        middleware.multipart(), // 文件上传中间件
        controller.upload.upload
    );
    
    // 忽略中间件的路由
    router.get('/api/public', middleware.auth({ ignore: true }), controller.public.index);
};
```

### 2.1.6 参数验证与路由约束

```javascript
    // app/router.js
    module.exports = app => {
    const { router, controller } = app;
    
    // 带参数约束的路由
    router.get('/user/:id(\\d+)', controller.user.show); // 只匹配数字ID
    
    // 多段路由
    router.get('/posts/:year/:month/:day', controller.posts.archive);
    
    // 可选参数
    router.get('/search/:keyword?', controller.search.index);
    
    // 正则约束
    router.get('/files/:name([^/]+\\.[^/]+)', controller.files.show);
};
```

### 2.1.7 多域名与子域名路由
```javascript
// app/router.js
module.exports = app => {
    const { router, controller } = app;
    
    // 主域名路由
    router.get('/', controller.home.index);
    
    // API子域名
    router.group('api', '/api', api => {
        api.get('/users', controller.api.user.list);
        api.post('/users', controller.api.user.create);
    });
    
    // 管理后台子域名
    router.group('admin', '/admin', admin => {
        admin.get('/', controller.admin.home);
        admin.resources('users', '/users', controller.admin.user);
    });
    
    // 多域名配置
    router.host('mobile.example.com').get('/', controller.mobile.index);
    router.host('www.example.com').get('/', controller.web.index);
};
```

### 2.1.8 文件上传与下载路由

```javascript
// app/router.js
module.exports = app => {
    const { router, controller, middleware } = app;
    
    // 文件上传
    router.post('/upload', 
        middleware.multipart(), // 启用文件上传
        controller.upload.upload
    );
    
    // 多文件上传
    router.post('/upload/multiple', 
        middleware.multipart({ multiples: true }),
        controller.upload.multiple
    );
    
    // 文件下载
    router.get('/download/:filename', controller.download.index);
    
    // 文件流
    router.get('/stream/:filename', controller.download.stream);
};
```

### 2.1.9 WebSocket 路由

```javascript
// app/router.js
module.exports = app => {
    const { router, controller } = app;
    
    // WebSocket路由
    router.ws('/ws', controller.ws.index);
    router.ws('/ws/chat', controller.ws.chat);
    
    // 命名空间
    router.ws.namespace('/api/v1').ws('/notify', controller.ws.notify);
};
```

### 2.1.10 重定向与别名路由

```javascript
// app/router.js
module.exports = app => {
    const { router, controller } = app;
    
    // 简单重定向
    router.redirect('/old', '/new', 301);
    
    // 带参数重定向
    router.redirect('/post/:id', '/articles/:id', 302);
    
    // 路由别名
    router.alias('/users/list', '/api/v1/users');
    
    // 条件重定向
    router.redirect('/legacy', ctx => {
        return ctx.query.version === '1' ? '/v1' : '/v2';
    });
};
```

### 2.1.11 复杂业务路由示例
   
```javascript
// app/router.js
module.exports = app => {
    const { router, controller, middleware } = app;
    
    // API版本控制
    router.group('/api', api => {
        api.group('/v1', v1 => {
            v1.resources('products', '/products', controller.api.v1.product);
        });
        
        api.group('/v2', v2 => {
            v2.resources('products', '/products', middleware.apiVersion('v2'), controller.api.v2.product);
        });
    });
    
    // 后台管理系统路由
    router.group('/admin', admin => {
        admin.get('/login', controller.admin.auth.login);
        admin.post('/login', controller.admin.auth.doLogin);
        
        // 需要管理员权限的路由组
        admin.group('', middleware.adminAuth(), authAdmin => {
            authAdmin.get('/', controller.admin.home.index);
            authAdmin.resources('users', '/users', controller.admin.user);
            authAdmin.resources('roles', '/roles', controller.admin.role);
        });
    });
    
    // 微信小程序接口
    router.group('/weapp', weapp => {
        weapp.post('/login', controller.weapp.login);
        weapp.post('/decrypt', middleware.weappAuth(), controller.weapp.decryptData);
    });
    
    // 图形验证码
    router.get('/captcha', controller.util.captcha);
    
    // 健康检查
    router.get('/health', controller.util.healthCheck);
};
```


## 2.2 中间件（Middleware）

### 2.2.1 基础

中间件是在路由和控制器之间执行的函数，可以访问请求对象(ctx)和响应对象，用于处理横切关注点。

1. 特点
    - 洋葱圈模型：类似 Koa 的中间件机制，支持 async/await
    - 可配置：可以全局使用或针对特定路由使用
    - 链式调用：多个中间件按顺序执行

2. 简单使用

    ```js
    // app/middleware/auth.js
    module.exports = options => {
        return async function auth(ctx, next) {
            // 获取token
            const token = ctx.headers.authorization;
            if (!token) {
                ctx.throw(401, '未提供认证令牌');
            }
            await next();
        };
    };
    ```

    ```js
    // 配置中使用
    // config/config.default.js
    exports.middleware = ['auth'];

    // 不适用于login
    exports.auth = {
        ignore: ['/login']
    };
    ```

    
3. 注意点

    - 中间件顺序
        1. 在 config.default.js 中 middleware 数组的顺序就是执行顺序
        2. 全局中间件 (onfig.default.js) 比路由中间件先触发
    - 中间件要求
        1. 避免在中间件中进行耗时操作
        2. 确保中间件有良好的错误处理机制
    

### 2.2.2 错误处理中间件

```js
// app/middleware/error_handler.js
module.exports = () => {
    return async function errorHandler(ctx, next) {
        try {
            await next();
        } catch (err) {
            // 记录错误日志
            ctx.app.emit('error', err, ctx);
            
            // 根据错误类型返回不同的响应
            const status = err.status || 500;
            const error = status === 500 && ctx.app.config.env === 'prod'
                ? 'Internal Server Error'
                : err.message;
            
            ctx.status = status;
            ctx.body = { 
                success: false,
                message: error,
                stack: ctx.app.config.env === 'local' ? err.stack : undefined
            };
        }
    };
};
```
### 2.2.3 请求日志中间件
```js
// app/middleware/request_logger.js
module.exports = () => {
    return async function requestLogger(ctx, next) {
        const start = Date.now();
        await next();
        const duration = Date.now() - start;
        
        ctx.app.logger.info(
        `[${ctx.method}] ${ctx.url} - ${ctx.status} - ${duration}ms - ${ctx.ip}`
        );
    };
};
```
### 2.2.4 API响应格式化中间件
```js
// app/middleware/response_formatter.js
module.exports = () => {
    return async function responseFormatter(ctx, next) {
        await next();
        
        // 如果已经有body则不再处理
        if (ctx.body === undefined || ctx.status === 302) return;
        
        // 格式化响应
        ctx.body = {
            success: ctx.status === 200,
            message: ctx.body.message || 'success',
            data: ctx.body.data || ctx.body
        };
    };
};
```
### 2.2.5 权限验证中间件
```js
// app/middleware/auth.js
module.exports = (options) => {
    return async function authMiddleware(ctx, next) {
        // 1. 从配置中获取忽略验证的路径
        const ignorePaths = options.ignore || [];
        if (ignorePaths.some(path => ctx.path.startsWith(path))) {
            await next();
            return;
        }
        
        // 2. 获取token
        const token = ctx.get('authorization') || ctx.query.token;
        
        if (!token) {
            ctx.throw(401, '未提供认证令牌');
        }
        
        try {
            // 3. 验证token
            const decoded = ctx.app.jwt.verify(token, ctx.app.config.jwt.secret);
            ctx.state.user = decoded; // 将用户信息挂载到ctx上
            await next();
        } catch (err) {
            ctx.throw(401, '无效的认证令牌');
        }
    };
};
```

### 2.2.6 请求频率限制中间件

```js
// app/middleware/rate_limit.js
module.exports = (options) => {
    const { max = 100, windowMs = 60 * 1000 } = options;
    
    return async function rateLimit(ctx, next) {
        const key = `rate_limit:${ctx.ip}`;
        const current = await ctx.app.redis.get(key) || 0;
        
        if (current >= max) {
            ctx.throw(429, '请求过于频繁，请稍后再试');
        }
        
        // 计数器+1
        await ctx.app.redis.multi()
        .incr(key)
        .expire(key, windowMs / 1000)
        .exec();
        
        // 设置响应头
        ctx.set('X-RateLimit-Limit', max);
        ctx.set('X-RateLimit-Remaining', max - current - 1);
        ctx.set('X-RateLimit-Reset', Math.floor(Date.now() / 1000) + (windowMs / 1000));
        
        await next();
    };
};
```
### 2.2.7 跨域中间件

```js
// app/middleware/cors.js
module.exports = (options) => {
    const { allowOrigins = [], allowMethods = 'GET,HEAD,PUT,POST,DELETE,PATCH' } = options;
    
    return async function corsMiddleware(ctx, next) {
        const origin = ctx.get('origin');
        
        // 设置允许的源
        if (allowOrigins.includes(origin)) {
            ctx.set('Access-Control-Allow-Origin', origin);
            ctx.set('Access-Control-Allow-Credentials', 'true');
        }
        
        // 处理预检请求
        if (ctx.method === 'OPTIONS') {
            ctx.set('Access-Control-Allow-Methods', allowMethods);
            ctx.set('Access-Control-Allow-Headers', ctx.get('access-control-request-headers'));
            ctx.set('Access-Control-Max-Age', '86400');
            ctx.status = 204;
            return;
        }
        
        await next();
    };
};
```

### 2.2.8 配置与使用

1. 在配置文件中启用中间件：

    ```js
    // config/config.default.js
    module.exports = {
        middleware: ['errorHandler', 'requestLogger', 'responseFormatter', 'cors'],
        
        // 中间件配置
        cors: {
            allowOrigins: ['https://yourdomain.com']
        },
        
        rateLimit: {
            max: 100,
            windowMs: 60 * 1000
        },
        
        auth: {
            ignore: ['/api/login', '/api/register']
        }
    };

2. 路由中使用中间件

        ```js
    // app/router.js
    module.exports = app => {
        const { router, controller, middleware } = app;
        
        // 全局中间件已在config中配置
        
        // 特定路由使用额外中间件
        router.get(
            '/api/protected', 
            middleware.auth(), 
            middleware.rateLimit(), 
            controller.user.protected
        );
    };
    ```



## 2.3 控制器（Controller）

### 2.3.1 基础

控制器负责处理业务逻辑，是路由和服务的桥梁。

1. 特点

    - 业务入口：接收请求参数，调用服务处理，返回响应
    - 瘦控制器：建议保持简洁，复杂逻辑放在 Service
    - 约定优于配置：文件必须放在 app/controller 目录

2. 职责
    - 参数校验
    - 调用服务处理业务
    - 处理异常
    - 返回响应
3. 简单示例

    ```js
    // app/controller/user.js
    const Controller = require('egg').Controller;

    class UserController extends Controller {
        async show() {
            const { ctx } = this;
            const user = await ctx.service.user.find(ctx.params.id);
            if (!user) {
                ctx.status = 404;
                return;
            }
            ctx.body = user;
        }
        
        async create() {
            const { ctx } = this;
            try {
                ctx.validate({
                    username: 'string',
                    password: 'string',
                });
                const user = await ctx.service.user.create(ctx.request.body);
                ctx.body = user;
                ctx.status = 201;
            } catch (e) {
                ctx.status = 422;
                ctx.body = { error: e.message };
            }
        }
    }
    ```

4. 最佳实践

   - **保持控制器简洁**：将复杂逻辑放到 Service 层
   - **统一响应格式**：使用基类控制器统一成功/失败响应
   - **参数验证**：使用 Egg.js 内置的 validate 方法
   - **错误处理**：合理捕获和处理错误
   - **权限控制**：敏感操作需要验证用户权限
   - **日志记录**：重要操作记录日志
   - **代码复用**：提取公共逻辑到基类或 Helper

### 2.3.2 基础控制器结构

```javascript
// app/controller/base.js
const Controller = require('egg').Controller;

class BaseController extends Controller {
    // 成功响应
    success(data, message = 'success') {
        this.ctx.body = {
            success: true,
            message,
            data,
        };
    }

    // 失败响应
    fail(message = 'error', code = 400) {
        this.ctx.status = code;
        this.ctx.body = {
            success: false,
            message,
        };
    }

    // 分页响应
    pagination(list, total, page, pageSize) {
        this.ctx.body = {
            success: true,
            data: {
                list,
                total,
                page,
                pageSize,
                totalPage: Math.ceil(total / pageSize),
            },
        };
    }
}

module.exports = BaseController;
```

### 2.3.3 用户控制器示例


```javascript
// app/controller/user.js
const BaseController = require('./base');

class UserController extends BaseController {
    // 用户注册
    async register() {
        const { ctx } = this;
        const { username, password } = ctx.request.body;
        
        try {
            // 参数验证
            ctx.validate({
                username: { type: 'string', required: true },
                password: { type: 'string', required: true, min: 6 },
            });
            
            // 检查用户名是否存在
            if (await ctx.service.user.findByUsername(username)) {
                return this.fail('用户名已存在');
            }
            
            // 创建用户
            const user = await ctx.service.user.create({
                username,
                password: ctx.helper.md5(password),
            });
            
            this.success(user, '注册成功');
        } catch (e) {
            if (e.errors) {
                return this.fail(e.errors.map(err => err.field + ' ' + err.message).join(','));
            }
            this.fail(e.message);
        }
    }

    // 用户登录
    async login() {
        const { ctx, app } = this;
        const { username, password } = ctx.request.body;
        
        try {
        ctx.validate({
            username: 'string',
            password: 'string',
        });
        
        const user = await ctx.service.user.findByUsername(username);
        if (!user || user.password !== ctx.helper.md5(password)) {
            return this.fail('用户名或密码错误');
        }
        
        // 生成 token
        const token = app.jwt.sign({
            userId: user.id,
            username: user.username,
        }, app.config.jwt.secret, { expiresIn: '1d' });
        
        // 设置 cookie
        ctx.cookies.set('token', token, {
            httpOnly: true,
            maxAge: 24 * 60 * 60 * 1000,
            signed: true,
        });
        
        this.success({ token }, '登录成功');
        } catch (e) {
        this.fail(e.message);
        }
    }

    // 获取当前用户信息
    async current() {
        const { ctx } = this;
        const userId = ctx.state.user.userId;
        
        try {
            const user = await ctx.service.user.findById(userId);
            if (!user) {
                return this.fail('用户不存在');
            }
            
            // 过滤敏感信息
            const { password, ...userInfo } = user.toJSON();
            this.success(userInfo);
        } catch (e) {
            this.fail(e.message);
        }
    }
}

module.exports = UserController;
```

### 2.3.4 文章控制器示例


```javascript
// app/controller/article.js
const BaseController = require('./base');

class ArticleController extends BaseController {
    // 创建文章
    async create() {
        const { ctx } = this;
        const { title, content } = ctx.request.body;
        const userId = ctx.state.user.userId;
        
        try {
            ctx.validate({
                title: { type: 'string', required: true, max: 100 },
                content: { type: 'string', required: true },
            });
            
            const article = await ctx.service.article.create({
                title,
                content,
                user_id: userId,
            });
            
            this.success(article, '创建成功');
        } catch (e) {
            this.fail(e.message);
        }
    }

    // 获取文章列表
    async list() {
        const { ctx } = this;
        const { page = 1, pageSize = 10 } = ctx.query;
        
        try {
            const { list, total } = await ctx.service.article.list({
                page: parseInt(page),
                pageSize: parseInt(pageSize),
            });
            
            this.pagination(list, total, page, pageSize);
        } catch (e) {
            this.fail(e.message);
        }
    }

    // 获取文章详情
    async detail() {
        const { ctx } = this;
        const { id } = ctx.params;
        
        try {
            const article = await ctx.service.article.findById(id);
            if (!article) {
                return this.fail('文章不存在');
            }
            
            // 增加阅读量
            await ctx.service.article.incrementViewCount(id);
            
            this.success(article);
        } catch (e) {
            this.fail(e.message);
        }
    }

    // 更新文章
    async update() {
        const { ctx } = this;
        const { id } = ctx.params;
        const { title, content } = ctx.request.body;
        const userId = ctx.state.user.userId;
        
        try {
            ctx.validate({
                title: { type: 'string', required: false, max: 100 },
                content: { type: 'string', required: false },
            });
            
            // 检查文章是否存在且属于当前用户
            const article = await ctx.service.article.checkOwner(id, userId);
            if (!article) {
                return this.fail('无权操作此文章');
            }
            
            const updated = await ctx.service.article.update(id, {
                title,
                content,
            });
            
            this.success(updated, '更新成功');
        } catch (e) {
            this.fail(e.message);
        }
    }

    // 删除文章
    async delete() {
        const { ctx } = this;
        const { id } = ctx.params;
        const userId = ctx.state.user.userId;
        
        try {
            // 检查文章是否存在且属于当前用户
            const article = await ctx.service.article.checkOwner(id, userId);
            if (!article) {
                return this.fail('无权操作此文章');
            }
            
            await ctx.service.article.delete(id);
            this.success(null, '删除成功');
        } catch (e) {
            this.fail(e.message);
        }
    }
}

module.exports = ArticleController;
```

### 2.3.5 文件上传控制器


```javascript
// app/controller/upload.js
const BaseController = require('./base');
const fs = require('fs');
const path = require('path');

class UploadController extends BaseController {
    // 单文件上传
    async upload() {
        const { ctx } = this;
        const file = ctx.request.files[0];
        
        try {
            if (!file) {
                return this.fail('请选择文件');
            }
            
            // 读取文件
            const fileContent = fs.readFileSync(file.filepath);
            // 生成新文件名
            const filename = Date.now() + path.extname(file.filename);
            // 文件保存路径
            const targetPath = path.join(this.config.baseDir, 'app/public/uploads', filename);
            
            // 写入文件
            fs.writeFileSync(targetPath, fileContent);
            
            // 删除临时文件
            await ctx.cleanupRequestFiles();
            
            this.success({
                url: `/public/uploads/${filename}`,
            }, '上传成功');
        } catch (e) {
            // 确保临时文件被清理
            await ctx.cleanupRequestFiles();
            this.fail(e.message);
        }
    }

    // 多文件上传
    async multiUpload() {
        const { ctx } = this;
        const files = ctx.request.files;
        
        try {
            if (!files || files.length === 0) {
                return this.fail('请选择文件');
            }
            
            const result = [];
            for (const file of files) {
                const fileContent = fs.readFileSync(file.filepath);
                const filename = Date.now() + Math.random().toString(36).substring(2, 8) + path.extname(file.filename);
                const targetPath = path.join(this.config.baseDir, 'app/public/uploads', filename);
                
                fs.writeFileSync(targetPath, fileContent);
                result.push({
                    name: file.filename,
                    url: `/public/uploads/${filename}`,
                });
            }
            
            await ctx.cleanupRequestFiles();
            this.success(result, '上传成功');
        } catch (e) {
            await ctx.cleanupRequestFiles();
            this.fail(e.message);
        }
    }
}

module.exports = UploadController;
```

### 2.3.6 微信小程序控制器示例


```javascript
// app/controller/weapp.js
const BaseController = require('./base');
const axios = require('axios');

class WeappController extends BaseController {
    // 微信小程序登录
    async login() {
        const { ctx, app } = this;
        const { code } = ctx.request.body;
        
        try {
            ctx.validate({
                code: { type: 'string', required: true },
            });
            
            // 调用微信接口获取openid
            const { appid, secret } = app.config.weapp;
            const result = await axios.get('https://api.weixin.qq.com/sns/jscode2session', {
                params: {
                    appid,
                    secret,
                    js_code: code,
                    grant_type: 'authorization_code',
                },
            });
            
            const { openid, session_key, errcode, errmsg } = result.data;
            if (errcode) {
                return this.fail(errmsg);
            }
            
            // 查找或创建用户
            let user = await ctx.service.user.findByOpenid(openid);
            if (!user) {
                user = await ctx.service.user.create({
                openid,
                source: 'weapp',
                });
            }
            
            // 生成token
            const token = app.jwt.sign({
                userId: user.id,
                openid,
            }, app.config.jwt.secret, { expiresIn: '30d' });
            
            this.success({ token }, '登录成功');
        } catch (e) {
            this.fail(e.message);
        }
    }

    // 获取微信手机号
    async getPhoneNumber() {
        const { ctx, app } = this;
        const { encryptedData, iv } = ctx.request.body;
        const sessionKey = ctx.state.user.sessionKey;
        
        try {
            ctx.validate({
                encryptedData: 'string',
                iv: 'string',
            });
            
            // 解密数据
            const { phoneNumber } = app.weapp.decryptData(encryptedData, iv, sessionKey);
            
            // 更新用户手机号
            await ctx.service.user.update(ctx.state.user.userId, {
                phone: phoneNumber,
            });
            
            this.success({ phoneNumber }, '获取成功');
        } catch (e) {
            this.fail(e.message);
        }
    }
}

module.exports = WeappController;
```

### 2.3.7 路由配置示例


```javascript
// app/router.js
module.exports = app => {
    const { router, controller, middleware } = app;
    
    // 用户相关路由
    router.post('/api/user/register', controller.user.register);
    router.post('/api/user/login', controller.user.login);
    router.get('/api/user/current', middleware.auth(), controller.user.current);
    
    // 文章相关路由
    router.resources('article', '/api/article', middleware.auth(), controller.article);
    
    // 文件上传
    router.post('/api/upload', middleware.auth(), controller.upload.upload);
    router.post('/api/upload/multi', middleware.auth(), controller.upload.multiUpload);
    
    // 微信小程序
    router.post('/api/weapp/login', controller.weapp.login);
    router.post('/api/weapp/phone', middleware.auth(), controller.weapp.getPhoneNumber);
};
```

## 2.4 服务（Service）

### 2.4.1 基础

服务是业务逻辑的具体实现，供控制器调用。

1. 特点

    - 复用性：可被多个控制器调用
    - 独立性：不依赖请求上下文，便于测试
    - 领域驱动：按业务领域组织代码

2. 常见职责
    - 数据库操作
    - 第三方 API 调用
    - 复杂业务逻辑
    - 数据加工处理

3. 简单使用

    ```js
    // app/service/user.js
    const Service = require('egg').Service;

    class UserService extends Service {
        async find(id) {
            return await this.ctx.model.User.findByPk(id);
        }
        
        async create(userData) {
            const user = await this.ctx.model.User.create(userData);
            await this.sendWelcomeEmail(user);
            return user;
        }
        
        async sendWelcomeEmail(user) {
            // 发送邮件逻辑
        }
    }
    ```


### 2.4.2 基础服务结构

首先创建一个基础服务类，封装常用方法：

```javascript
// app/service/base.js
const Service = require('egg').Service;

class BaseService extends Service {
    // 分页查询封装
    async paginate(model, where = {}, options = {}) {
        const { page = 1, pageSize = 10, order = [['id', 'DESC']], ...query } = options;
        const offset = (page - 1) * pageSize;
        
        const result = await model.findAndCountAll({
            where,
            ...query,
            offset,
            limit: parseInt(pageSize),
            order,
        });
        
        return {
            list: result.rows,
            total: result.count,
            page: parseInt(page),
            pageSize: parseInt(pageSize),
            totalPages: Math.ceil(result.count / pageSize),
        };
    }

    // 检查资源是否存在
    async checkExist(model, where, message = '资源不存在') {
        const item = await model.findOne({ where });
        if (!item) {
            this.ctx.throw(404, message);
        }
        return item;
    }

    // 检查资源所有权
    async checkOwner(model, id, userId, message = '无权操作此资源') {
        const item = await model.findOne({ 
            where: { 
                id,
                user_id: userId 
            } 
        });
        if (!item) {
            this.ctx.throw(403, message);
        }
        return item;
    }
}

module.exports = BaseService;
```

### 2.4.3 用户服务示例


```javascript
// app/service/user.js
const BaseService = require('./base');
const bcrypt = require('bcryptjs');

class UserService extends BaseService {
    // 根据ID查找用户
    async findById(id) {
        const { ctx } = this;
        return await ctx.model.User.findByPk(id, {
            attributes: { exclude: ['password', 'deleted_at'] },
        });
    }

    // 根据用户名查找用户
    async findByUsername(username) {
        return await this.ctx.model.User.findOne({ 
            where: { username } 
        });
    }

    // 根据openid查找用户
    async findByOpenid(openid) {
        return await this.ctx.model.User.findOne({ 
            where: { openid } 
        });
    }

    // 创建用户
    async create(userData) {
        const { ctx } = this;
        const transaction = await ctx.model.transaction();
        
        try {
            // 密码加密
            if (userData.password) {
                userData.password = bcrypt.hashSync(userData.password, 10);
            }

            const user = await ctx.model.User.create(userData, { transaction });
            
            // 创建用户资料
            await ctx.model.UserProfile.create({
                user_id: user.id,
            }, { transaction });

            await transaction.commit();
            return user;
        } catch (err) {
            await transaction.rollback();
            ctx.throw(500, '创建用户失败');
        }
    }

    // 更新用户信息
    async update(id, userData) {
        const { ctx } = this;
        
        // 过滤不允许更新的字段
        const { password, ...updateData } = userData;
        
        // 如果需要更新密码
        if (password) {
            updateData.password = bcrypt.hashSync(password, 10);
        }

        const [ affectedCount ] = await ctx.model.User.update(updateData, {
            where: { id },
        });

        if (affectedCount === 0) {
            ctx.throw(404, '用户不存在');
        }

        return await this.findById(id);
    }

    // 验证用户密码
    async verifyPassword(user, password) {
        return bcrypt.compareSync(password, user.password);
    }
}

module.exports = UserService;
```

### 2.4.4 文章服务示例

```javascript
// app/service/article.js
const BaseService = require('./base');

class ArticleService extends BaseService {
    // 创建文章
    async create(articleData) {
        const { ctx } = this;
        const transaction = await ctx.model.transaction();
        
        try {
            const article = await ctx.model.Article.create(articleData, { transaction });
            
            // 处理标签
            if (articleData.tags && articleData.tags.length > 0) {
                await this._processTags(article.id, articleData.tags, transaction);
            }

            await transaction.commit();
            return article;
        } catch (err) {
            await transaction.rollback();
            ctx.throw(500, '创建文章失败');
        }
    }

    // 获取文章列表
    async list(options = {}) {
        const { ctx } = this;
        const { tag, keyword, ...query } = options;
        const where = {};
        
        // 标签筛选
        if (tag) {
            where.id = {
                [ctx.model.Op.in]: ctx.model.literal(
                    `(SELECT article_id FROM article_tags WHERE tag_id = ${tag})`
                ),
            };
        }
        
        // 关键词搜索
        if (keyword) {
            where[ctx.model.Op.or] = [
                { title: { [ctx.model.Op.like]: `%${keyword}%` } },
                { content: { [ctx.model.Op.like]: `%${keyword}%` } },
            ];
        }

        return await this.paginate(ctx.model.Article, where, {
            ...query,
            include: [
                {
                    model: ctx.model.User,
                    as: 'author',
                    attributes: ['id', 'username', 'avatar'],
                },
                {
                    model: ctx.model.Tag,
                    as: 'tags',
                    through: { attributes: [] },
                },
            ],
        });
    }

    // 获取文章详情
    async findById(id) {
        const { ctx } = this;
        const article = await ctx.model.Article.findByPk(id, {
            include: [
                {
                    model: ctx.model.User,
                    as: 'author',
                    attributes: ['id', 'username', 'avatar'],
                },
                {
                    model: ctx.model.Tag,
                    as: 'tags',
                    through: { attributes: [] },
                },
                {
                    model: ctx.model.Comment,
                    as: 'comments',
                    limit: 10,
                    order: [['created_at', 'DESC']],
                    include: [
                        {
                            model: ctx.model.User,
                            as: 'user',
                            attributes: ['id', 'username', 'avatar'],
                        },
                    ],
                },
            ],
        });

        if (!article) {
            ctx.throw(404, '文章不存在');
        }

        return article;
    }

    // 更新文章
    async update(id, articleData) {
        const { ctx } = this;
        const transaction = await ctx.model.transaction();
        
        try {
            const [ affectedCount ] = await ctx.model.Article.update(articleData, {
                where: { id },
                transaction,
            });

            if (affectedCount === 0) {
                ctx.throw(404, '文章不存在');
            }

            // 处理标签
            if (articleData.tags) {
                await ctx.model.ArticleTag.destroy({ 
                    where: { article_id: id },
                    transaction,
                });
                
                await this._processTags(id, articleData.tags, transaction);
            }

            await transaction.commit();
            return await this.findById(id);
        } catch (err) {
            await transaction.rollback();
            ctx.throw(500, '更新文章失败');
        }
    }

    // 删除文章
    async delete(id) {
        const { ctx } = this;
        const affectedCount = await ctx.model.Article.destroy({
            where: { id },
        });

        if (affectedCount === 0) {
            ctx.throw(404, '文章不存在');
        }
    }

    // 增加文章阅读量
    async incrementViewCount(id) {
        await this.ctx.model.Article.increment('view_count', {
            where: { id },
        });
    }

    // 处理文章标签
    async _processTags(articleId, tags, transaction) {
        const { ctx } = this;
        
        // 查找或创建标签
        const tagInstances = await Promise.all(
            tags.map(async tagName => {
                const [tag] = await ctx.model.Tag.findOrCreate({
                    where: { name: tagName },
                    transaction,
                });
                return tag;
            })
        );

        // 关联文章和标签
        await ctx.model.ArticleTag.bulkCreate(
            tagInstances.map(tag => ({
                article_id: articleId,
                tag_id: tag.id,
            })),
            { transaction }
        );
    }
}

module.exports = ArticleService;
```

### 2.4.5 文件上传服务

```javascript
// app/service/upload.js
const BaseService = require('./base');
const path = require('path');
const fs = require('fs');
const pump = require('mz-modules/pump');
const { v4: uuidv4 } = require('uuid');

class UploadService extends BaseService {
    // 上传文件
    async upload(stream, options = {}) {
        const { ctx } = this;
        const { allowedExtensions = [], maxSize = 1024 * 1024 * 5 } = options;
        
        // 验证文件扩展名
        const ext = path.extname(stream.filename).toLowerCase();
        if (allowedExtensions.length > 0 && !allowedExtensions.includes(ext)) {
            ctx.throw(400, `不支持的文件类型: ${ext}`);
        }
        
        // 验证文件大小
        if (stream.byteLimit && stream.byteLimit > maxSize) {
            ctx.throw(400, `文件大小不能超过 ${maxSize / 1024 / 1024}MB`);
        }

        // 生成唯一文件名
        const filename = `${uuidv4()}${ext}`;
        const relativePath = `uploads/${this.ctx.helper.day().format('YYYY/MM/DD')}`;
        const targetDir = path.join(this.config.baseDir, 'app/public', relativePath);
        const targetPath = path.join(targetDir, filename);
        
        // 确保目录存在
        if (!fs.existsSync(targetDir)) {
            fs.mkdirSync(targetDir, { recursive: true });
        }
        
        // 写入文件
        const writeStream = fs.createWriteStream(targetPath);
        await pump(stream, writeStream);
        
        // 返回文件信息
        return {
            filename,
            originalname: stream.filename,
            mimetype: stream.mimeType,
            size: stream.byteLimit,
            path: `/${path.join(relativePath, filename)}`,
        };
    }

    // 生成文件访问URL
    generateUrl(filePath) {
        return `${this.config.domain}${filePath}`;
    }

    // 删除文件
    async delete(filePath) {
        const absolutePath = path.join(this.config.baseDir, 'app/public', filePath);
        
        if (fs.existsSync(absolutePath)) {
            fs.unlinkSync(absolutePath);
            return true;
        }
        
        return false;
    }
}

module.exports = UploadService;
```

### 2.4.6 微信小程序服务


```javascript
// app/service/weapp.js
const BaseService = require('./base');
const axios = require('axios');
const WXBizDataCrypt = require('../utils/WXBizDataCrypt');

class WeappService extends BaseService {
    // 获取微信openid
    async code2Session(code) {
        const { appid, secret } = this.config.weapp;
        
        try {
            const result = await axios.get('https://api.weixin.qq.com/sns/jscode2session', {
                params: {
                    appid,
                    secret,
                    js_code: code,
                    grant_type: 'authorization_code',
                },
            });

            const { openid, session_key, unionid, errcode, errmsg } = result.data;
            
            if (errcode) {
                this.ctx.throw(400, `微信接口错误: ${errmsg}`);
            }

            return { openid, sessionKey: session_key, unionid };
        } catch (err) {
            this.ctx.throw(500, '获取微信openid失败');
        }
    }

    // 解密用户数据
    async decryptData(encryptedData, iv, sessionKey) {
        const { appid } = this.config.weapp;
        const pc = new WXBizDataCrypt(appid, sessionKey);
        
        try {
            return pc.decryptData(encryptedData, iv);
        } catch (err) {
            this.ctx.throw(400, '解密用户数据失败');
        }
    }

    // 获取微信access_token
    async getAccessToken() {
        const { appid, secret } = this.config.weapp;
        const cacheKey = `weapp:access_token:${appid}`;
        
        // 从缓存获取
        let accessToken = await this.app.redis.get(cacheKey);
        if (accessToken) {
            return accessToken;
        }
        
        // 从微信接口获取
        try {
            const result = await axios.get('https://api.weixin.qq.com/cgi-bin/token', {
                params: {
                grant_type: 'client_credential',
                appid,
                secret,
                },
            });

            const { access_token, expires_in, errcode, errmsg } = result.data;
            
            if (errcode) {
                this.ctx.throw(400, `获取access_token失败: ${errmsg}`);
            }

            // 缓存access_token
            await this.app.redis.set(cacheKey, access_token, 'EX', expires_in - 60);
            
            return access_token;
        } catch (err) {
            this.ctx.throw(500, '获取access_token失败');
        }
    }

    // 发送模板消息
    async sendTemplateMessage(openid, templateId, data, page = null) {
        const accessToken = await this.getAccessToken();
        
        try {
            await axios.post(`https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=${accessToken}`, {
                touser: openid,
                template_id: templateId,
                page,
                data,
            });
            
            return true;
        } catch (err) {
            this.ctx.logger.error('发送模板消息失败:', err);
            return false;
        }
    }
}

module.exports = WeappService;
```

### 2.4.7 缓存服务示例


```javascript
// app/service/cache.js
const BaseService = require('./base');

class CacheService extends BaseService {
    // 设置缓存
    async set(key, value, ttl = 0) {
        if (ttl > 0) {
            await this.app.redis.set(key, JSON.stringify(value), 'EX', ttl);
        } else {
            await this.app.redis.set(key, JSON.stringify(value));
        }
    }

    // 获取缓存
    async get(key) {
        const value = await this.app.redis.get(key);
        return value ? JSON.parse(value) : null;
    }

    // 删除缓存
    async del(key) {
        await this.app.redis.del(key);
    }

    // 获取或设置缓存
    async remember(key, ttl, callback) {
        const cached = await this.get(key);
        if (cached !== null) {
            return cached;
        }
        
        const value = await callback();
        await this.set(key, value, ttl);
        return value;
    }

    // 递增
    async incr(key, amount = 1) {
        return await this.app.redis.incrby(key, amount);
    }

    // 递减
    async decr(key, amount = 1) {
        return await this.app.redis.decrby(key, amount);
    }
}

module.exports = CacheService;
```
## 2.5 模型（Model） 


下面我将展示如何在 Egg.js 中定义 Model 并连接 MySQL 数据库。我们将使用 Sequelize 作为 ORM 框架来操作 MySQL。

1. 安装必要的依赖

    ```bash
    npm install --save egg-sequelize mysql2
    ```

2. 配置 MySQL 连接

    在 `config/config.default.js` 中配置数据库：

    ```javascript
    // config/config.default.js
    module.exports = appInfo => {
        const config = {};

        // Sequelize 配置
        config.sequelize = {
            dialect: 'mysql',
            host: '127.0.0.1',
            port: 3306,
            database: 'egg_demo',
            username: 'root',
            password: 'yourpassword',
            timezone: '+08:00', // 东八区
            define: {
                timestamps: true, // 自动添加 createdAt 和 updatedAt
                paranoid: true,  // 添加 deletedAt
                underscored: true, // 使用下划线命名风格
                freezeTableName: true, // 禁止表名自动复数化
            },
            dialectOptions: {
                dateStrings: true,
                typeCast: true,
            },
        };

        return config;
    };
    ```

3. 启用 Sequelize 插件

    在 `config/plugin.js` 中启用插件：

    ```javascript
    // config/plugin.js
    exports.sequelize = {
        enable: true,
        package: 'egg-sequelize',
    };
    ```

4. 定义 Model 示例

    - 用户模型 (User)

        ```javascript
        // app/model/user.js
        module.exports = app => {
            const { STRING, INTEGER, DATE, BOOLEAN } = app.Sequelize;

            const User = app.model.define('user', {
                id: {
                    type: INTEGER,
                    primaryKey: true,
                    autoIncrement: true,
                },
                username: {
                    type: STRING(50),
                    unique: true,
                    allowNull: false,
                    comment: '用户名',
                },
                password: {
                    type: STRING(100),
                    allowNull: false,
                    comment: '密码',
                },
                email: {
                    type: STRING(100),
                    unique: true,
                    validate: {
                        isEmail: true,
                    },
                    comment: '邮箱',
                },
                phone: {
                    type: STRING(20),
                    unique: true,
                    comment: '手机号',
                },
                avatar: {
                    type: STRING(255),
                    comment: '头像URL',
                },
                status: {
                    type: BOOLEAN,
                    defaultValue: true,
                    comment: '状态: true-启用, false-禁用',
                },
                last_login_at: {
                    type: DATE,
                    comment: '最后登录时间',
                },
                created_at: DATE,
                updated_at: DATE,
                deleted_at: DATE,
            }, {
                // 自定义表名
                tableName: 'users',
                // 开启软删除
                paranoid: true,
                // 自定义时间戳字段名
                createdAt: 'created_at',
                updatedAt: 'updated_at',
                deletedAt: 'deleted_at',
            });

            // 定义关联关系
            User.associate = function() {
                // 一个用户有多篇文章
                app.model.User.hasMany(app.model.Article, {
                    foreignKey: 'user_id',
                    as: 'articles',
                });
                
                // 一个用户有一个资料
                app.model.User.hasOne(app.model.UserProfile, {
                    foreignKey: 'user_id',
                    as: 'profile',
                });
                
                // 用户和角色是多对多关系
                app.model.User.belongsToMany(app.model.Role, {
                    through: app.model.UserRole,
                    foreignKey: 'user_id',
                    otherKey: 'role_id',
                    as: 'roles',
                });
            };

            return User;
        };
        ```

    - 文章模型 (Article)

        ```javascript
        // app/model/article.js
        module.exports = app => {
            const { STRING, INTEGER, TEXT, DATE } = app.Sequelize;

            const Article = app.model.define('article', {
                id: {
                    type: INTEGER,
                    primaryKey: true,
                    autoIncrement: true,
                },
                title: {
                    type: STRING(100),
                    allowNull: false,
                    comment: '文章标题',
                },
                content: {
                    type: TEXT,
                    comment: '文章内容',
                },
                user_id: {
                    type: INTEGER,
                    allowNull: false,
                    comment: '作者ID',
                },
                view_count: {
                    type: INTEGER,
                    defaultValue: 0,
                    comment: '浏览数',
                },
                like_count: {
                    type: INTEGER,
                    defaultValue: 0,
                    comment: '点赞数',
                },
                status: {
                    type: INTEGER,
                    defaultValue: 1,
                    comment: '状态: 1-草稿, 2-已发布, 3-已下架',
                },
                created_at: DATE,
                updated_at: DATE,
                deleted_at: DATE,
            }, {
                tableName: 'articles',
                paranoid: true,
                createdAt: 'created_at',
                updatedAt: 'updated_at',
                deletedAt: 'deleted_at',
            });

            Article.associate = function() {
                // 文章属于一个用户
                app.model.Article.belongsTo(app.model.User, {
                    foreignKey: 'user_id',
                    as: 'author',
                });
                
                // 文章和标签是多对多关系
                app.model.Article.belongsToMany(app.model.Tag, {
                    through: app.model.ArticleTag,
                    foreignKey: 'article_id',
                    otherKey: 'tag_id',
                    as: 'tags',
                });
                
                // 文章有多条评论
                app.model.Article.hasMany(app.model.Comment, {
                    foreignKey: 'article_id',
                    as: 'comments',
                });
            };

            return Article;
        };
        ```

    - 标签模型 (Tag)


        ```javascript
        // app/model/tag.js
        module.exports = app => {
            const { STRING, INTEGER, DATE } = app.Sequelize;

            const Tag = app.model.define('tag', {
                id: {
                    type: INTEGER,
                    primaryKey: true,
                    autoIncrement: true,
                },
                name: {
                    type: STRING(50),
                    unique: true,
                    allowNull: false,
                    comment: '标签名称',
                },
                description: {
                    type: STRING(255),
                    comment: '标签描述',
                },
                created_at: DATE,
                updated_at: DATE,
            }, {
                tableName: 'tags',
                timestamps: true,
                createdAt: 'created_at',
                updatedAt: 'updated_at',
            });

            Tag.associate = function() {
                // 标签和文章是多对多关系
                app.model.Tag.belongsToMany(app.model.Article, {
                    through: app.model.ArticleTag,
                    foreignKey: 'tag_id',
                    otherKey: 'article_id',
                    as: 'articles',
                });
            };

            return Tag;
        };
        ```

    - 文章标签关联模型 (ArticleTag)

        ```javascript
            // app/model/article_tag.js
            module.exports = app => {
                const { INTEGER, DATE } = app.Sequelize;

                const ArticleTag = app.model.define('article_tag', {
                    id: {
                        type: INTEGER,
                        primaryKey: true,
                        autoIncrement: true,
                    },
                    article_id: {
                        type: INTEGER,
                        allowNull: false,
                        comment: '文章ID',
                    },
                    tag_id: {
                        type: INTEGER,
                        allowNull: false,
                        comment: '标签ID',
                    },
                    created_at: DATE,
                }, {
                    tableName: 'article_tags',
                    timestamps: true,
                    createdAt: 'created_at',
                    updatedAt: false,
                    indexes: [
                    {
                        unique: true,
                        fields: ['article_id', 'tag_id'],
                    },
                    ],
                });

                return ArticleTag;
            };
        ```

    - 用户资料模型 (UserProfile)

        ```javascript
        // app/model/user_profile.js
        module.exports = app => {
            const { STRING, INTEGER, DATE, TEXT } = app.Sequelize;

            const UserProfile = app.model.define('user_profile', {
                id: {
                    type: INTEGER,
                    primaryKey: true,
                    autoIncrement: true,
                },
                user_id: {
                    type: INTEGER,
                    unique: true,
                    allowNull: false,
                    comment: '用户ID',
                },
                nickname: {
                    type: STRING(50),
                    comment: '昵称',
                },
                gender: {
                    type: INTEGER,
                    defaultValue: 0,
                    comment: '性别: 0-未知, 1-男, 2-女',
                },
                birthday: {
                    type: DATE,
                    comment: '生日',
                },
                bio: {
                    type: TEXT,
                    comment: '个人简介',
                },
                website: {
                    type: STRING(255),
                    comment: '个人网站',
                },
                created_at: DATE,
                updated_at: DATE,
            }, {
                tableName: 'user_profiles',
                timestamps: true,
                createdAt: 'created_at',
                updatedAt: 'updated_at',
            });

            UserProfile.associate = function() {
                // 资料属于一个用户
                app.model.UserProfile.belongsTo(app.model.User, {
                    foreignKey: 'user_id',
                    as: 'user',
                });
            };

            return UserProfile;
        };
        ```

5. 数据库迁移（可选）

    1. 如果需要使用数据库迁移功能，可以安装 `sequelize-cli`：


        ```bash
        npm install --save-dev sequelize-cli
        ```

    2. 然后在项目根目录创建 `.sequelizerc` 文件：


        ```javascript
        // .sequelizerc
        const path = require('path');

        module.exports = {
            config: path.join(__dirname, 'config/sequelize.js'),
            'models-path': path.join(__dirname, 'app/model'),
            'seeders-path': path.join(__dirname, 'database/seeders'),
            'migrations-path': path.join(__dirname, 'database/migrations'),
        };
        ```

    3. 创建 `config/sequelize.js` 配置文件：


        ```javascript
        // config/sequelize.js
        const { username, password, database, host, port } = require('./config').sequelize;

        module.exports = {
            development: {
                username,
                password,
                database,
                host,
                port,
                dialect: 'mysql',
                timezone: '+08:00',
            },
            test: {
                username,
                password,
                database: `${database}_test`,
                host,
                port,
                dialect: 'mysql',
                timezone: '+08:00',
            },
            production: {
                username,
                password,
                database,
                host,
                port,
                dialect: 'mysql',
                timezone: '+08:00',
            },
        };
        ```

6. 在 Service 中使用 Model

    ```javascript
    // app/service/user.js
    const Service = require('egg').Service;

    class UserService extends Service {
        // 创建用户
        async create(userData) {
            const { ctx } = this;
            return await ctx.model.User.create(userData);
        }

        // 根据ID查找用户
        async findById(id) {
            const { ctx } = this;
            return await ctx.model.User.findByPk(id, {
                include: [
                    {
                        model: ctx.model.UserProfile,
                        as: 'profile',
                    },
                ],
            });
        }

        // 分页查询用户
        async paginate({ page = 1, pageSize = 10 }) {
            const { ctx } = this;
            return await ctx.model.User.findAndCountAll({
                offset: (page - 1) * pageSize,
                limit: pageSize,
                order: [[ 'created_at', 'DESC' ]],
                include: [
                    {
                        model: ctx.model.UserProfile,
                        as: 'profile',
                        attributes: ['nickname', 'gender'],
                    },
                ],
            });
        }
    }

    module.exports = UserService;
    ```

7. 模型使用最佳实践

    1.  **命名规范**：
        *   模型文件使用单数形式（如 `user.js`）
        *   数据库表名使用复数形式（如 `users`）
    2.  **关联关系**：
        *   一对一：`hasOne` 和 `belongsTo`
        *   一对多：`hasMany` 和 `belongsTo`
        *   多对多：`belongsToMany` 和 `belongsToMany`
    3.  **字段定义**：
        *   明确指定字段类型和长度
        *   添加适当的验证规则
        *   添加注释说明字段用途
    4.  **时间戳**：
        *   建议统一使用 `created_at`、`updated_at` 和 `deleted_at`
        *   启用 `paranoid` 模式实现软删除
    5.  **性能优化**：
        *   查询时指定需要的字段
        *   合理使用 `include` 进行关联查询
        *   添加适当的索引
 

## 2.6 定时任务（Schedule）

1. 基本配置

    首先需要在 `config/plugin.js` 中启用 schedule 插件：

    ```javascript
    // config/plugin.js
    exports.schedule = {
        enable: true,
        package: 'egg-schedule',
    };
    ```

2. 定时任务示例

    - 示例1：简单的定时任务

        ```javascript
        // app/schedule/update_cache.js
        module.exports = {
            // 定时任务配置
            schedule: {
                interval: '1h', // 1小时间隔
                type: 'all', // 指定所有的 worker 都需要执行
            },

            // 任务执行函数
            async task(ctx) {
                try {
                    // 更新缓存数据
                    const data = await ctx.service.data.getLatest();
                    await ctx.app.redis.set('latest_data', JSON.stringify(data));
                    ctx.logger.info('缓存更新成功');
                } catch (err) {
                    ctx.logger.error('缓存更新失败:', err);
                }
            },
        };
        ```

    - 示例2：使用 Cron 表达式

        ```javascript
        // app/schedule/clean_log.js
        module.exports = {
            schedule: {
                // 使用 cron 表达式，每天凌晨3点执行
                cron: '0 0 3 * * *',
                type: 'worker', // 只有一个 worker 会执行
            },

            async task(ctx) {
                try {
                    // 清理7天前的日志
                    const beforeDate = new Date();
                    beforeDate.setDate(beforeDate.getDate() - 7);
                    
                    const result = await ctx.model.Log.destroy({
                        where: {
                        created_at: {
                            [ctx.model.Op.lt]: beforeDate,
                        },
                        },
                    });
                    
                    ctx.logger.info(`清理了 ${result} 条旧日志`);
                } catch (err) {
                    ctx.logger.error('清理日志失败:', err);
                }
            },
        };
        ```

    - 示例3：动态禁用任务



        ```javascript
        // app/schedule/sync_data.js
        module.exports = {
            schedule: {
                interval: '30m',
                type: 'all',
                disable: app => {
                    // 只在生产环境启用
                    return app.config.env !== 'prod';
                },
            },

            async task(ctx) {
                try {
                    // 同步外部数据
                    const count = await ctx.service.external.syncData();
                    ctx.logger.info(`同步了 ${count} 条数据`);
                } catch (err) {
                    ctx.logger.error('数据同步失败:', err);
                }
            },
        };
        ```

    - 示例4：立即执行任务


        ```javascript
        // app/schedule/immediate_task.js
        module.exports = {
            schedule: {
                type: 'worker',
                immediate: true, // 应用启动后立即执行一次
            },

            async task(ctx) {
                try {
                    // 初始化数据
                    await ctx.service.system.initData();
                    ctx.logger.info('系统数据初始化完成');
                } catch (err) {
                    ctx.logger.error('初始化失败:', err);
                }
            },
        };
        ```
3. 定时任务配置选项

    | 选项  | 类型  | 说明  |
    | --- | --- | --- |
    | interval | string | 执行间隔，如 '1s', '2m', '3h' |
    | cron | string | cron 表达式，如 '0 0 \*/3 \* \* \*' |
    | type | string | 执行方式：'worker'（随机一个 worker 执行），'all'（所有 worker 都执行） |
    | immediate | boolean | 是否立即执行一次 |
    | disable | function | 是否禁用任务 |
    | env | array | 指定在哪些环境下启用，如 \['prod', 'test'\] |

4. 高级用法

    1. 使用 Redis 实现分布式锁


        ```javascript
        // app/schedule/distributed_task.js
        module.exports = {
            schedule: {
                interval: '5m',
                type: 'all',
            },

            async task(ctx) {
                const lockKey = 'schedule:distributed_task:lock';
                const lockTimeout = 300; // 5分钟
                
                // 获取分布式锁
                const locked = await ctx.app.redis.set(lockKey, '1', 'EX', lockTimeout, 'NX');
                if (!locked) {
                    ctx.logger.info('任务已被其他 worker 执行');
                    return;
                }
                
                try {
                    // 执行任务
                    await ctx.service.task.processBatch();
                    ctx.logger.info('分布式任务执行完成');
                } finally {
                    // 释放锁
                    await ctx.app.redis.del(lockKey);
                }
            },
        };
        ```

    2. 定时发送邮件


        ```javascript
        // app/schedule/send_daily_report.js
        module.exports = {
            schedule: {
                cron: '0 30 9 * * *', // 每天上午9:30
                type: 'worker',
            },

            async task(ctx) {
                try {
                    // 获取日报数据
                    const reportData = await ctx.service.report.generateDailyReport();
                    
                    // 获取需要发送的用户列表
                    const users = await ctx.model.User.findAll({
                        where: {
                            receive_report: true,
                        },
                    });
                    
                    // 批量发送邮件
                    for (const user of users) {
                        await ctx.service.mail.send({
                            to: user.email,
                            subject: '每日报告',
                            template: 'daily_report',
                            data: {
                                user,
                                report: reportData,
                            },
                        });
                    }
                    
                    ctx.logger.info(`已发送 ${users.length} 份日报邮件`);
                } catch (err) {
                    ctx.logger.error('发送日报邮件失败:', err);
                }
            },
        };
        ```

    3. 定时备份数据库

        ```javascript
        // app/schedule/backup_database.js
        const { exec } = require('child_process');
        const path = require('path');
        const fs = require('fs');
        const dayjs = require('dayjs');

        module.exports = {
            schedule: {
                cron: '0 0 2 * * *', // 每天凌晨2点
                type: 'worker',
            },

            async task(ctx) {
                const { app } = ctx;
                const backupDir = path.join(app.config.baseDir, 'backups');
                
                // 创建备份目录
                if (!fs.existsSync(backupDir)) {
                    fs.mkdirSync(backupDir, { recursive: true });
                }
                
                const timestamp = dayjs().format('YYYYMMDD_HHmmss');
                const backupFile = path.join(backupDir, `backup_${timestamp}.sql`);
                
                try {
                    // 执行mysqldump命令
                    await new Promise((resolve, reject) => {
                        const { host, port, username, password, database } = app.config.sequelize;
                        
                        const cmd = `mysqldump -h${host} -P${port} -u${username} -p${password} ${database} > ${backupFile}`;
                        
                        exec(cmd, (error, stdout, stderr) => {
                            if (error) {
                                reject(error);
                                return;
                            }
                            resolve();
                        });
                    });
                    
                    // 保留最近7天的备份
                    const files = fs.readdirSync(backupDir)
                        .filter(file => file.startsWith('backup_') && file.endsWith('.sql'))
                        .sort()
                        .reverse();
                    
                    if (files.length > 7) {
                        for (const file of files.slice(7)) {
                            fs.unlinkSync(path.join(backupDir, file));
                        }
                    }
                    
                    ctx.logger.info(`数据库备份成功: ${backupFile}`);
                } catch (err) {
                    ctx.logger.error('数据库备份失败:', err);
                }
            },
        };
        ```

5. 测试定时任务

    1. 手动执行定时任务

        你可以在开发环境中手动执行定时任务进行测试：


        ```javascript
        // 在 controller 中调用
        async triggerSchedule() {
            const { ctx } = this;
            const schedule = ctx.app.schedules['update_cache'];
            await schedule.task(ctx);
            ctx.body = '定时任务已手动触发';
        }
        ```

    2. 日志查看

        定时任务的执行情况会记录在日志中，可以在 `logs/{app_name}/common-log.{app_name}.log` 中查看。

6. 注意事项

    1.  **任务执行时间**：确保任务的执行时间不会超过间隔时间，避免任务重叠执行
    2.  **错误处理**：务必做好错误处理，避免任务失败导致整个应用崩溃
    3.  **分布式环境**：在集群环境下，考虑使用分布式锁避免重复执行
    4.  **性能影响**：长时间运行的任务可能会影响应用性能，建议拆分大任务
    5.  **配置管理**：生产环境和开发环境的定时任务配置可能需要不同
        
7. 最佳实践

    1.  **任务拆分**：将大任务拆分为多个小任务   
    2.  **幂等设计**：确保任务可以重复执行而不会产生副作用
    3.  **监控报警**：对关键任务添加监控和报警机制
    4.  **日志记录**：详细记录任务执行情况和结果
    5.  **资源释放**：确保任务执行完毕后释放所有资源

