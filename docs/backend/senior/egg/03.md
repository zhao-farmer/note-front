
# 三、内置对象

## 3.1 内置对象介绍

1. 应用的内置对象

    Egg.js 框架提供了多个内置对象，这些对象贯穿整个应用的生命周期，在开发中扮演着重要角色。

    1. 从 `[Koa]` 继承而来的 4 个对象 Application，Context，Request，Response
    2. 从框架扩展的其他一些对象 Controller，Service，Helper，Config，Logger



2. 各对象关系图

    ```md
    Application (全局)
    |
    ├── Config (配置)
    ├── Logger (日志)
    ├── Controller (控制器)
    |     |
    |     └── Context (上下文)
    |           |
    |           ├── Request (请求)
    |           ├── Response (响应)
    |           └── Helper (辅助)
    |
    └── Service (服务)
            |
            └── Context (上下文)
    ```

3. Egg.js 的 Context 对象提供了丰富的方法和属性来处理 HTTP 请求和响应，

    1.  **Controller 保持精简**：只负责参数处理和结果返回
        
    2.  **业务逻辑放 Service**：保持业务独立性
        
    3.  **合理使用 Helper**：提取通用工具函数
        
    4.  **配置分离**：不同环境使用不同配置
        
    5.  **日志分级**：合理使用不同级别日志
        
    6.  **善用 Context**：在需要请求信息的地方使用上下文


## 3.2 Application（应用对象）


### 3.2.1 介绍

Application 是全局应用对象，在一个应用中只会实例化一次，它继承自 Koa.Application。

1. 特点

    *   在应用启动时创建
    *   贯穿整个应用生命周期
    *   可以通过 `app` 访问    
2. 主要属性和方法


    ```js
    // 获取应用配置
    app.config

    // 访问 Service
    app.serviceName

    // 访问 Model
    app.model

    // 注册中间件
    app.use(middleware)

    // 事件监听
    app.on('event', callback)

    // 获取插件
    app.pluginName
    ```


3. Application 对象是 Egg.js 的核心全局对象，通过它可以：

    1.  扩展全局方法和属性 
    2.  管理应用生命周期
    3.  处理全局事件
    4.  管理中间件和插件
    5.  实现多进程通信
    6.  进行全局配置
    7.  实现监控和错误处理
    

### 3.2.2 基础 Application 扩展

- 在 app.js 中扩展 Application

    ```javascript
    // app.js
    module.exports = app => {
        // 添加全局方法
        app.getServerTime = () => {
            return new Date();
        };

        // 添加全局变量
        app.sharedData = {
            version: '1.0.0',
            author: 'Egg Team'
        };

        // 添加全局服务
        app.myGlobalService = {
            getConfig(key) {
                return app.config[key];
            },
            getAllRoutes() {
                return app.router.stack.map(layer => {
                    return {
                        path: layer.path,
                        methods: layer.methods
                    };
                });
            }
        };
    };
    ```

- 在 Controller 中使用扩展的 Application

    ```javascript
    // app/controller/home.js
    const Controller = require('egg').Controller;

    class HomeController extends Controller {
        async index() {
            const { app } = this;
            
            // 使用扩展的方法和属性
            const serverTime = app.getServerTime();
            const version = app.sharedData.version;
            const dbConfig = app.myGlobalService.getConfig('sequelize');
            const routes = app.myGlobalService.getAllRoutes();
            
            this.ctx.body = {
                serverTime,
                version,
                dbConfig,
                routes
            };
        }
    }

    module.exports = HomeController;
    ```

### 3.2.3 生命周期事件监听

- 设置app.js

    ```javascript
    // app.js
    module.exports = app => {
        // 应用启动完成事件
        app.once('server', server => {
            // HTTP server 已启动
            app.logger.info('Server started on port %s', server.address().port);
        });
        
        // 收到请求事件
        app.on('request', ctx => {
            app.logger.info('Request received: %s %s', ctx.method, ctx.url);
        });
        
        // 响应完成事件
        app.on('response', ctx => {
            const used = Date.now() - ctx.starttime;
            app.logger.info('Request completed: %s %s - %s ms', 
            ctx.method, ctx.url, used);
        });
        
        // 自定义事件
        app.on('custom_event', data => {
            app.logger.info('Custom event triggered with data:', data);
        });
    };
    ```
- 在 Controller 中触发自定义事件

    ```js
    async triggerEvent() {
        this.app.emit('custom_event', { time: new Date() });
        this.ctx.body = 'Event triggered';
    }
    ```

### 3.2.4 全局中间件管理

- 设置 app.js

    ```javascript
    module.exports = app => {
        // 添加全局中间件
        app.config.coreMiddleware.unshift('myGlobalMiddleware');
        
        // 自定义全局中间件
        app.middleware.myGlobalMiddleware = (options, app) => {
            return async (ctx, next) => {
                ctx.starttime = Date.now();
                app.logger.info('Global middleware start');
                await next();
                app.logger.info('Global middleware end');
            };
        };
    };
    ```

- 在 config/config.default.js 中配置

    ```js
    exports.middleware = ['myGlobalMiddleware'];
    ```

### 3.2.5 插件管理示例


- app.js

    ```javascript
    module.exports = app => {
        // 检查插件是否启用
        if (app.plugins.sequelize) {
            app.logger.info('Sequelize plugin is enabled');
            
            // 添加模型关联
            app.ready(() => {
                app.model.User.hasMany(app.model.Article, {
                    foreignKey: 'user_id',
                    as: 'articles'
                });
            });
        }
        
        // 扩展插件功能
        if (app.plugins.redis) {
            app.redisCheck = () => {
                return app.redis.ping().then(() => true).catch(() => false);
            };
        }
    };
    ```

- 在 Controller 中使用

    ```js
    async checkRedis() {
        const isOK = await this.app.redisCheck();
        this.ctx.body = { redis: isOK ? 'OK' : 'Down' };
    }
    ```

### 3.2.6 定时任务管理


```javascript
// app.js
module.exports = app => {
    // 动态添加定时任务
    if (app.config.env === 'prod') {
        app.beforeStart(async () => {
            await app.runSchedule('backup_database');
        });
    }
    
    // 添加自定义定时任务
    app.schedule('custom_task', {
        type: 'worker',
        schedule: '0 0 3 * * *', // 每天凌晨3点执行
        async task(ctx) {
            ctx.logger.info('Custom task running');
            await ctx.service.cleanup.run();
        }
    });
};
```

### 3.2.7 全局错误处理

- app.js

    ```javascript
    module.exports = app => {
        // 全局错误处理
        app.on('error', (err, ctx) => {
            // 记录错误日志
            app.logger.error(err);
            
            // 发送错误通知
            if (app.config.env === 'prod') {
                app.service.mail.sendErrorReport(err, ctx);
            }
        });
        
        // 自定义错误类型
        class AppError extends Error {
            constructor(message, code) {
                super(message);
                this.code = code;
            }
        }
        
        app.AppError = AppError;
    };
    ```
- 在 Service 中使用

    ```js
    async sensitiveOperation() {
        const { ctx, app } = this;
        if (!ctx.user.admin) {
            throw new app.AppError('Permission denied', 403);
        }
        // ...其他逻辑
    }
    ```

### 3.2.8 应用启动前初始化


```javascript
// app.js
module.exports = app => {
    // 应用启动前异步操作
    app.beforeStart(async () => {
        // 等待数据库连接
        await app.model.sync();
        
        // 初始化数据
        await app.service.initData.run();
        
        // 检查依赖服务
        const redisOK = await app.redis.ping();
        if (!redisOK) {
            throw new Error('Redis connection failed');
        }
        
        app.logger.info('Application initialized successfully');
    });
    
    // 应用关闭时清理
    app.beforeClose(async () => {
        await app.redis.quit();
        await app.model.sequelize.close();
        app.logger.info('Application closed gracefully');
    });
};
```

### 3.2.9 动态配置管理

- app.js

    ```javascript
    module.exports = app => {
        // 动态更新配置
        app.updateConfig = (key, value) => {
            app.config[key] = value;
            app.logger.info('Config updated: %s = %s', key, value);
        };
        
        // 配置热重载
        if (app.config.env === 'local') {
            const chokidar = require('chokidar');
            const path = require('path');
            
            const configPath = path.join(app.baseDir, 'config');
            const watcher = chokidar.watch(configPath);
            
            watcher.on('change', changedPath => {
                app.logger.info('Config file changed: %s', changedPath);
                delete require.cache[changedPath];
                const newConfig = require(changedPath);
                Object.assign(app.config, newConfig);
            });
        }
    };
    ```

- 在 Controller 中使用

    ```js
        async updateConfig() {
        const { app, ctx } = this;
        const { key, value } = ctx.request.body;
        app.updateConfig(key, value);
        ctx.body = { success: true };
    }
    ```

### 3.2.10 多进程通信

- app.js

    ```javascript
    module.exports = app => {
        // 主进程逻辑
        if (app.cluster && app.cluster.isMaster) {
            // 监听子进程消息
            process.on('message', msg => {
                if (msg.action === 'update_cache') {
                    app.messenger.sendToApp('refresh_cache');
                }
            });
        }
        
        // 添加进程间通信方法
        app.broadcast = (action, data) => {
            app.messenger.sendToApp(action, data);
        };
        
        // 监听进程消息
        app.messenger.on('refresh_cache', () => {
            app.service.cache.refresh();
        });
    };
    ```
- 在 Service 中使用

    ```js
    async refreshAll() {
        await this.app.broadcast('refresh_cache');
    }
    ```

### 3.2.11 综合案例：应用监控系统

- app.js

    ```javascript
    module.exports = app => {
        // 应用监控系统
        app.monitor = {
            stats: {
                requestCount: 0,
                errorCount: 0
            },
            
            incrementRequest() {
                this.stats.requestCount++;
            },
            
            incrementError() {
                this.stats.errorCount++;
            },
            
            getStats() {
                return {
                    ...this.stats,
                    uptime: process.uptime(),
                    memoryUsage: process.memoryUsage()
                };
            }
        };
        
        // 监听请求事件
        app.on('request', () => {
            app.monitor.incrementRequest();
        });
        
        // 监听错误事件
        app.on('error', () => {
            app.monitor.incrementError();
        });
        
        // 定时报告状态
        app.schedule('report_stats', {
            interval: '10m',
            type: 'worker',
            async task(ctx) {
                const stats = app.monitor.getStats();
                await ctx.service.monitor.report(stats);
            }
        });
    };
    ```

- 在 Controller 中获取监控数据

    ```js
    async getStats() {
        this.ctx.body = this.app.monitor.getStats();
    }
    ```

## 3.3 Context（上下文对象）

### 3.3.1 基础

Context 是请求级别的对象，继承自 Koa.Context，封装了这次用户请求的信息。

1. 特点

    *   每次请求都会创建一个新的 Context
    *   在中间件、控制器、服务等地方都可以访问到
    *   可以通过 `ctx` 访问
        

2. 主要属性和方法


    ```javascript
    // 请求信息
    ctx.request
    ctx.response
    ctx.method
    ctx.url

    // 状态管理
    ctx.status = 200
    ctx.body = { data: 'value' }

    // Cookie 操作
    ctx.cookies.get('name')
    ctx.cookies.set('name', 'value')

    // Session 操作
    ctx.session.user = { name: 'egg' }

    // 服务调用
    ctx.service.user.find()
    ```


3. Egg.js 的 Context 对象提供了丰富的方法和属性来处理 HTTP 请求和响应，主要包括：

    1.  **请求处理**：获取参数、校验数据、处理上传文件
    2.  **响应处理**：设置状态码、响应头、返回各种类型数据
    3.  **状态管理**：Cookie 和 Session 操作
    4.  **服务调用**：访问 Service 层
    5.  **异常处理**：统一的错误处理机制
    6.  **日志记录**：请求级别的日志记录
    7.  **辅助方法**：通过 Helper 使用工具函数
    

### 3.3.2 基础 Context 使用

获取请求信息

```javascript
// app/controller/home.js
const Controller = require('egg').Controller;

class HomeController extends Controller {
    async info() {
        const { ctx } = this;
        
        // 获取请求方法
        const method = ctx.method;
        
        // 获取请求URL
        const url = ctx.url;
        
        // 获取请求头
        const headers = ctx.headers;
        
        // 获取IP地址
        const ip = ctx.ip;
        
        ctx.body = {
            method,
            url,
            headers,
            ip,
            timestamp: new Date()
        };
    }
}

module.exports = HomeController;
```

### 3.3.3 请求参数处理

- 获取不同类型参数

    ```javascript
    async params() {
        const { ctx } = this;
        
        // 获取路由参数 /:id
        const routeParams = ctx.params;
        
        // 获取查询参数 ?name=value
        const queryParams = ctx.query;
        
        // 获取POST请求体
        const bodyParams = ctx.request.body;
        
        // 获取上传的文件
        const files = ctx.request.files;
        
        ctx.body = {
            routeParams,
            queryParams,
            bodyParams,
            hasFiles: !!files
        };
    }
    ```

- 参数校验


    ```javascript
    async createUser() {
        const { ctx } = this;
        
        // 参数校验规则
        const rules = {
            username: { type: 'string', required: true },
            password: { type: 'string', min: 6 },
            age: { type: 'number', required: false },
            email: { type: 'email' }
        };
        
        // 执行校验
        try {
            ctx.validate(rules);
            const user = await ctx.service.user.create(ctx.request.body);
            ctx.body = user;
        } catch (err) {
            ctx.status = 422;
            ctx.body = {
                error: 'Validation Failed',
                details: err.errors
            };
        }
    }
    ```

### 3.3.4 响应处理

- 设置不同响应

    ```javascript
    async response() {
        const { ctx } = this;
        
        // 设置HTTP状态码
        ctx.status = 201;
        
        // 设置响应头
        ctx.set('X-Request-Id', ctx.helper.uuid());
        
        // 返回JSON
        ctx.body = {
            success: true,
            data: {
            message: 'Hello World'
            }
        };
        
        // 重定向
        // ctx.redirect('/login');
        
        // 返回HTML
        // ctx.body = '<h1>Hello</h1>';
        // ctx.type = 'html';
        
        // 文件下载
        // ctx.attachment('filename.txt');
        // ctx.body = fs.createReadStream('/path/to/file.txt');
    }
    ```

### 3.3.5 Cookie 和 Session 操作

- Cookie 操作

    ```javascript
    async cookie() {
        const { ctx } = this;
        
        // 设置Cookie
        ctx.cookies.set('token', 'abcd1234', {
            httpOnly: true,
            maxAge: 24 * 60 * 60 * 1000, // 1天
            signed: true, // 签名防止篡改
            encrypt: true // 加密cookie值
        });
        
        // 获取Cookie
        const token = ctx.cookies.get('token', {
            signed: true,
            encrypt: true
        });
        
        // 删除Cookie
        // ctx.cookies.set('token', null);
        
        ctx.body = {
            token
        };
    }
    ```

- Session 操作

    ```javascript
    async session() {
        const { ctx } = this;
        
        // 设置Session
        ctx.session.visited = ctx.session.visited ? ctx.session.visited + 1 : 1;
        
        // 获取Session
        const user = ctx.session.user;
        
        // 删除Session
        // ctx.session = null;
        
        ctx.body = {
            visited: ctx.session.visited,
            currentUser: user
        };
    }
    ```

### 3.3.6 服务调用

调用 Service 方法

```javascript
async userInfo() {
    const { ctx } = this;
    
    // 调用Service
    const user = await ctx.service.user.find(ctx.params.id);
    
    if (!user) {
        ctx.throw(404, 'User not found');
    }
    
    ctx.body = user;
}
```

### 3.3.7 异常处理

抛出和处理异常

```javascript
async riskyOperation() {
    const { ctx } = this;
    
    try {
        // 可能会抛出异常的操作
        const result = await ctx.service.dangerous.action();
        ctx.body = result;
    } catch (err) {
        // 记录错误日志
        ctx.logger.error('Risky operation failed:', err);
        
        // 返回错误响应
        ctx.status = err.status || 500;
        ctx.body = {
        error: err.message,
        code: err.code
        };
    }
}

async throwError() {
    const { ctx } = this;
    
    // 抛出带状态码的错误
    ctx.throw(403, 'Permission denied');
    
    // 等同于
    // const err = new Error('Permission denied');
    // err.status = 403;
    // throw err;
}
```

### 3.3.8 文件上传


```javascript
async upload() {
    const { ctx } = this;
    
    // 确保是multipart/form-data请求
    if (!ctx.request.files) {
        ctx.throw(400, 'Only multipart/form-data is supported');
    }
    
    const file = ctx.request.files[0];
    
    try {
        // 保存文件
        const savePath = `/uploads/${ctx.helper.uuid()}${path.extname(file.filename)}`;
        const target = path.join(this.config.baseDir, 'app/public', savePath);
        
        // 确保目录存在
        const dir = path.dirname(target);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        // 移动文件
        await fs.promises.rename(file.filepath, target);
        
        // 清理临时文件
        await ctx.cleanupRequestFiles();
        
        ctx.body = {
            url: savePath,
            originalname: file.filename,
            size: file.size
        };
    } catch (err) {
        // 确保清理临时文件
        await ctx.cleanupRequestFiles();
        ctx.throw(500, 'Upload failed');
    }
}
```

### 3.3.9 日志记录


```javascript
async logExample() {
    const { ctx } = this;
    
    // 不同级别的日志
    ctx.logger.debug('Debug message');
    ctx.logger.info('Request from %s', ctx.ip);
    ctx.logger.warn('Warning message');
    ctx.logger.error(new Error('Something wrong'));
    
    // 带请求信息的日志
    ctx.logger.info('Request completed: %s %s', ctx.method, ctx.url);
    
    ctx.body = {
        message: 'Check your logs'
    };
}
```

### 3.3.10 辅助方法 (Helper)

```javascript
async helperExample() {
    const { ctx } = this;
    
    // 生成URL
    const userUrl = ctx.helper.urlFor('userController.show', { id: 123 });
    
    // 加密字符串
    const encrypted = ctx.helper.md5('password');
    
    // 格式化日期
    const today = ctx.helper.formatDate(new Date());
    
    ctx.body = {
        userUrl,
        encrypted,
        today
    };
}
```

### 3.3.11 综合示例：用户认证流程

```javascript
// app/controller/auth.js
const Controller = require('egg').Controller;

class AuthController extends Controller {
    async login() {
        const { ctx } = this;
        
        // 参数校验
        ctx.validate({
            username: 'string',
            password: 'string'
        });
        
        // 验证用户
        const user = await ctx.service.user.verify(
            ctx.request.body.username,
            ctx.request.body.password
        );
        
        if (!user) {
            ctx.throw(401, 'Invalid username or password');
        }
        
        // 生成token
        const token = ctx.app.jwt.sign({
            userId: user.id
        }, ctx.app.config.jwt.secret);
        
        // 设置session
        ctx.session.user = {
            id: user.id,
            username: user.username
        };
        
        // 设置cookie
        ctx.cookies.set('token', token, {
            httpOnly: true,
            maxAge: 7 * 24 * 60 * 60 * 1000, // 7天
            signed: true
        });
        
        ctx.body = {
            success: true,
            token,
            user: {
                id: user.id,
                username: user.username
            }
        };
    }
    
    async logout() {
        const { ctx } = this;
        
        // 清除session
        ctx.session = null;
        
        // 清除cookie
        ctx.cookies.set('token', null);
        
        ctx.body = {
            success: true
        };
    }
    
    async profile() {
        const { ctx } = this;
        
        // 检查认证
        if (!ctx.session.user) {
            ctx.throw(401, 'Please login first');
        }
        
        // 获取用户信息
        const user = await ctx.service.user.find(ctx.session.user.id);
        
        ctx.body = {
            user
        };
    }
}

module.exports = AuthController;
```

### 3.3.12 自定义 Context 扩展


```javascript
// app/extend/context.js
module.exports = {
    // 成功响应方法
    success(data, message = 'success') {
        this.body = {
            success: true,
            message,
            data
        };
    },
    
    // 失败响应方法
    fail(message = 'error', code = 400) {
        this.status = code;
        this.body = {
            success: false,
            message
        };
    },
    
    // 获取当前用户
    get user() {
        return this.session.user;
    },
    
    // 检查是否登录
    get isAuthenticated() {
        return !!this.session.user;
    }
};

// 在 Controller 中使用扩展方法
async example() {
    const { ctx } = this;
    
    if (!ctx.isAuthenticated) {
        return ctx.fail('Please login', 401);
    }
    
    const data = await ctx.service.data.fetch();
    ctx.success(data);
}
```

## 3.4 请求与响应


Egg.js 的 Request 和 Response 对象提供了丰富的功能：

- **Request 主要功能**：

    *   获取请求方法、URL、路径等信息
    *   处理查询参数和请求体
    *   文件上传处理
    *   参数校验
    *   内容协商
    
- **Response 主要功能**：

    *   设置HTTP状态码
    *   设置响应头
    *   返回不同类型数据（JSON/HTML/文本等）
    *   重定向
    *   文件下载
    *   Cookie设置

### 3.4.1 Request（请求对象）

Request 是请求级别的对象，封装了 Node.js 原生的 HTTP Request 对象。

1. 特点

    *   提供更多便捷的属性和方法 
    *   可以通过 `ctx.request` 访问
        

2. 主要属性和方法

    ```javascript
    // 获取查询参数
    ctx.request.query

    // 获取 POST 数据
    ctx.request.body

    // 获取请求头
    ctx.request.headers

    // 检查内容类型
    ctx.request.is('json')

    // 获取 IP
    ctx.request.ip
    ```


### 3.4.2 Response（响应对象）


Response 是请求级别的对象，封装了 Node.js 原生的 HTTP Response 对象。

1. 特点

    *   提供更多便捷的属性和方法
    *   可以通过 `ctx.response` 访问

2. 主要属性和方法


    ```javascript
    // 设置状态码
    ctx.response.status = 201

    // 设置响应体
    ctx.response.body = { data: 'value' }

    // 设置响应头
    ctx.response.set('X-Request-Id', '123')

    // 重定向
    ctx.response.redirect('/login')

    // 附件下载
    ctx.response.attachment('file.txt')
    ```

### 3.4.3  Request 对象使用示例

Request 对象封装了 Node.js 原生的 HTTP Request 对象，提供了许多便捷的方法和属性。

1. 基础请求信息获取


    ```javascript
    // app/controller/request.js
    const Controller = require('egg').Controller;

    class RequestController extends Controller {
        async info() {
            const { ctx } = this;
            
            // 获取请求方法
            const method = ctx.request.method;
            
            // 获取请求URL
            const url = ctx.request.url;
            
            // 获取请求路径
            const path = ctx.request.path;
            
            // 获取查询字符串
            const query = ctx.request.query;
            
            // 获取请求头
            const headers = ctx.request.headers;
            
            // 获取客户端IP
            const ip = ctx.request.ip;
            
            ctx.body = {
                method,
                url,
                path,
                query,
                headers,
                ip
            };
        }
    }
    ```

2. 请求体处理


    ```javascript
    async body() {
        const { ctx } = this;
        
        // 获取POST请求体
        const body = ctx.request.body;
        
        // 检查内容类型
        const isJson = ctx.request.is('json');
        const isXml = ctx.request.is('xml');
        
        // 获取Content-Type
        const contentType = ctx.request.type;
        
        // 获取Content-Length
        const contentLength = ctx.request.length;
        
        ctx.body = {
            body,
            isJson,
            isXml,
            contentType,
            contentLength
        };
    }
    ```

3. 参数校验

    ```javascript
    async validate() {
        const { ctx } = this;
        
        // 参数校验规则
        const rules = {
            username: { type: 'string', required: true },
            password: { type: 'string', min: 6 },
            age: { type: 'number', required: false, max: 120 },
            email: { type: 'email' }
        };
        
        // 执行校验
        try {
            ctx.validate(rules);
            ctx.body = { 
                success: true,
                data: ctx.request.body
            };
        } catch (err) {
            ctx.status = 422;
            ctx.body = {
                success: false,
                errors: err.errors
            };
        }
    }
    ```

4. 文件上传处理


    ```javascript
    async upload() {
        const { ctx } = this;
        
        // 检查是否有文件上传
        if (!ctx.request.files || ctx.request.files.length === 0) {
            ctx.throw(400, '请上传文件');
        }
        
        const file = ctx.request.files[0];
        
        try {
            // 处理文件...
            ctx.body = {
                filename: file.filename,
                mimeType: file.mimeType,
                size: file.size
            };
        } finally {
            // 清理临时文件
            await ctx.cleanupRequestFiles();
        }
    }
    ```

### 3.4.4 Response 对象使用示例

Response 对象封装了 Node.js 原生的 HTTP Response 对象，提供了响应相关的便捷方法。

1. 基础响应设置


    ```javascript
    // app/controller/response.js
    const Controller = require('egg').Controller;

    class ResponseController extends Controller {
        async basic() {
            const { ctx } = this;
            
            // 设置HTTP状态码
            ctx.response.status = 200;
            
            // 设置响应头
            ctx.response.set({
                'X-Powered-By': 'Egg.js',
                'X-Request-Id': ctx.helper.uuid()
            });
            
            // 设置响应体
            ctx.response.body = {
                message: 'Hello World'
            };
        }
    }
    ```

2. 不同类型响应

    ```javascript
    async types() {
        const { ctx } = this;
        
        // JSON响应
        ctx.response.type = 'json';
        ctx.body = { message: 'JSON response' };
        
        // HTML响应
        // ctx.response.type = 'html';
        // ctx.body = '<h1>HTML response</h1>';
        
        // 文本响应
        // ctx.response.type = 'text';
        // ctx.body = 'Plain text response';
        
        // XML响应
        // ctx.response.type = 'xml';
        // ctx.body = '<message>XML response</message>';
    }
    ```

3. 重定向

    ```javascript
    async redirect() {
        const { ctx } = this;
        
        // 临时重定向(302)
        ctx.response.redirect('/new/location');
        
        // 永久重定向(301)
        // ctx.response.redirect('/new/location', 301);
        
        // 重定向回来源页面
        // ctx.response.redirect('back');
    }
    ```

4. 文件下载


    ```javascript
    async download() {
        const { ctx } = this;
        const filePath = '/path/to/file.txt';
        
        // 设置附件下载
        ctx.response.attachment(filePath);
        
        // 设置响应体为文件流
        ctx.body = fs.createReadStream(filePath);
    }
    ```

5. 设置Cookie


    ```javascript
    async cookie() {
        const { ctx } = this;
        
        // 设置Cookie
        ctx.response.cookies.set('token', 'abcd1234', {
            httpOnly: true,
            maxAge: 24 * 60 * 60 * 1000, // 1天
            signed: true,
            encrypt: true
        });
        
        ctx.body = {
            message: 'Cookie set'
        };
    }
    ```

### 3.4.5  综合示例

1. RESTful API 实现

    ```javascript
    // app/controller/api.js
    const Controller = require('egg').Controller;

    class ApiController extends Controller {
        async index() {
            const { ctx } = this;
            const items = await ctx.service.item.list(ctx.request.query);
            ctx.response.body = items;
        }
        
        async show() {
            const { ctx } = this;
            const item = await ctx.service.item.find(ctx.params.id);
            
            if (!item) {
                ctx.response.status = 404;
                ctx.response.body = { error: 'Not found' };
                return;
            }
            
            ctx.response.body = item;
        }
        
        async create() {
            const { ctx } = this;
            try {
            ctx.validate({
                name: 'string',
                value: 'number'
            });
            
            const item = await ctx.service.item.create(ctx.request.body);
                ctx.response.status = 201;
                ctx.response.body = item;
            } catch (err) {
                ctx.response.status = 422;
                ctx.response.body = {
                    error: 'Validation failed',
                    details: err.errors
                };
            }
        }
        
        async update() {
            const { ctx } = this;
            try {
                ctx.validate({
                    name: { type: 'string', required: false },
                    value: { type: 'number', required: false }
                });
                
                const item = await ctx.service.item.update(
                    ctx.params.id,
                    ctx.request.body
                );
                
                ctx.response.body = item;
            } catch (err) {
                ctx.response.status = 422;
                ctx.response.body = {
                    error: 'Update failed',
                    details: err.message
                };
            }
        }
        
        async destroy() {
            const { ctx } = this;
            const success = await ctx.service.item.delete(ctx.params.id);
            
            if (success) {
            ctx.response.status = 204;
            } else {
            ctx.response.status = 404;
            ctx.response.body = { error: 'Not found' };
            }
        }
    }
    ```

2. 文件上传和下载服务



    ```javascript
    // app/controller/file.js
    const Controller = require('egg').Controller;
    const fs = require('fs');
    const path = require('path');

    class FileController extends Controller {
        async upload() {
            const { ctx } = this;
            
            // 检查文件上传
            if (!ctx.request.files || ctx.request.files.length === 0) {
                ctx.response.status = 400;
                ctx.response.body = { error: 'No files uploaded' };
                return;
            }
            
            const file = ctx.request.files[0];
            const savePath = `/uploads/${Date.now()}${path.extname(file.filename)}`;
            const target = path.join(this.config.baseDir, 'app/public', savePath);
            
            try {
                // 确保目录存在
                const dir = path.dirname(target);
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                }
                
                // 移动文件
                await fs.promises.rename(file.filepath, target);
                
                ctx.response.body = {
                    url: savePath,
                    originalname: file.filename,
                    size: file.size
                };
            } catch (err) {
                ctx.response.status = 500;
                ctx.response.body = { error: 'File upload failed' };
            } finally {
                await ctx.cleanupRequestFiles();
            }
        }
        
        async download() {
            const { ctx } = this;
            const filePath = path.join(
                this.config.baseDir,
                'app/public',
                ctx.params[0]
            );
            
            if (!fs.existsSync(filePath)) {
                ctx.response.status = 404;
                ctx.response.body = { error: 'File not found' };
                return;
            }
            
            // 设置下载头
            ctx.response.attachment(filePath);
            
            // 返回文件流
            ctx.response.body = fs.createReadStream(filePath);
        }
    }
    ```

3. 认证中间件示例


    ```javascript
    // app/middleware/auth.js
    module.exports = options => {
        return async (ctx, next) => {
            // 从请求头获取token
            const token = ctx.request.get('Authorization');
            
            if (!token) {
                ctx.response.status = 401;
                ctx.response.body = { error: 'Unauthorized' };
                return;
            }
            
            try {
                // 验证token
                const decoded = ctx.app.jwt.verify(token, ctx.app.config.jwt.secret);
                ctx.request.user = decoded;
                await next();
            } catch (err) {
                ctx.response.status = 401;
                ctx.response.body = { error: 'Invalid token' };
            }
        };
    };

    // 在需要认证的控制器中使用
    async profile() {
        const { ctx } = this;
        ctx.response.body = {
            user: ctx.request.user
        };
    }
    ```

### 3.4.5 扩展 Request 和 Response

你还可以扩展 Request 和 Response 对象：


```javascript
// app/extend/request.js
module.exports = {
    get isMobile() {
        const userAgent = this.get('User-Agent').toLowerCase();
        return /iphone|ipod|android|windows phone/.test(userAgent);
    },
    
    get isApiRequest() {
        return this.path.startsWith('/api/');
    }
};

// app/extend/response.js
module.exports = {
    success(data, message = 'success') {
        this.status = 200;
        this.body = {
        success: true,
        message,
        data
        };
    },
    
    fail(message = 'error', code = 400) {
        this.status = code;
        this.body = {
        success: false,
        message
        };
    }
};

// 在控制器中使用扩展方法
async example() {
    const { ctx } = this;
    
    if (ctx.request.isMobile) {
        ctx.response.success({ version: 'mobile' });
    } else {
        ctx.response.success({ version: 'desktop' });
    }
}
```

        

## 3.5 控制器与服务

1. 基类

    - Controller:框架提供了一个 Controller 基类，并推荐所有的 Controller 都继承于该基类实现。

        ```js
        const Controller = require('egg').Controller;

        class UserController extends Controller {
        }
        ```
    - Service:框架提供了一个 Service 基类，并推荐所有的 Service 都继承于该基类实现。
        ```js
        const Service = require('egg').Service;

        class UserService extends Service {
            
        }
        ```

2. 访问对象

    - ctx.controller 提供了访问其他控制器方法的能力，允许你在一个控制器中调用另一个控制器的逻辑。

        ```js
        // app/controller/user.js
        const Controller = require('egg').Controller;

        class UserController extends Controller {
            async profile() {
                const { ctx } = this;
                const user = await ctx.service.user.find(ctx.params.id);
                ctx.body = user;
            }
        }

        // app/controller/api.js
        const Controller = require('egg').Controller;

        class ApiController extends Controller {
            async getUser() {
                const { ctx } = this;
                // 调用 UserController 的 profile 方法
                await ctx.controller.user.profile();
            }
        }
        ```
    - ctx.service 是访问服务层的主要方式，用于处理业务逻辑、数据访问等核心功能。

        ```js
        // app/service/user.js
        const Service = require('egg').Service;

        class UserService extends Service {
            async find(id) {
                return await this.ctx.model.User.findByPk(id);
            }
            
            async create(userData) {
                return await this.ctx.model.User.create(userData);
            }
        }

        // 在控制器中使用
        async createUser() {
            const { ctx } = this;
            const user = await ctx.service.user.create(ctx.request.body);
            ctx.body = user;
        }

        // 其他服务层调用
        const Service = require('egg').Service;

        class OrderService extends Service {
            async create(userId, orderData) {
                // 调用其他服务
                const user = await this.ctx.service.user.find(userId);

            }
        }

        ```



## 3.6 Helper（辅助函数）


### 3.6.1 基础

Helper 是 Egg.js 提供的一个实用工具对象，用于放置一些常用的工具方法。它可以在 Context 的实例上获取到（即 `ctx.helper`），也可以在 Controller、Service 等地方通过 `this.ctx.helper` 访问。


1. 内置方法

    ```javascript
    // 生成 URL
    ctx.helper.urlFor('userController.show', { id: 123 })

    // 转义 HTML
    ctx.helper.escape('<script>')

    // 格式化日期
    ctx.helper.formatDate(new Date())
    ```

2. 自定义扩展


    ```javascript
    // app/extend/helper.js
    module.exports = {
        md5(str) {
            return require('crypto').createHash('md5').update(str).digest('hex');
        }
    };

    // 使用
    ctx.helper.md5('123456');
    ```

### 3.6.2 基础 Helper 定义与使用

1.  定义 Helper 方法

    在 `app/extend/helper.js` 中扩展 Helper：


    ```javascript
    // app/extend/helper.js
    const crypto = require('crypto');

    module.exports = {
        // 生成MD5哈希
        md5(str) {
            return crypto.createHash('md5').update(str).digest('hex');
        },

        // 格式化日期
        formatDate(date, format = 'YYYY-MM-DD HH:mm:ss') {
            const d = new Date(date);
            const pad = n => n < 10 ? `0${n}` : n;
            
            return format
            .replace('YYYY', d.getFullYear())
            .replace('MM', pad(d.getMonth() + 1))
            .replace('DD', pad(d.getDate()))
            .replace('HH', pad(d.getHours()))
            .replace('mm', pad(d.getMinutes()))
            .replace('ss', pad(d.getSeconds()));
        },

        // 生成随机字符串
        randomString(length = 16) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
    };
    ```

2. 在 Controller 中使用 Helper


    ```javascript
    // app/controller/home.js
    const Controller = require('egg').Controller;

    class HomeController extends Controller {
        async index() {
            const { ctx } = this;
            
            // 使用helper方法
            const today = ctx.helper.formatDate(new Date());
            const encrypted = ctx.helper.md5('password123');
            const randomStr = ctx.helper.randomString(8);
            
            ctx.body = {
                today,
                encrypted,
                randomStr
            };
        }
    }

    module.exports = HomeController;
    ```

### 3.6.3 常用 Helper 方法示例

1. 分页处理

    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 分页处理
        paginate(data, options = {}) {
            const { list, total } = data;
            const { page = 1, pageSize = 10 } = options;
            
            return {
                list,
                total,
                page: parseInt(page),
                pageSize: parseInt(pageSize),
                totalPages: Math.ceil(total / pageSize)
            };
        }
    };

    // 在Service中使用
    async listUsers() {
        const { ctx } = this;
        const { page, pageSize } = ctx.query;
        const result = await ctx.model.User.findAndCountAll({
            offset: (page - 1) * pageSize,
            limit: pageSize
        });
        
        return ctx.helper.paginate({
            list: result.rows,
            total: result.count
        }, { page, pageSize });
    }
    ```

2. 数据脱敏

    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 数据脱敏
        desensitize(str, options = {}) {
            const { start = 3, end = 4, mask = '*' } = options;
            
            if (!str || typeof str !== 'string') return str;
            if (str.length <= start + end) return str;
            
            const head = str.slice(0, start);
            const tail = str.slice(-end);
            const middle = mask.repeat(str.length - start - end);
            
            return `${head}${middle}${tail}`;
        }
    };

    // 使用示例
    async userInfo() {
        const { ctx } = this;
        const user = await ctx.service.user.find(ctx.params.id);
        
        ctx.body = {
            ...user,
            phone: ctx.helper.desensitize(user.phone),
            email: ctx.helper.desensitize(user.email, { start: 2, end: 2 })
        };
    }
    ```

3. 参数校验增强


    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 增强参数校验
        validateParams(rules, params) {
            const { ctx } = this;
            try {
                ctx.validate(rules, params);
                return { valid: true };
            } catch (err) {
                return {
                    valid: false,
                    errors: err.errors.map(e => `${e.field}: ${e.message}`)
                };
            }
        }
    };

    // 在Controller中使用
    async createOrder() {
        const { ctx } = this;
        const rules = {
            productId: 'string',
            quantity: { type: 'number', min: 1 }
        };
        
        const validation = ctx.helper.validateParams(rules, ctx.request.body);
        if (!validation.valid) {
            ctx.status = 422;
            ctx.body = { errors: validation.errors };
            return;
        }
        
        // 继续处理...
    }
    ```

### 3.6.4 高级 Helper 示例

1. 文件处理 Helper


    ```javascript
    // app/extend/helper.js
    const fs = require('fs');
    const path = require('path');

    module.exports = {
        // 确保目录存在
        ensureDir(dir) {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        },
        
        // 获取文件扩展名
        getFileExt(filename) {
            return path.extname(filename).toLowerCase().slice(1);
        },
        
        // 生成唯一文件名
        generateFilename(originalname) {
            const ext = this.getFileExt(originalname);
            return `${Date.now()}-${Math.random().toString(36).slice(2)}.${ext}`;
        }
        };

        // 在文件上传中使用
        async upload() {
        const { ctx } = this;
        const file = ctx.request.files[0];
        
        // 使用helper方法
        const uploadDir = path.join(this.config.baseDir, 'app/public/uploads');
        ctx.helper.ensureDir(uploadDir);
        
        const filename = ctx.helper.generateFilename(file.filename);
        const target = path.join(uploadDir, filename);
        
        await fs.promises.rename(file.filepath, target);
        
        ctx.body = {
            url: `/uploads/${filename}`
        };
    }
    ```

    2. 权限检查 Helper


    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 检查权限
        checkPermission(user, requiredPermission) {
            if (!user || !user.roles) return false;
            
                return user.roles.some(role => 
                    role.permissions.includes(requiredPermission)
            );
        },
        
        // 验证管理员权限
        isAdmin(user) {
            return this.checkPermission(user, 'admin');
        }
    };

    // 在Controller中使用
    async deleteUser() {
        const { ctx } = this;
        
        if (!ctx.helper.isAdmin(ctx.session.user)) {
            ctx.throw(403, '无权执行此操作');
        }
        
        await ctx.service.user.delete(ctx.params.id);
        ctx.status = 204;
    }
    ```

3. API 响应格式化


    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 成功响应
        success(data = null, message = 'success') {
            this.ctx.body = {
                success: true,
                message,
                data
            };
        },
        
        // 失败响应
        fail(message = 'error', code = 400, errors = null) {
            this.ctx.status = code;
            this.ctx.body = {
                success: false,
                message,
                errors
            };
        }
    };

    // 在Controller中使用
    async getUser() {
        const { ctx } = this;
        try {
            const user = await ctx.service.user.find(ctx.params.id);
            if (!user) {
                return ctx.helper.fail('用户不存在', 404);
            }
            ctx.helper.success(user);
        } catch (err) {
            ctx.helper.fail('服务器错误', 500, [err.message]);
        }
    }
    ```

### 3.6.5 Helper 最佳实践

1.  **保持方法纯净**：Helper 方法应该是纯函数，不依赖外部状态
2.  **单一职责**：每个 Helper 方法只做一件事
3.  **通用性**：Helper 方法应该是通用的，可复用的
4.  **避免业务逻辑**：业务逻辑应该放在 Service 中
5.  **合理分类**：可以按功能将 Helper 方法拆分到不同文件
    

```javascript
// 可以这样组织helper
// app/extend/helper/
//   - date.js       // 日期相关方法
//   - string.js     // 字符串处理
//   - validate.js   // 验证相关
//   - file.js       // 文件处理
//   - index.js      // 主入口文件
```

### 3.6.6 实际应用场景

1. 验证码生成与校验

    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 生成数字验证码
        generateCaptcha(length = 6) {
            let code = '';
            for (let i = 0; i < length; i++) {
                code += Math.floor(Math.random() * 10);
            }
            return code;
        },
        
        // 校验验证码
        verifyCaptcha(input, stored) {
            return input === stored;
        }
    };

    // 在Controller中使用
    async sendSms() {
        const { ctx } = this;
        const phone = ctx.request.body.phone;
        
        // 生成验证码
        const code = ctx.helper.generateCaptcha();
        
        // 存储验证码（实际项目中应该用Redis等存储）
        ctx.session.captcha = {
            code,
            phone,
            expires: Date.now() + 5 * 60 * 1000 // 5分钟过期
        };
        
        // 发送短信（伪代码）
        await ctx.service.sms.send(phone, `您的验证码是：${code}`);
        
        ctx.helper.success(null, '验证码已发送');
        }

        async verifySms() {
        const { ctx } = this;
        const { phone, code } = ctx.request.body;
        
        if (!ctx.helper.verifyCaptcha(code, ctx.session.captcha?.code) || 
            phone !== ctx.session.captcha?.phone) {
            ctx.helper.fail('验证码错误', 400);
            return;
        }
        
        if (Date.now() > ctx.session.captcha?.expires) {
            ctx.helper.fail('验证码已过期', 400);
            return;
        }
        
        // 验证通过...
        ctx.helper.success();
    }
    ```

2. 数据转换 Helper

    ```javascript
    // app/extend/helper.js
    module.exports = {
        // 树形结构转换
        arrayToTree(data, options = {}) {
            const {
                idKey = 'id',
                parentKey = 'parentId',
                childrenKey = 'children'
            } = options;
            
            const tree = [];
            const map = {};
            
            // 创建映射
            data.forEach(item => {
                map[item[idKey]] = { ...item, [childrenKey]: [] };
            });
            
            // 构建树
            data.forEach(item => {
                const node = map[item[idKey]];
                if (item[parentKey] && map[item[parentKey]]) {
                    map[item[parentKey]][childrenKey].push(node);
                } else {
                    tree.push(node);
                }
            });
            
            return tree;
        },
        
        // 下划线转驼峰
        underlineToHump(obj) {
            if (!obj || typeof obj !== 'object') return obj;
            
            if (Array.isArray(obj)) {
                return obj.map(item => this.underlineToHump(item));
            }
            
            const newObj = {};
            for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const newKey = key.replace(/_(\w)/g, (_, c) => c.toUpperCase());
                newObj[newKey] = this.underlineToHump(obj[key]);
            }
            }
            return newObj;
        }
    };

    // 使用示例
    async menuList() {
        const { ctx } = this;
        const menus = await ctx.model.Menu.findAll(); // 返回数据库格式数据
        
        // 转换为树形结构
        const tree = ctx.helper.arrayToTree(menus);
        
        // 字段名转换
        ctx.body = ctx.helper.underlineToHump(tree);
    }
    ```

## 3.7 Config（配置）

### 3.7.1 介绍

Config 是 Egg.js 中用于管理应用配置的内置对象，支持多环境配置和合并规则。下面我将详细介绍 Config 的使用方法。

可以通过 `app.config` 或 `ctx.config` 访问


        
1. 配置方式


    ```javascript
    // config/config.default.js
    exports.sequelize = {
        dialect: 'mysql',
        host: '127.0.0.1',
        port: 3306,
    };

    // config/config.prod.js
    exports.sequelize = {
        host: 'mysql.prod.com',
    };
    ```

2. 使用方式

    ```javascript
    // 获取配置
    const dbConfig = this.app.config.sequelize;
    ```


### 3.7.2 基础配置结构

Egg.js 的配置文件位于 `config` 目录下，支持不同环境的配置：

```plain
config/
  |- config.default.js
  |- config.local.js
  |- config.prod.js
  |- config.unittest.js
  |- config.test.js
```

### 3.7.3 基本配置示例

1. config.default.js - 默认配置


    ```javascript
    // config/config.default.js
    module.exports = appInfo => {
        return {
            // 应用基础配置
            appName: 'my-egg-app',
            keys: appInfo.name + '_1234567890', // 用于加密 cookies 的密钥
            
            // 中间件配置
            middleware: [ 'errorHandler' ],
            
            // 自定义配置
            custom: {
                apiPrefix: '/api/v1',
                maxPageSize: 100
            },
            
            // 安全配置
            security: {
                csrf: {
                    enable: false // 根据需求开启
                }
            },
            
            // 数据库配置
            sequelize: {
                dialect: 'mysql',
                host: '127.0.0.1',
                port: 3306,
                database: 'egg_demo',
                username: 'root',
                password: 'password',
                timezone: '+08:00'
            }
        };
    };
    ```

2. config.local.js - 本地开发配置



    ```javascript
    // config/config.local.js
    module.exports = () => {
        return {
            // 覆盖默认配置
            sequelize: {
                password: 'dev_password'
            },
            
            // 本地开发特有配置
            logger: {
                level: 'DEBUG'
            }
        };
    };
    ```

3. config.prod.js - 生产环境配置


    ```javascript
    // config/config.prod.js
    module.exports = {
        // 生产环境配置
        sequelize: {
            host: 'mysql.prod.com',
            password: process.env.MYSQL_PASSWORD // 从环境变量读取
        },
        
        logger: {
            dir: '/logs/egg-app' // 生产环境日志目录
        },
        
        cluster: {
            listen: {
                port: 7001,
                hostname: '0.0.0.0'
            }
        }
    };
    ```

### 3.7.4 多环境配置合并规则

Egg.js 的配置合并遵循以下规则：

1.  先加载 `config.default.js`
    
2.  根据运行环境加载对应的配置（如 `config.prod.js`）
    
3.  最后加载 `config.local.js`（本地开发特有，不会被提交到代码库）
    

### 3.7.5 在应用中使用配置

1. 在 Controller 中使用

    ```javascript
    // app/controller/home.js
    const Controller = require('egg').Controller;

    class HomeController extends Controller {
        async config() {
            const { ctx } = this;
            
            // 获取配置
            const apiPrefix = ctx.app.config.custom.apiPrefix;
            const dbConfig = ctx.app.config.sequelize;
            
            // 安全考虑，不返回敏感配置
            ctx.body = {
            appName: ctx.app.config.appName,
            apiPrefix,
            dbConfig: {
                host: dbConfig.host,
                port: dbConfig.port,
                database: dbConfig.database
            }
            };
        }
    }

    module.exports = HomeController;
    ```

2. 在 Service 中使用


    ```javascript
    // app/service/user.js
    const Service = require('egg').Service;

    class UserService extends Service {
        async list() {
            const { app } = this;
            const pageSize = Math.min(
                this.ctx.query.pageSize || 10,
                app.config.custom.maxPageSize
            );
            
            return await this.ctx.model.User.findAll({
                limit: pageSize
            });
        }
    }

    module.exports = UserService;
    ```

3. 在 Middleware 中使用


    ```javascript
    // app/middleware/error_handler.js
    module.exports = (options, app) => {
        return async (ctx, next) => {
            try {
                await next();
            } catch (err) {
                // 根据配置决定是否记录错误详情
                if (app.config.env === 'prod') {
                    app.logger.error(err);
                } else {
                    app.logger.debug(err.stack);
                }
                
                ctx.status = err.status || 500;
                ctx.body = {
                    error: app.config.env === 'prod' 
                    ? 'Internal Server Error' 
                    : err.message
                };
            }
        };
    };
    ```

### 3.7.6 高级配置技巧

1. 动态配置


    ```javascript
    // config/config.default.js
    module.exports = appInfo => {
        const isDev = appInfo.env === 'local';
        
        return {
            custom: {
            // 开发环境使用本地API，生产环境使用远程API
            apiBaseUrl: isDev 
                ? 'http://localhost:3000/api'
                : 'https://api.example.com',
            
            // 根据应用名生成唯一标识
            instanceId: `${appInfo.name}-${process.pid}`
            }
        };
    };
    ```

2. 配置文件拆分

    - 对于大型项目，可以将配置拆分到多个文件：

        ```md
        config/
        |- config.default.js
        |- db.js
        |- redis.js
        |- security.js
        ```

    - 然后在主配置文件中引入：

        ```javascript
        // config/config.default.js
        const dbConfig = require('./db');
        const redisConfig = require('./redis');
        const securityConfig = require('./security');

        module.exports = appInfo => {
            return {
                ...dbConfig,
                ...redisConfig,
                ...securityConfig,
                // 其他配置...
            };
        };
        ```

3. 环境变量覆盖


    ```javascript
    // config/config.default.js
    module.exports = {
        redis: {
            client: {
            port: process.env.REDIS_PORT || 6379,
            host: process.env.REDIS_HOST || '127.0.0.1',
            password: process.env.REDIS_PASSWORD || '',
            db: process.env.REDIS_DB || 0
            }
        }
    };
    ```

### 3.7.7 插件配置

配置插件也非常简单，只需在配置文件中添加对应的配置项：



```javascript
// config/config.default.js
module.exports = {
    // egg-sequelize 插件配置
    sequelize: {
        dialect: 'mysql',
        host: '127.0.0.1',
        port: 3306,
        database: 'egg_demo'
    },
    
    // egg-redis 插件配置
    redis: {
        client: {
        port: 6379,
        host: '127.0.0.1',
        password: '',
        db: 0
        }
    },
    
    // egg-validate 插件配置
    validate: {
        convert: true,
        widelyUndefined: true
    }
};
```

### 3.7.8 实际应用案例

1. 多数据库配置

    ```javascript
    // config/config.default.js
    module.exports = {
        sequelize: {
            clients: {
                db1: {
                    dialect: 'mysql',
                    host: 'db1.example.com',
                    database: 'app_db1'
                },
                db2: {
                    dialect: 'postgres',
                    host: 'db2.example.com',
                    database: 'app_db2'
                }
            },
            default: {
                dialect: 'mysql',
                host: 'default.db.example.com',
                database: 'app_main'
            }
        }
    };

    // 在Service中使用指定数据库
    async queryFromDb1() {
        return await this.app.modelDb1.query(...);
    }
    ```

2. 微服务端点配置


    ```javascript
    // config/config.default.js
    module.exports = {
        microservices: {
            userService: {
                endpoint: 'http://user-service.example.com/api',
                timeout: 3000
            },
            orderService: {
                endpoint: 'http://order-service.example.com/api',
                timeout: 5000
            }
        }
    };

    // 在Service中使用
    async getUserInfo(userId) {
        const { endpoint, timeout } = this.config.microservices.userService;
        return await this.ctx.curl(`${endpoint}/users/${userId}`, {
            timeout,
            dataType: 'json'
        });
    }
    ```

3. 功能开关配置

    ```javascript
    // config/config.default.js
    module.exports = {
        featureFlags: {
            newPaymentGateway: false,
            experimentalSearch: true,
            maintenanceMode: false
        }
    };

    // 在Middleware中使用
    module.exports = (options, app) => {
        return async (ctx, next) => {
            if (app.config.featureFlags.maintenanceMode) {
            ctx.status = 503;
            ctx.body = '系统维护中，请稍后再试';
            return;
            }
            await next();
        };
    };
    ```

## 3.8 Logger（日志对象）

### 3.8.1 介绍

Logger 是框架内置的日志功能。

1. 特点
    *   多级日志（debug/info/warn/error）
    *   多环境适配
    *   多种传输方式
        
2. 日志类型

    ```javascript
    // 应用日志
    app.logger.info('some message');

    // 上下文日志（会自动记录请求信息）
    ctx.logger.warn('some warning');

    // 核心日志（框架内部使用）
    app.coreLogger.error('some error');
    ```

3. 配置示例

    ```js
    // config/config.default.js
    exports.logger = {
        level: 'INFO',
        consoleLevel: 'DEBUG',
    };
    ```



### 3.8.2 基础日志记录

1. 不同日志级别

    ```javascript
    // app/controller/home.js
    const Controller = require('egg').Controller;

    class HomeController extends Controller {
        async index() {
            const { ctx } = this;
            
            // 不同级别的日志
            ctx.logger.debug('Debug message - only visible in local env');
            ctx.logger.info('Request from IP: %s', ctx.ip);
            ctx.logger.warn('Warning message: something unusual happened');
            ctx.logger.error(new Error('Something wrong'));
            
            ctx.body = { message: 'Check your logs' };
        }
    }

    module.exports = HomeController;
    ```

2. 应用日志 vs 上下文日志

    ```javascript
    async logExample() {
        const { ctx, app } = this;
        
        // 应用日志 (app.logger)
        app.logger.info('Application level log');
        
        // 上下文日志 (ctx.logger) - 会自动附加请求信息
        ctx.logger.info('Context level log with request info');
        
        // 核心日志 (app.coreLogger) - 框架内部使用
        app.coreLogger.info('Core framework log');
    }
    ```

### 3.8.3 日志配置

1. 基本配置


    ```javascript
    // config/config.default.js
    module.exports = {
        logger: {
            // 日志级别，生产环境建议 INFO
            level: 'INFO',
            
            // 控制台日志级别，默认同 level
            consoleLevel: 'DEBUG',
            
            // 日志目录
            dir: '/path/to/your/logs',
            
            // 单个日志文件大小，超过后会自动切割
            fileSize: '100MB',
            
            // 保留的日志文件数
            filesRotate: 30,
            
            // 是否禁用日志文件输出
            disableFile: false,
            
            // 是否禁用控制台输出
            disableConsole: false
        }
    };
    ```

2. 环境特定配置

    ```javascript
    // config/config.local.js
    module.exports = {
        logger: {
            level: 'DEBUG', // 本地开发环境显示更详细日志
            consoleLevel: 'DEBUG'
        }
    };

    // config/config.prod.js
    module.exports = {
        logger: {
            level: 'WARN', // 生产环境只记录警告及以上级别
            consoleLevel: 'INFO',
            dir: '/var/log/myapp' // 生产环境日志目录
        }
    };
    ```

### 3.8.4 高级日志功能

1. 自定义日志文件


    ```javascript
    // config/config.default.js
    module.exports = {
        customLogger: {
            bizLogger: {
            file: 'biz.log', // 文件名
            level: 'INFO',   // 日志级别
            consoleLevel: 'DEBUG'
            },
            dbLogger: {
            file: 'db.log',
            level: 'DEBUG'
            }
        }
    };

    // 在应用中使用自定义日志
    async businessOperation() {
        const { ctx } = this;
        
        // 记录业务日志
        ctx.getLogger('bizLogger').info('Business operation started');
        
        try {
            // 数据库操作
            await ctx.model.User.create({ /* ... */ });
            ctx.getLogger('dbLogger').debug('User created');
        } catch (err) {
            ctx.getLogger('bizLogger').error('Operation failed', err);
            throw err;
        }
    }
    ```

2. 日志上下文



    ```javascript
    async userAction() {
        const { ctx } = this;
        
        // 添加上下文信息
        ctx.logger.addContext('userId', ctx.user.id);
        ctx.logger.addContext('requestId', ctx.requestId);
        
        ctx.logger.info('User performed action');
        
        // 日志输出示例:
        // [2023-01-01 12:00:00.000][INFO][app-name] User performed action 
        // (userId=123, requestId=abcd1234)
    }
    ```

3. 错误日志记录

    ```javascript
    async riskyOperation() {
        const { ctx } = this;
        
        try {
            // 可能失败的操作
            await ctx.service.external.call();
        } catch (err) {
            // 记录完整错误堆栈
            ctx.logger.error('External call failed', err);
            
            // 自定义错误信息
            ctx.logger.error({
                message: 'External call failed',
                error: err.message,
                stack: err.stack,
                request: {
                    method: ctx.method,
                    url: ctx.url,
                    body: ctx.request.body
                }
            });
            
            ctx.throw(500, 'Service unavailable');
        }
    }
    ```

### 3.8.5 日志实践案例

1. 请求日志中间件

    ```javascript
    // app/middleware/request_logger.js
    module.exports = () => {
        return async (ctx, next) => {
            const start = Date.now();
            
            try {
                await next();
                
                // 记录请求完成日志
                ctx.logger.info(
                    '[%s %s] %s %s - %s ms',
                    ctx.method,
                    ctx.status,
                    ctx.url,
                    ctx.request.ips.length ? ctx.request.ips.join(', ') : ctx.ip,
                    Date.now() - start
                );
            } catch (err) {
                // 记录错误日志
                ctx.logger.error(
                    '[%s %s] %s %s - %s ms - Error: %s',
                    ctx.method,
                    err.status || 500,
                    ctx.url,
                    ctx.request.ips.length ? ctx.request.ips.join(', ') : ctx.ip,
                    Date.now() - start,
                    err.message
                );
                
                throw err;
            }
        };
    };

    // config/config.default.js
    module.exports = {
        middleware: [ 'requestLogger' ]
    };
    ```

2. 数据库查询日志

    ```javascript
    // app.js
    module.exports = app => {
        if (app.config.env === 'local') {
            // 开发环境下记录所有SQL查询
            app.on('query', data => {
            app.getLogger('dbLogger').debug(
                '[SQL] %s %s %s',
                data.sql,
                data.bindings,
                `(${data.executionTime}ms)`
            );
            });
        }
    };
    ```

3. 性能监控日志


    ```javascript
    // app/service/performance.js
    const Service = require('egg').Service;

    class PerformanceService extends Service {
        async monitor() {
            const { ctx, app } = this;
            const logger = ctx.getLogger('perfLogger');
            
            // 记录内存使用
            logger.info('Memory usage: %j', process.memoryUsage());
            
            // 记录系统负载
            const load = await this.getSystemLoad();
            logger.info('System load: %j', load);
            
            // 记录响应时间统计
            const stats = await this.getResponseTimeStats();
            logger.info('Response time stats: %j', stats);
        }
        }

        module.exports = PerformanceService;

        // 在定时任务中调用
        // app/schedule/monitor.js
        module.exports = {
        schedule: {
            interval: '1m',
            type: 'worker'
        },
        async task(ctx) {
            await ctx.service.performance.monitor();
        }
    };
    ```

### 3.8.6 日志分析建议

1.  **结构化日志**：

    ```javascript
    ctx.logger.info({
        event: 'user_login',
        userId: 123,
        ip: ctx.ip,
        success: true,
        timestamp: new Date()
    });
    ```
    
2.  **日志分类**：
    
    *   访问日志 (access.log)
    *   错误日志 (error.log)
    *   业务日志 (biz.log)
    *   数据库日志 (sql.log)
        
3.  **日志收集**：
    
    *   使用 ELK (Elasticsearch, Logstash, Kibana) 堆栈
    *   或使用阿里云 SLS、腾讯云 CLS 等日志服务

### 3.8.7 生产环境日志实践

1. 敏感信息过滤


    ```javascript
    // app/extend/context.js
    module.exports = {
        // 过滤敏感信息的日志方法
        safeLogger() {
            const ctx = this;
            const sensitiveFields = ['password', 'token', 'creditCard'];
            
            return {
                info(message, ...args) {
                    ctx.logger.info(this.filterSensitive(message), ...args);
                },
                // 其他级别方法...
                filterSensitive(obj) {
                    if (typeof obj !== 'object') return obj;
                    
                    const filtered = { ...obj };
                    sensitiveFields.forEach(field => {
                        if (filtered[field]) {
                            filtered[field] = '******';
                        }
                    });
                    return filtered;
                }
            };
        }
    };

    // 使用示例
    ctx.safeLogger().info({
        action: 'user_register',
        user: {
            username: 'test',
            password: '123456' // 会被过滤成 ******
        }
    });
    ```

2. 日志报警


    ```javascript
    // app.js
    module.exports = app => {
        app.on('error', (err, ctx) => {
            // 记录错误日志
            app.logger.error(err);
            
            // 生产环境发送报警
            if (app.config.env === 'prod') {
                app.service.alert.send({
                    type: 'error',
                    message: err.message,
                    stack: err.stack,
                    request: ctx ? {
                    method: ctx.method,
                    url: ctx.url,
                    ip: ctx.ip
                    } : null
                });
            }
        });
    };
    ```

### 3.8.8 总结

1. Egg.js 的 Logger 对象提供了强大的日志功能：
    1.  **多级别日志**：debug/info/warn/error
    2.  **多种日志类型**：应用日志、上下文日志、核心日志
    3.  **灵活配置**：支持环境特定配置和自定义日志
    4.  **丰富功能**：上下文信息、错误堆栈、结构化日志
        

2. 通过合理使用 Logger，你可以：
    *   更好地监控应用运行状态
    *   快速定位和解决问题
    *   分析用户行为和系统性能
    *   满足审计和安全合规要求
        
