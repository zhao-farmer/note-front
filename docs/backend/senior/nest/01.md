# 一、前置知识

## 1.1 介绍nest.js

1. next.js 特点

    Nestjs 是一个用于构建高效可扩展的一个基于Node js 服务端 应用程序开发框架

    并且完全支持typeScript  结合了 AOP 面向切面的编程方式

    nestjs 还是一个spring MVC 的风格 其中有依赖注入 IOC 控制反转 都是借鉴了Angualr

    nestjs 的底层代码运用了 express 和  Fastify 在他们的基础上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员。这样可以轻松使用每个平台的无数第三方模块

    nestjs 英文官网 [NestJS - A progressive Node.js framework](https://nestjs.com/)

    nestjs 中文网  [NestJS 简介 | NestJS 中文文档 | NestJS 中文网](https://nestjs.bootcss.com/)

    nestjs 中文网2  [Nest.js 中文文档](https://docs.nestjs.cn/)

2.  nestjs内置框架express 默认express

    能够快速构建服务端应用程序，且学习成本非常低，容易上手

     express 文档[Express - 基于 Node.js 平台的 web 应用开发框架 - Express 中文文档 | Express 中文网](https://www.expressjs.com.cn/ "Express - 基于 Node.js 平台的 web 应用开发框架 - Express 中文文档 | Express 中文网")

3. nestjs唯二内置框架 Fastify

    *   **高性能：** 据我们所知，Fastify 是这一领域中最快的 web 框架之一，另外，取决于代码的复杂性，Fastify 最多可以处理每秒 3 万次的请求。
    *   **可扩展：** Fastify 通过其提供的钩子（hook）、插件和装饰器（decorator）提供完整的可扩展性。
    *   **基于 Schema：** 即使这不是强制性的，我们仍建议使用 [JSON Schema](http://json-schema.org/) 来做路由（route）验证及输出内容的序列化，Fastify 在内部将 schema 编译为高效的函数并执行。
    *   **日志：** 日志是非常重要且代价高昂的。我们选择了最好的日志记录程序来尽量消除这一成本，这就是 [Pino](https://github.com/pinojs/pino)!
    *   **对开发人员友好：** 框架的使用很友好，帮助开发人员处理日常工作，并且不牺牲性能和安全性。
    *   **支持 TypeScript：** 我们努力维护一个 [TypeScript](https://www.typescriptlang.org/) 类型声明文件，以便支持不断成长的 TypeScript 社区。

## 1.2 控制翻转与依赖注入

1. 设计模式

    - IOC
        Inversion of Control字面意思是控制反转，具体定义是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

    - DI
        依赖注入（Dependency Injection）其实和IoC是同根生，这两个原本就是一个东西，只不过由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”。 类A依赖类B的常规表现是在A中使用B的instance。

2. 未使用控制反转和依赖注入之前的代码

    ```js
    class A {
        name: string
        constructor(name: string) {
            this.name = name
        }
    }


    class B {
        age:number
        entity:A
        constructor (age:number) {
            this.age = age;
            this.entity = new A('zhangsan')
        }
    }

    const c = new B(18)

    console.log(c.entity.name);
    ```

    我们可以看到，B 中代码的实现是需要依赖 A 的，两者的代码耦合度非常高。当两者之间的业务逻辑复杂程度增加的情况下，维护成本与代码可读性都会随着增加，并且很难再多引入额外的模块进行功能拓展。

3. 使用ioc 控制容器

    ```js
    class A{
        name: string
        constructor(name:string){
            this.name = name
        }
    }

    class C{
        name:string
        constructor(name:string){
            this.name = name
        }
    }

    // 中间件用于解耦
    class Container{
        modeuls:any
        constructor(){
            this.modeuls = {}
        }

        provide(key:string,modeul:any){
            this.modeuls[key] = modeul
        }

        get(key:string){
            return this.modeuls[key]
        }
    }



    const mo = new Container()
    mo.provide("a",new A("zhangsan"))
    mo.provide("a",new C("lisi"))
    // 在引入ioc容器 container之后，B和A的代码逻辑已经解耦，
    // 可以单独扩展其他功能，也可以方便的加入其他模块C
    // 所以在面对复杂的后端业务逻辑中，引入ioc可以降低组件之间的耦合度
    // 实现系统各层之间的解耦

    class B{
        a:any
        c:any
        constructor(container:Container){
            this.a = container.get("a")
            this.c = container.get("c")
        }
    }

    new B(mo)
    ```


## 1.3 ts装饰器

### 1.3.1 四种装饰器

1. 什么是装饰器

    装饰器是一种特殊的类型声明，他可以附加在类，方法，属性，参数上面

    装饰器写法 **tips（需要开启一项配置）**

    ![](/backend/senior/nest/001.png)

2. 类装饰器 主要是通过@符号添加装饰器

    他会自动把class的构造函数传入到装饰器的第一个参数 target

    然后通过prototype可以自定义添加属性和方法

    ```typescript
    function decotators1 (target:any) {
        target.prototype.name = 'zhangsan'
    }
    
    @decotators1
    class Test1 {

        constructor () {
    
        }
    }
    
    const test1:any = new Test1()
    console.log(test1.name) // zhangsan
    ```

3. 属性装饰器

    同样使用@符号给属性添加装饰器,它会返回两个参数

    1. 原形对象

    2. 属性的名称

    ```typescript
    const decotators2: PropertyDecorator = (target: any, key: string | symbol) => {
        console.log(target, key)
    }
    
    
    class Test2 {
        @decotators2
        public name: string 
        constructor() {
            this.name = ''
        }
        getName() {
            return this.name
        }
    }

    //结果：{} name
    ```

4.  参数装饰器

    同样使用@符号给属性添加装饰器，它会返回三个参数

    1. 原形对象
    2. 方法的名称
    3. 参数的位置从0开始

    ```typescript
    const currency4: ParameterDecorator = (target: Object, key: string | symbol | undefined, index: number) => {
        console.log(target, key,index)
    }
    
    
    class Test4 {
        public name: string
        constructor() {
            this.name = ''
        }
        getName(name:string,@currency4 age:number) {
            return this.name
        }
    }
    
    //结果：{} getName 1
    ```


4. 方法装饰器 

    同样使用@符号给属性添加装饰器，它会返回三个参数

    1. 原形对象

    2. 方法的名称

    3. 属性描述符  可写对应writable，可枚举对应enumerable，可配置对应configurable


    ```typescript
    const decotators3: MethodDecorator = (target: any, key: string | symbol,descriptor:any) => {
        console.log(target, key,descriptor)
    }
    
    
    class Test3 {
        public name: string
        constructor() {
            this.name = ''
        }
        @decotators3
        getName(name:string,age:number) {
            return this.name
        }
    }
    //结果：{} getName { value: [Function: getName],...}
    ```

### 1.3.2 装饰器实现get请求

1. 实现步骤

    1. 安装依赖npm install axios -S

    2. 定义控制器 Controller

    2. 定义装饰器

    3. 这时候需要使用装饰器工厂

    4. 应为装饰器默认会塞入一些参数

    5. 定义 descriptor 的类型 通过 descriptor描述符里面的value 把axios的结果返回给当前使用装饰器的函数

2. 实现代码

    ```js
    import axios from 'axios'

 
    const Get = (url: string): MethodDecorator => {
        return (target, key, descriptor: PropertyDescriptor) => {
            const fnc = descriptor.value;
            axios.get(url).then(res => {
                fnc(res, {
                    status: 200,
                })
            }).catch(e => {
                fnc(e, {
                    status: 500,
                })
            })
        }
    }
    
    //定义控制器
    class Controller {
        constructor() {
    
        }
        @Get('https://api.apiopen.top/api/getHaoKanVideo?page=0&size=10')
        getList (res: any, status: any) {
            console.log(res.data.result.list, status)
        }
    }
    ```

