# 二、核心

## 2.1 工程介绍


1. 通过cli创建nestjs项目

    ```sh
    # 全局安装构建组件
    npm i -g @nestjs/cli
    # 创建新项目
    nest new [项目名称]
    ```

2. 启动项目 

    我们需要热更新就启动npm run start:dev就可以了

    ```json
    {
        "start": "nest start",
        "start:dev": "nest start --watch",
        "start:debug": "nest start --debug --watch",
        "start:prod": "node dist/main",
    }
    ```

## 2.2 目录介绍

1. 程序入口
    - main.ts 入口文件主文件 类似于vue 的main.ts
    - 通过 `NestFactory.create(AppModule)` 创建一个app  就是类似于绑定一个根组件App.vue
    - app.listen(3000); 监听一个端口

    ```javascript
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';

    async function bootstrap() {
        const app = await NestFactory.create(AppModule);
        await app.listen(3000);
    }
    bootstrap();
    ```

2. Controller.ts 控制器

    - 控制层，直接向后端提供接口

    - `private readonly appService: AppService` 这一行代码就是**依赖注入**不需要实例化  appService 它内部会自己实例化的我们主需要放上去就可以了

    ```typescript
    import { Controller, Get } from '@nestjs/common';
    import { AppService } from './app.service';

    @Controller()
    export class AppController {
        constructor(private readonly appService: AppService) {}

        @Get()
        getHello(): string {
            return this.appService.getHello();
        }
    }

    //-----------------------------------------------------
    //修改地址之后

    import { Controller, Get } from '@nestjs/common';
    import { AppService } from './app.service';

    @Controller('/get')
    export class AppController {
        constructor(private readonly appService: AppService) {}

        @Get('/hello')
        getHello(): string {
            return this.appService.getHello();
        }
    }
    ```

3. app.service.ts

    - 业务层 当然Controller可以实现逻辑，但是就是单一的无法复用，放到app.service有别的模块也需要就可以实现复用
    - @Injectable注解，用于 controller、service 依赖注入

    ```typescript
    import { Injectable } from '@nestjs/common';

    @Injectable()
    export class AppService {
        getHello(): string {
            return 'Hello World!';
        }
    }
    ```

## 2.3 常用命令


1. 查看命令

    - `nest --help` 可以查看nestjs所有的命令
    - 它的命令和 angular 很像


    ![](/backend/senior/nest/002.png)

    │ 名称          │ 别名         │ 描述                        │
    │ application   │ application │ 生成一个新的应用工作区               │
    │ class         │ cl          │ 生成一个新的类                      │
    │ configuration │ config      │ 生成CLI配置文件                     │
    │ controller    │ co          │ 生成控制器声明                      │
    │ decorator     │ d           │ 生成自定义装饰器                    │
    │ filter        │ f           │ 生成过滤器声明                      │
    │ gateway       │ ga          │ 生成网关声明                        │
    │ guard         │ gu          │ 生成守卫声明                        │
    │ interceptor   │ itc         │ 生成拦截器声明                      │
    │ interface     │ itf         │ 生成接口                            │
    │ library       │ lib         │ 在monorepo中生成新库                │
    │ middleware    │ mi          │ 生成中间件声明                      │
    │ module        │ mo          │ 生成模块声明                        │
    │ pipe          │ pi          │ 生成管道声明                        │
    │ provider      │ pr          │ 生成提供者声明                      │
    │ resolver      │ r           │ 生成GraphQL解析器声明               │
    │ resource      │ res         │ 生成新的CRUD资源                    │
    │ service       │ s           │ 生成服务声明                        │
    │ sub-app       │ app         │ 在monorepo中生成新应用              │


2. 单项生成

    1. 生成controller.ts

    ```sh
    # 完整命令
    nest g controller user
    # 简化的命令
    nest g co user
    ```

    2. 生成  module.ts

    ```sh
    nest g mo user
    ```

    3. 生成service.ts

    ```sh
    nest g s user
    ```

    4. 运行结果

        ![](/backend/senior/nest/003.png)

3. 一个命令生成

    - 输入命令

        ```sh
         nest g resource test
        ```
    - 选择 REST API
    - 运行结果

         ![](/backend/senior/nest/004.png)

4. 出现了 Delete `cr` 问题

    1. 配置 .prettierrc

        ```json
        {
            "endOfLine":"auto"
        }
        ```
    2. 配置 eslint.config.mjs

        
        ```js
        rules: {
            'prettier/prettier': ['error', { endOfLine: 'auto' }],
        }
        ```

## 2.4 restful 风格设计

RESTful 是一种风格，在RESTful中，一切都被认为是资源，每个资源有对应的URL标识.

不是标准也不是协议，只是一种风格。当然你也可以不按照他的风格去写。

1. 接口url

    - **传统接口**

        - `http://localhost:8080/api/get_list?id=1` 查询

        - `http://localhost:8080/api/delete_list?id=1` 删除

        - `http://localhost:8080/api/update_list?id=1` 更新

    - **RESTful接口**

        - `http://localhost:8080/api/get\_list/1`

        - RESTful 风格一个接口就会完成 增删改差 他是通过不同的请求方式来区分的
            - 查询GET
            - 提交POST
            - 更新 PUT PATCH
            - 删除 DELETE

        - 页面中展示

            ![](/backend/senior/nest/005.png)

2. RESTful 版本控制 

    一共有三种我们一般用第一种 更加语义化

    |  版本控制类型   |  描述   |
    | --- | --- |
    | `URI Versioning` | 版本将在请求的 URI 中传递（默认） |
    | `Header Versioning` | 自定义请求标头将指定版本 |
    | `Media Type Versioning` | 请求的`Accept`标头将指定版本 |


    - 启动类配置

        ```javascript
        import { NestFactory } from '@nestjs/core';
        // 导入版本控制
        import { VersioningType } from '@nestjs/common';
        import { AppModule } from './app.module';

        async function bootstrap() {
            const app = await NestFactory.create(AppModule);
            // 版本控制模式
            app.enableVersioning({
                type: VersioningType.URI,
            })
            await app.listen(3000);
        }
        bootstrap();
        ```

    - 然后在user.controller 配置版本 Controller 变成一个对象 通过version 配置版本

        ```typescript
        import { Controller, Get, Post, Body, Patch, Param, Delete, Version } from '@nestjs/common';
        import { UserService } from './user.service';
        import { CreateUserDto } from './dto/create-user.dto';
        import { UpdateUserDto } from './dto/update-user.dto';

        // 加入版本控制
        @Controller({
            path:"user",
            version:'1'
        })
        export class UserController {
            constructor(private readonly userService: UserService) {}

            @Post()
            create(@Body() createUserDto: CreateUserDto) {
                return this.userService.create(createUserDto);
            }

            @Get()
            // @Version('1')
            findAll() {
                return this.userService.findAll();
            }

            @Get(':id')
            findOne(@Param('id') id: string) {
                return this.userService.findOne(+id);
            }

            @Patch(':id')
            update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
                return this.userService.update(+id, updateUserDto);
            }
        }
        ```
    - 运行结果

        ![](/backend/senior/nest/006.png)

3. Code码规范

    - 200 OK
    - 400 Bad Request 参数错误
    - 401 token错误
    - 403 Forbidden referer origin 验证失败
    - 404 Not Found 接口不存在
    - 500 Internal Server Error 服务端错误
    - 502 Bad Gateway 上游接口有问题或者服务器问题

## 2.5 controller中一些配置


1. 装饰器和它们所代表的相应平台特定对象的列表

    | 参数注解                 | 列表对象                        |
    |-------------------------|---------------------------------|
    | @Request(), @Req()      | req                             |
    | @Response(), @Res()*    | res                             |
    | @Next()                 | next                            |
    | @Session()              | req.session                     |
    | @Param(key?: string)    | req.params / req.params[key]    |
    | @Body(key?: string)     | req.body / req.body[key]        |
    | @Query(key?: string)    | req.query / req.query[key]      |
    | @Headers(name?: string) | req.headers / req.headers[name] |
    | @Ip()                   | req.ip                          |
    | @HostParam()            | req.hosts                       |


2. 实战测试

    - 新建controller

        ```sh
        nest g controller test
        ```
    - 代码

        ```ts
        import {
            Controller,
            Req,
            Query,
            Body,
            Headers,
            HttpCode,
            Get,
            Param,
        } from '@nestjs/common';
        // 这里很重要，官网都是错的
        import type { Request } from 'express';

        @Controller('test')
        export class TestController {
            // get请求测试 @Request
            @Get('getTestRequest')
            getTestRequest(@Req() req: Request) {
                console.log(req.query);
                return '';
            }

            // get请求测试 @Query
            @Get('getTestQuery')
            getTestQuery(@Query() req: string) {
                console.log(req);
                return '';
            }

            // post请求测试 @Request
            @Get('postTestRequest')
            postTestRequest(@Req() req: Request) {
                console.log(req.body);
                return '';
            }

            // post请求测试 @Query
            @Get('postTestBody')
            postTestBody(@Body() req: object) {
                console.log(req);
                return '';
            }

            // url路径中参数
            @Get('getTestParam/:id')
            getTestParam(@Param('id') id: string) {
                console.log(id);
                return '';
            }

            // 获取header信息
            @Get('getHeaders/:id')
            getHeaders(@Headers() header) {
                console.log(header);
                return {
                    code: 200,
                };
            }

            // 直接返回状态码
            @Get('getStatusCode/:id')
            @HttpCode(500)
            getStatusCode(@Headers() header) {
                return {
                    code: 500,
                };
            }
        }
        ```
    - 容易出现的问题

        - 错误类型： `导入“Request”与此文件中使用的全局值冲突，因此在启用“isolatedModules”时必须使用仅类型导入进行声明。`

        - 解决方案 一定要加type

            ```ts
            import type { Request } from 'express';
            ```

## 2.6 session 

### 2.6.1 服务端

1. 安装插件

    ```sh
    # 安装session
    npm install express-session
    npm install @types/express-session --save-dev
    # 安装svg验证图层
    npm install svg-captcha
    ```

2. 初始化sesssion main.ts

    ```js
    // 引入session
    import session from 'express-session';

    // 调用启动项
    app.use(
        session({
        secret: 'your-secret-key', // 用于签名 session ID 的密钥
        resave: false, // 强制保存未修改的 session
        saveUninitialized: false, // 强制保存未初始化的 session
        cookie: {
            maxAge: 3600000, // cookie 过期时间 (1小时)
            secure: process.env.NODE_ENV === 'production', // 生产环境下使用 HTTPS
        },
        }),
    );
    ```
3. 登录页面设置

    - 创建登录controller

        ```sh
        nest g controller login
        ```
    - 修改代码 login.controller.ts

        ```ts
        import { Controller, Res, Body, Post, Get, Session } from '@nestjs/common';
        import type { Response } from 'express';

        import * as svgCaptcha from 'svg-captcha';

        @Controller('login')
        export class LoginController {
            @Get('code')
            createCaptcha(@Session() session: Record<string, any>, @Res() res: Response) {
                const options = {
                    size: 4, // 验证码长度
                    ignoreChars: '0o1i', // 排除容易混淆的字符
                    noise: 2, // 干扰线数量
                    color: true, // 彩色验证码
                    background: '#cc9966', // 背景色
                    width: 100, // 宽度
                    height: 40, // 高度
                    fontSize: 50, // 字体大小
                };

                const captcha = svgCaptcha.create(options);
                session.code = captcha.text; //存储验证码记录到session
                res.type('image/svg+xml');
                res.send(captcha.data);
            }

            @Post('create')
            createUser(
                @Body() body: Record<string, any>,
                @Session() session: Record<string, any>,
            ) {
                console.log(session.code, body);
                if (session.code.toLocaleLowerCase() === body?.code?.toLocaleLowerCase()) {
                    return {
                        message: '验证码正确',
                    };
                } else {
                return {
                    message: '验证码错误',
                };
                }
            }
        }

        ```

4. 接口调用结果

    ![](/backend/senior/nest/007.png)

### 2.6.2 客户端

1. 创建项目

    ```sh
    npm create vue@latest
    ```
2. 安装插件

    ```
    npm install element-plus -S
    ```
3. 启用element-plus main.js

    ```js
    import { createApp } from 'vue'
    import ElementPlus from 'element-plus'
    import 'element-plus/dist/index.css'
    import App from './App.vue'

    const app = createApp(App)

    app.use(ElementPlus)
    app.mount('#app')
    ```

4. 设置代理 vite.config.js

    ```js
    server: {
        proxy: {
            "/api": {
                target: "http://localhost:3006/",
                changeOrigin: true,
                rewrite: path => path.replace(/^\/api/, ""),
            },
        },
    },
    ```

5. App.vue代码

    ```vue
    <template>
        <div class="wraps">
            <el-form ref="ruleFormRef" style="max-width: 600px" :model="ruleForm" status-icon label-width="auto" class="demo-ruleForm">
                <el-form-item label="账号" prop="username">
                    <el-input v-model="ruleForm.username" autocomplete="off" />
                </el-form-item>
                <el-form-item label="密码" prop="password">
                    <el-input v-model="ruleForm.password" type="password" autocomplete="off" />
                </el-form-item>
                <el-form-item label="验证码" prop="code">
                    <div style="display: flex">
                        <el-input v-model="ruleForm.code" />
                        <img @click="resetCode" :src="codeUrl" alt="" />
                    </div>
                </el-form-item>
                <el-form-item>
                    <el-button type="primary" @click="submit()"> 登录 </el-button>
                </el-form-item>
            </el-form>
        </div>
    </template>

    <script setup lang="ts">
    import { reactive, ref } from "vue";

    const codeUrl = ref<string>("/api/login/code");

    const resetCode = () => (codeUrl.value = codeUrl.value + "?" + Math.random());

    const ruleForm = reactive({
        username: "",
        password: "",
        code: "",
    });

    const submit = async () => {
        await fetch("/api/login/create", {
            method: "POST",
            body: JSON.stringify(ruleForm),
            headers: {
                "content-type": "application/json",
            },
        }).then(res => res.json());
    };
    </script>

    <style>
    * {
        padding: 0;
        margin: 0;
    }

    .wraps {
        display: flex;
        justify-content: center;
        align-items: center;
        height: inherit;
    }

    html,
    body,
    #app {
        height: 100%;
    }
    </style>
    ```
6. 运行结果

    ![](/backend/senior/nest/008.png)

## 2.7 providers 提供者

1. 介绍

    - 服务类使用@Injectable()装饰器装饰，表明该类可以由Nest的IoC容器管理
    - 服务需要在对应的module中进行注册，如果不注册IoC容器是不会帮你创建对象的，而且还会报错
    - 在其它类中使用时（如Controller控制器中），在该类的构造函数的参数中进行注入(后面也会讲通过属性注入的方法)
        
        强调一下这里的依赖注入，可以看到是通过类构造函数来的， constructor(private readonly userService: UserService) {}，Nest提供了IoC容器利用Typescript自带类型的特点自动创建对象的能力，注意这里是单例模式，如果该Service在其它地方也被用过，那么会在不会重新创建对象，各个应用只会有一个该Service的对象，容器会先寻找当前有没有，如果没有再进行创建。

    - 生命周期：默认情况下随着整个应用的启动而产生，随着应用的关闭而销毁，但是也可以自定义，可以随着请求的生命周期进行调整

2. 文件类型

    - 新建资源curd

        ```sh
        nest g resource flow
        ```
    - 文件介绍

        ![](/backend/senior/nest/009.png)

    - 调用流程

        ![](/backend/senior/nest/010.png)

3. 类引入
 
    - service

        ```ts
        import { Injectable } from '@nestjs/common';

        @Injectable()
        export class FlowService {
            test01() {
                return 'test01';
            }
            test02() {
                return 'test02';
            }
        }
        ```
    - module

        ```ts
        import { Module } from '@nestjs/common';
        import { FlowService } from './flow.service';
        import { FlowController } from './flow.controller';

        @Module({
            // controller 加入进来
            controllers: [FlowController],
            // service加入进来
            providers: [
                // 基础类注册
                FlowService,
                // 别名类注册
                {
                    provide: 'otherName',
                    useClass: FlowService,
                },
            ],
        })
        export class FlowModule {}
        ```
    - controller

        ```ts
        import { Controller, Get, Inject } from '@nestjs/common';
        import { FlowService } from './flow.service';

        @Controller('flow')
        export class FlowController {
        constructor(
            // 直接注入
            private readonly flowService: FlowService,
            // 别名注入
            @Inject('otherName') private readonly flowService2: FlowService,
        ) {}

        @Get('test1')
            findAll() {
                // 返回数据
                const data = {
                    test1: this.flowService.test01(),
                    test2: this.flowService2.test02(),
                };

                return data;
            }
        }
        ```
        
4. 值引入

    - module

        ```ts
        import { Module } from '@nestjs/common';
        import { FlowService } from './flow.service';
        import { FlowController } from './flow.controller';

        @Module({
        // controller 加入进来
        controllers: [FlowController],
        // service加入进来
        providers: [
            // 基础类注册
            FlowService,
            // 别名类注册
            {
                provide: 'otherName',
                useClass: FlowService,
            },
            // 值注册
            {
                provide: 'ds',
                useValue: ['TB', 'PDD', 'JD'],
            },
        ],
        })
        export class FlowModule {}

        ```

    - controller

        ```ts
        import { Controller, Get, Inject } from '@nestjs/common';
        import { FlowService } from './flow.service';

        @Controller('flow')
        export class FlowController {
            constructor(
                // 类直接注入
                private readonly flowService: FlowService,
                // 别名注入
                @Inject('otherName') private readonly flowService2: FlowService,
                // 值注入
                @Inject('ds') private readonly shopList: string[],
            ) {}

            @Get('test1')
            findAll() {
                // 返回数据
                const data = {
                    test1: this.flowService.test01(),
                    test2: this.flowService2.test02(),
                    test3: this.shopList,
                };

                return data;
            }
        }
        ```

5. 工厂模式

    - service

        ```ts
        import { Injectable } from '@nestjs/common';

        @Injectable()
        export class FlowService {
            test01() {
                return 'test01';
            }
            test02() {
                return 'test02';
            }
            test03() {
                return 'test03';
            }
            test04() {
                return 'test04';
            }
        }
        ```
    - module

        ```ts
        import { Module } from '@nestjs/common';
        import { FlowService } from './flow.service';
        import { FlowController } from './flow.controller';

        @Module({
        // controller 加入进来
        controllers: [FlowController],
        // service加入进来
        providers: [
            // 基础类注册
            FlowService,
            // 别名类注册
            {
                provide: 'otherName',
                useClass: FlowService,
            },
            // 值注册
            {
                provide: 'ds',
                useValue: ['TB', 'PDD', 'JD'],
            },
            // 工厂模式
            {
                provide: 'factory1',
                inject: [FlowService],
                useFactory(flowService: FlowService) {
                    return flowService.test03();
                },
            },
            // 异步工厂模式
            {
                provide: 'factory2',
                inject: [FlowService],
                async useFactory(flowService: FlowService) {
                    return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(flowService.test04());
                    }, 2000);
                    });
                },
            },
        ],
        })
        export class FlowModule {}

        ```
    - controller

        ```ts
        import { Controller, Get, Inject } from '@nestjs/common';
        import { FlowService } from './flow.service';

        @Controller('flow')
        export class FlowController {
            constructor(
                // 直接注入
                private readonly flowService: FlowService,
                // 别名注入
                @Inject('otherName') private readonly flowService2: FlowService,
                // 值注入
                @Inject('ds') private readonly shopList: string[],
                // 工厂模式注入
                @Inject('factory1') private readonly factory1: string,
                // 异步工厂模式
                @Inject('factory2') private readonly factory2: string,
            ) {}

            @Get('test1')
            findAll() {
                // 返回数据
                const data = {
                    test1: this.flowService.test01(),
                    test2: this.flowService2.test02(),
                    test3: this.shopList,
                    test4: this.factory1,
                    test5: this.factory2,
                };
                return data;
            }
        }
        ```
6. 运行结果

    ![](/backend/senior/nest/011.png)

## 2.8 Modules 模块

nestjs是模块化编程的思想，一个应用由一个个拆分的模块来组成，每个模块负责自己的一部分业务，一个应用至少有一个模块，也就是根模块，使用@Module()装饰器来声明一个模块，模块也是一个类。


1. 基础模块

    - 创建组件

        ```sh
        nest g resource module
        ```
    - 删除文件，只保留 module service controller

        - controller

            ```ts
            import { Controller, Get } from '@nestjs/common';
            import { ModuleService } from './module.service';

            @Controller('module')
            export class ModuleController {
                constructor(private readonly moduleService: ModuleService) {}

                @Get('useController')
                findAll() {
                    return this.moduleService.useService();
                }
            }
            ```
        - service

            ```ts
            import { Injectable } from '@nestjs/common';

            @Injectable()
            export class ModuleService {
                useService() {
                    return 'useService';
                }
            }
            ```
        - module

            ```ts
            import { Module } from '@nestjs/common';
            import { ModuleService } from './module.service';
            import { ModuleController } from './module.controller';

            @Module({
                controllers: [ModuleController],
                providers: [ModuleService],
            })
            export class ModuleModule {}
            ```

    - 主模块的引入

        ![](/backend/senior/nest/012.png)
    - 接口调用结果

        ![](/backend/senior/nest/013.png)

2. 共享模块

    - 导出模块 exports

        ```ts
        import { Module } from '@nestjs/common';
        import { ModuleService } from './module.service';
        import { ModuleController } from './module.controller';

        @Module({
            controllers: [ModuleController],
            providers: [ModuleService],
            // 导出用于共享
            exports: [ModuleService],
        })
        export class ModuleModule {}
        ```
    - 创建新的controller

        ```sh
        nest g controller test2
        ```

    - 注入ModuleService并使用 test2.controller.ts

        ```ts
        import { Controller, Get } from '@nestjs/common';
        import { ModuleService } from '../module/module.service';

        @Controller('test2')
        export class Test2Controller {
            constructor(private readonly moduleService: ModuleService) {}

            @Get('share')
            getTest(): string {
                return this.moduleService.useService();
            }
        }
        ```
    - 接口调用结果

        ![](/backend/senior/nest/014.png)

3. 全局模块

    - 创建全局模块 module/global.module.ts

        ```ts
        import { Module, Global } from '@nestjs/common';

        @Global()
        @Module({
            providers: [
                {
                    provide: 'Global',
                    useValue: { baseUrl: '/api' },
                },
            ],
            exports: [
                {
                    provide: 'Global',
                    useValue: { baseUrl: '/api' },
                },
            ],
        })
        export class GlobalModule {}
        ```
    - 在主模块中引用 app.module.ts

        ```ts
        import { GlobalModule } from './module/global.module';
        @Module({
            imports: [GlobalModule],
        })
        ```
    - 使用全局模块

        ```ts{8,16-19}
        import { Controller, Get, Inject } from '@nestjs/common';
        import { ModuleService } from '../module/module.service';

        @Controller('test2')
        export class Test2Controller {
            constructor(
                private readonly moduleService: ModuleService,
                @Inject('Global') private readonly base: object,
            ) {}

            @Get('share')
            getTest(): string {
                return this.moduleService.useService();
            }

            @Get('global')
            getGlobalTest(): object {
                return this.base;
            }
        }
        ```
    - 运行结果

        ![](/backend/senior/nest/015.png)

4. 动态模块

    - 创建动态模块 module/dynamic.moudule.ts

        ```ts
        import { Module, DynamicModule, Global } from '@nestjs/common';

        interface Options {
            path: string;
        }

        @Global()
        @Module({})
        export class DynModule {
            static forRoot(options: Options): DynamicModule {
                return {
                    module: DynModule,
                    providers: [
                        {
                            provide: 'Dynamic',
                            useValue: { baseUrl: '/api' + options.path },
                        },
                    ],
                    exports: [
                        {
                            provide: 'Dynamic',
                            useValue: { baseUrl: '/api' + options.path },
                        },
                    ],
                };
            }
        }

        ```
    - 在主模块中引用 app.module.ts

        ```ts
        import { DynModule } from './module/dynamic.moudule';
        @Module({
            imports: [
                DynModule.forRoot({
                    path: '/myPath',
                }),
            ],
        })
        ```
    - 使用全局模块

        ```ts{8,16-19}
        import { Controller, Get, Inject } from '@nestjs/common';
        import { ModuleService } from '../module/module.service';

        @Controller('test2')
        export class Test2Controller {
            constructor(
                private readonly moduleService: ModuleService,
                @Inject('Global') private readonly base: object,
                @Inject('Dynamic') private readonly staticBase: object,
            ) {}

            @Get('share')
            getTest(): string {
                return this.moduleService.useService();
            }

            @Get('global')
            getGlobalTest(): object {
                return this.base;
            }

            @Get('dynamic')
            getDynamicTest(): object {
                return this.staticBase;
            }
        }
        ```
    - 运行结果

        ![](/backend/senior/nest/016.png)

## 2.9 中间件

1. 介绍

    中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象

    中间件函数可以执行以下任务:

    - 执行任何代码。
    - 对请求和响应对象进行更改。
    - 结束请求-响应周期。
    - 调用堆栈中的下一个中间件函数。
    - 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。

2. 创建一个依赖注入中间件

    - 创建一个日志中间件 logger.middleware.ts

        ```ts
        import { Injectable, NestMiddleware } from '@nestjs/common';
        import { Request, Response, NextFunction } from 'express';

        @Injectable()
        export class Logger implements NestMiddleware {
            use(req: Request, res: Response, next: NextFunction) {
                console.log('拦截经过');
                // send返回不会再进行next
                res.send('直接拦截了，不进行下一步');
                // 继续进行下一步
                next();
            }
        }
        ```
    - 模块中引入

        ```ts
        import {
            MiddlewareConsumer,
            Module,
            NestModule,
            RequestMethod,
        } from '@nestjs/common';
        import { UserService } from './user.service';
        import { UserController } from './user.controller';
        import { Logger } from '../logger.middleware';

        @Module({
            controllers: [UserController],
            providers: [UserService],
        })
        export class UserModule implements NestModule {
            configure(consumer: MiddlewareConsumer) {
                // controller的参数是user
                consumer.apply(Logger).forRoutes('user');
                // 直接塞入 controller 类
                consumer.apply(Logger).forRoutes(UserController);
                // 单独针对Get请求
                consumer
                    .apply(Logger)
                    .forRoutes({ path: 'user', method: RequestMethod.GET });
            }
        }
        ```

    - 运行结果

        ![](/backend/senior/nest/017.png)

2. 全局中间件 main.ts
    - 代码

        ```ts
        import { Request, Response, NextFunction } from 'express';

        function middleWareAll(req: Request, res: Response, next: NextFunction) {
            console.log(req.originalUrl, '我收全局的');
            if (['/list'].includes(req.originalUrl)) {
                next();
            } else {
                res.send('小黑子，露出鸡脚了吧');
            }
        }

        // 使用全局中间件
        app.use(middleWareAll);
        ```
    - 运行结果

        ![](/backend/senior/nest/018.png)

3. 接入第三方中间件 例如 cors 处理跨域

    - 安装cors插件

        ```sh
        # 安装cors
        npm install cors
        # 安装cors提示
        npm install @types/cors -D
        ```
    - main.ts 使用

        ```ts
        // 引入cors 用于跨域
        import cors from 'cors';
        // 使用cors
        app.use(cors());
        ```
## 2.10 上传图片-静态文件

1. 上传图片

    - 安装依赖

        ```sh
        npm install multer -S
        npm install @types/multer -D 
        ```
    - 创建新组件

        ```sh
        nest g resource upload
        ```
    - module 设置MulterModule

        ```ts{9-21}
        import { Module } from '@nestjs/common';
        import { UploadService } from './upload.service';
        import { UploadController } from './upload.controller';
        import { MulterModule } from '@nestjs/platform-express';
        import { diskStorage } from 'multer';
        import { extname, join } from 'path';

        @Module({
            imports: [
                // 注册 MulterModule 类型
                MulterModule.register({
                // 使用 multer 的 diskStorage 方法设置 文件地址与文件名称
                storage: diskStorage({
                    destination: join(__dirname, '../images'),
                    filename: (_, file, callback) => {
                    const filename = `${new Date().getTime() + extname(file.originalname)}`;
                    return callback(null, filename);
                    },
                }),
                }),
            ],
            controllers: [UploadController],
            providers: [UploadService],
        })
        export class UploadModule {}
        ```
    - controller 上传配置

        ```js
        import {
            Controller,
            Post,
            UseInterceptors,
            UploadedFile,
        } from '@nestjs/common';
        import { FileInterceptor } from '@nestjs/platform-express';

        @Controller('upload')
        export class UploadController {
            @Post('album')
            @UseInterceptors(FileInterceptor('file'))
            upload(@UploadedFile() file) {
                console.log(file);
                return true;
            }
        }
        ```
    - 上传图片

        ![](/backend/senior/nest/019.png)
    - 运行结果

        ![](/backend/senior/nest/020.png)
2. 访问图片-静态目录

    - 设置访问路径

        ```ts
        import { NestFactory } from '@nestjs/core';
        import { AppModule } from './app.module';
        import {NestExpressApplication} from '@nestjs/platform-express'
        import { join } from 'path'
        async function bootstrap() {
        const app = await NestFactory.create<NestExpressApplication>(AppModule);
            // useStaticAssets prefix 是虚拟前缀
            app.useStaticAssets(join(__dirname,'images'),{
                prefix:"/myImages"
            })
            await app.listen(3000);
        }
        bootstrap();
        ```
    - 运行结果

        ![](/backend/senior/nest/021.png)

## 2.11 下载文件

1. reponse.download下载 与 字节流下载

    ```ts
    import {
        Controller,
        Post,
        Get,
        Res,
        UseInterceptors,
        UploadedFile,
    } from '@nestjs/common';
    import { FileInterceptor } from '@nestjs/platform-express';
    import { join } from 'path';
    import type { Response } from 'express';
    import { zip } from 'compressing';

    @Controller('upload')
    export class UploadController {
        // 上传文件
        @Post('album')
        @UseInterceptors(FileInterceptor('file'))
        upload(@UploadedFile() file) {
            console.log(file);
            return true;
        }
        // reponse.download下载
        @Get('export')
        downLoad(@Res() res: Response) {
            const url = join(__dirname, '../images/1754563534169.png');
            res.download(url);
        }
        // 字节流下载
        @Get('stream')
        async down(@Res() res: Response) {
            const url = join(__dirname, '../images/1754563534169.png');
            const tarStream = new zip.Stream();
            await tarStream.addEntry(url);

            res.setHeader('Content-Type', 'application/octet-stream');

            res.setHeader('Content-Disposition', `attachment; filename=xiaoman`);

            tarStream.pipe(res);
        }
    }

    ```


2. 前端接收流数据

    ```ts
    const useFetch = async (url: string) => {
        // 返回的信息转成字节流
        const res = await fetch(url).then(res => res.arrayBuffer());
        console.log(res);
        const a = document.createElement("a");
        a.href = URL.createObjectURL(
            new Blob([res], {
                // type:"image/png"
            })
        );
        a.download = "image.zip";
        a.click();
    };

    const download = () => {
        useFetch("http://localhost:3006/upload/stream");
        // window.open("http://localhost:3006/upload/export");
    };
    ```
