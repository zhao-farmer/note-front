# 三、项目设置

## 3.1 拦截器


拦截器具有一系列有用的功能，这些功能受面向切面编程（AOP）技术的启发。它们可以：

- 在函数执行之前/之后绑定额外的逻辑
- 转换从函数返回的结果
- 转换从函数抛出的异常
- 扩展基本函数行为
- 根据所选条件完全重写函数 (例如, 缓存目的)

### 3.1.1 响应拦截器

1. 设置响应拦截器 common/Response.ts

    ```ts
    import {CallHandler,ExecutionContext,Injectable,NestInterceptor,} from '@nestjs/common';
    import { map } from 'rxjs/operators';
    import { Observable } from 'rxjs';

    interface data<T> {
        data: T;
    }

    @Injectable()
    export class Response<T = any> implements NestInterceptor {
        intercept( context: ExecutionContext, next: CallHandler<any>,): Observable<data<T>> {
            return next.handle().pipe(
            map((data) => {
                return {data, status: 0,success: true,message: '成功',};
            }),
            );
        }
    }
    ```
2. 注册全局响应拦截器 main.ts

    ```ts{3,7-8}
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';
    import { Response } from './common/Response';

    async function bootstrap() {
        const app = await NestFactory.create(AppModule);
        // 添加全局 响应拦截器
        app.useGlobalInterceptors(new Response())
        await app.listen(process.env.PORT ?? 3006);
    }
    bootstrap();
    ```
3. 运行结果

    ![](/backend/senior/nest/022.png)

### 3.1.2 异常拦截器


1. 设置异常过滤器 common/HttpFilter.ts

    ```ts
    import { ArgumentsHost, Catch, ExceptionFilter, HttpException } from "@nestjs/common";
    import { Request,Response } from "express";


    @Catch(HttpException)
    export class HttpFilter implements ExceptionFilter{
        catch(exception: HttpException, host: ArgumentsHost) {
            const ctx = host.switchToHttp()
            const request = ctx.getRequest<Request>()
            const response = ctx.getResponse<Response>()

            const status = exception.getStatus()

            response.status(status).json({
                // data: exception.message,
                data: exception,
                time: new Date().getTime(),
                success: false,
                path: request.url,
                status
            })
        }
    }
    ```
2. 注册全局响应拦截器 main.ts

    ```ts{4,10-11}
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';
    import { Response } from './common/Response';
    import { HttpFilter } from './common/HttpFilter';

    async function bootstrap() {
        const app = await NestFactory.create(AppModule);
        // 添加全局 响应拦截器
        app.useGlobalInterceptors(new Response())
        // 添加全局 异常过滤器
        app.useGlobalFilters(new HttpFilter())
        await app.listen(process.env.PORT ?? 3006);
    }
    bootstrap();

    ```
3. 运行结果

    ![](/backend/senior/nest/023.png)

## 3.2 管道

管道 可以做两件事

1. 转换，可以将前端传入的数据转成成我们需要的数据

2. 验证 类似于前端的rules 配置验证规则

### 3.2.1 转换

1. Nestjs 提供了八个内置转换API

    - ValidationPipe
    - ParseIntPipe
    - ParseFloatPipe
    - ParseBoolPipe
    - ParseArrayPipe
    - ParseUUIDPipe
    - ParseEnumPipe
    - DefaultValuePipe





2. 案例1 参数string转number

    - 初始化

        ```sh
        nest g controller pc
        ```
    - 代码

        ```ts
        import { Controller, Get,Param, ParseIntPipe } from '@nestjs/common';

        import * as uuid from 'uuid'

        @Controller('pc')
        export class PcController {

            @Get("parseOld/:id")
            parseParamsOld(@Param('id') id: string){
                console.log(typeof id,"=============>");
                return "id类型:" + typeof id
            }

            @Get("parseNew/:id")
            parseParamsNew(@Param('id',ParseIntPipe) id: number){
                console.log(typeof id,"=============>");
                return "id类型:" + typeof id
            }
        }
        ```
    - 运行结果

        - 未转换

            ![](/backend/senior/nest/024.png)
        - 转换后

            ![](/backend/senior/nest/025.png)

3. 案例2 验证uuid

    - 安装uuid

        ```sh
        npm install uuid -S
        npm install @types/uuid -D
        ```
    - 代码

        ```ts
        import { Controller, Get,Param, ParseUUIDPipe } from '@nestjs/common';

        import * as uuid from 'uuid'

        @Controller('pc')
        export class PcController {

            @Get("getUUid")
            getUUid(){
                return "传递的是uuid:"  + uuid.v4()
            }

            @Get("parseUUid/:id")
            parseParamsUUid(@Param('id',ParseUUIDPipe) id: number){
                return "传递的是uuid"
            }
        }
        ```
    - 运行结果

        - 未转换

            ![](/backend/senior/nest/026.png)
        - 转换后

            ![](/backend/senior/nest/027.png)


### 3.2.2 验证DTO

1. 准备工作

    - 创建模块

        ```sh
        # 创建curd
        nest g resource login
        # 进入目录
        cd src/login
        # 创建管道
        nest g pipe login
        ```
    - 安装验证器

        ```sh
        npm i --save class-validator class-transformer
        ```
2. 验证 pipe 的参数信息

    - 修改pipe文件

        ```ts{6-7}
        import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';

        @Injectable()
        export class LoginPipe implements PipeTransform {
            transform(value: any, metadata: ArgumentMetadata) {
                // 值与源数据
                console.log(value,metadata);
                return value;
            }
        }
        ```

    - 使用pipe文件

        ```ts{4,11}
        import { Controller,Post, Body } from '@nestjs/common';
        import { LoginService } from './login.service';
        import { CreateLoginDto } from './dto/create-login.dto';
        import { LoginPipe } from './login/login.pipe';

        @Controller('login')
        export class LoginController {
            constructor(private readonly loginService: LoginService) {}

            @Post()
            create(@Body(LoginPipe) createLoginDto: CreateLoginDto) {
                return this.loginService.create(createLoginDto);
            }
        }

        ```

    - 远程运行
        - 调用url
        
            ![](/backend/senior/nest/028.png)
        - 控制台打印数据

            ```json
            { name: 'tom', age: 18 } { metatype: [class CreateLoginDto], type: 'body', data: undefined }
            ```
3. 实现验证transform

    - 实体类添加验证

        ```ts
        import { IsNotEmpty, IsNumber, IsString, Length } from "class-validator"
        export class CreateLoginDto {
            @IsNotEmpty()
            @IsString()
            @Length(5,10,{
                message:"字符串最小为5，最大不能超过10"
            })
            name:string;
            @IsNumber()
            age:number
        }
        ```
    - 管道中添加判断

        ```ts
        import { ArgumentMetadata, HttpException, HttpStatus, Injectable, PipeTransform } from '@nestjs/common';
        import { plainToInstance } from 'class-transformer';
        import { validate } from 'class-validator';
        import { CreateLoginDto } from '../dto/create-login.dto';

        @Injectable()
        export class LoginPipe implements PipeTransform {
            async transform(value: any, metadata: ArgumentMetadata) {
                // 值与源数据
                console.log(value,metadata);

                // 反射获取DTO
                const DTO = plainToInstance(CreateLoginDto,value);
                console.log(DTO);
                const errors = await validate(DTO)
                console.log(errors);
                
                if(errors.length){
                    throw new HttpException(errors,HttpStatus.BAD_REQUEST)
                }
                return value;
            }
        }

        ```
    - 运行结果

        ![](/backend/senior/nest/029.png)

4. 注册全局DTO验证管道 (不需要在请求中添加管道)

    - 全局文件中添加

        ```ts{5,13-14}
        import { NestFactory } from '@nestjs/core';
        import { AppModule } from './app.module';
        import { Response } from './common/Response';
        import { HttpFilter } from './common/HttpFilter';
        import { ValidationPipe } from '@nestjs/common';

        async function bootstrap() {
            const app = await NestFactory.create(AppModule);
            // 添加全局 响应拦截器
            app.useGlobalInterceptors(new Response())
            // 添加全局 异常过滤器
            app.useGlobalFilters(new HttpFilter())
            // 全局的管道验证
            app.useGlobalPipes(new ValidationPipe())
            await app.listen(process.env.PORT ?? 3006);
        }
        bootstrap();
        ```
    - 运行结果

        ![](/backend/senior/nest/030.png)

## 3.3 爬虫

1. 介绍

    首先是要对网络协议尤其是 http 协议有基本的了解, 能够分析网站的数据请求响应。学会使用一些工具，简单的情况使用 chrome devtools 的 network 面板就够了

    - cheerio: 是jquery核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对DOM进行操作的地方，让你在服务器端和html愉快的玩耍。
    - https  网络请求库可以发送http请求

2. 准备工作

    - 下载依赖

        ```sh
        # 用于爬虫
        npm i --save cheerio 
        # vpn进入外网
        npm i --save socks-proxy-agent
        ```
    - 新建controller

        ```sh
        nest g controller spider
        ```
3. 代码

    ```ts
    import { Controller, Get } from '@nestjs/common';

    import * as cheerio from 'cheerio';
    import { SocksProxyAgent } from 'socks-proxy-agent';
    import https from 'https';
    import fs from 'fs';
    const fsp = fs.promises;


    const agent = new SocksProxyAgent("socks://127.0.0.1:1080");
    // 获取网页
    function fetchData(url) {
        return new Promise((resolve, reject) => {
            https.get(url, { agent }, response => {
                let data = "";

                response.on("data", chunk => {
                    data += chunk;
                });

                response.on("end", () => {
                    resolve(data);
                });
            }).on("error", error => {
                reject(error);
            });
        });
    }

    // 获取文件
    function fetchDownload(urlStr,fileStream) {    
        // 解决 referer：unsafe-url
        const headers = {
            'referer': 'https://xxxxx.cc/pic/',
        };

        return new Promise((resolve, reject) => {
            https.get(urlStr,
                {   
                    agent,
                    headers:headers
                }, response => {
                // 将响应数据管道传输到文件
                response.pipe(fileStream);

                // 监听完成事件
                fileStream.on('finish', () => {
                    fileStream.close();
                });
            }).on("error", error => {
                reject(error);
            });
        });
    }

    // 间隔时间
    function waitOneSecond() {
        return new Promise(resolve => {
            setTimeout(resolve, 500);
        });
    }

    @Controller('spider')
    export class SpiderController {

        @Get()
        async getNetWorkImage() {
            console.log('==============  开始操作 =================');

            let index = 1;
            const nextText = '下页';
            // url 集合
            const urls:string[] = [];

            let title = '';
            // 获取url 数据
            async function getData() {
                try {
                    const result = await fetchData(
                    `https://xxxxx.cc/pic/186292748753-${index}.html`,
                    );
                    // console.log(result);
                    
                    if (!result) return;
                    // 获取对象
                    const $ = cheerio.load(result + "");
                    // 获取头部
                    let head = $('.item_title');
                    // 获取标题
                    title = head.find('h1').text();
                    if (index == 1) {
                        // 创建目录
                        await fsp.mkdir(title);

                        let file = title + '/描述信息.txt';

                        // 创建文本文件
                        await fsp.writeFile(file, '', 'utf8');

                        // 描述信息
                        head.find('article p').each(function () {
                            fsp.appendFile(file, $(this).text() + '\n\n', 'utf8');
                        });
                    }

                    // 创建图片
                    const page = $('.content .page').find('a');

                    // 获取页数数组
                    const pageArray = page.map(function () {
                        return $(this).text();
                    }).toArray();

                    // 不是最后一页 进行递归
                    if (pageArray.includes(nextText)) {
                        // 获取图片
                        // 第一个 content 的img图片
                        $('.content').eq(0).find('img').each(function () {
                            let srcStr = $(this).attr('src');
                            if (srcStr) {
                                urls.push(srcStr + "");
                            }
                        });

                        index++;
                        // 开启递归
                        await getData();
                    }
                } catch (error) {
                    console.error('Error:', error);
                }
            }

            await getData()

            console.log(urls);
            

            // 开始下载
            for (const newUrl of urls) {
                // 等待1s 后调用
                await waitOneSecond();
                // 文件地址
                const fileStream = fs.createWriteStream(title + "/" + new Date().getTime() + '.jpg');
                // 开始写入
                fetchDownload(newUrl,fileStream)
            } 

            return 'cos';
        }
    }

    ```

4. 运行结果

    ![](/backend/senior/nest/031.png)

## 3.4 守卫

1. 守卫（guard） 介绍

    守卫有一个单独的责任。它们根据运行时出现的某些条件（例如权限，角色，访问控制列表等）来确定给定的请求是否由路由处理程序处理。这通常称为授权。在传统的 Express 应用程序中，通常由中间件处理授权(以及认证)。中间件是身份验证的良好选择，因为诸如 token 验证或添加属性到 request 对象上与特定路由(及其元数据)没有强关联。

2. 准备工作

    ```sh
    # 创建新模块
    nest g controller guard
    # 进入目录
    cd src/guard
    # 创建守卫
    nest g gu guard
    ```
3. controller 使用守卫
    
    使用UseGuards  控制守卫

    - role.guard.ts 守卫文件

        ```ts{9}
        import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
        import { Observable } from 'rxjs';

        @Injectable()
        export class RoleGuard implements CanActivate {
            canActivate(
                context: ExecutionContext,
            ): boolean | Promise<boolean> | Observable<boolean> {
                console.log("经过了守卫");
                return true;
            }
        }

        ```
    - guard.controller.ts 使用守卫

        ```ts
        import { Controller, Get, UseGuards } from '@nestjs/common';
        import { RoleGuard } from './role/role.guard';

        @UseGuards(RoleGuard)
        @Controller('guard')
        export class GuardController {
            @Get('verify1')
            verify1() {
                return '验证 controller 中的守卫';
            }
        }
        ```

4. 全局守卫

    ```ts{6,16-17}
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';
    import { Response } from './common/Response';
    import { HttpFilter } from './common/HttpFilter';
    import { ValidationPipe } from '@nestjs/common';
    import { RoleGuard } from './guard/role/role.guard';

    async function bootstrap() {
        const app = await NestFactory.create(AppModule);
        // 添加全局 响应拦截器
        app.useGlobalInterceptors(new Response())
        // 添加全局 异常过滤器
        app.useGlobalFilters(new HttpFilter())
        // 全局的管道验证
        app.useGlobalPipes(new ValidationPipe())
        // 全局守卫
        app.useGlobalGuards(new RoleGuard())
        
        await app.listen(process.env.PORT ?? 3006);
    }
    bootstrap();

    ```

5. 验证角色

    - controller 设置

        ```ts{12-16}
        import { Controller, Get, SetMetadata, UseGuards } from '@nestjs/common';
        import { RoleGuard } from './role/role.guard';

        @UseGuards(RoleGuard)
        @Controller('guard')
        export class GuardController {
            @Get('verify1')
            verify1() {
                return '验证 controller 中的守卫';
            }

            @Get('verifyRole')
            @SetMetadata('role', ['admin'])
            verifyRole() {
                return '验证 角色控制';
            }
        }

        ```
    - guard 设置

        ```ts
        import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
        import { Observable } from 'rxjs';
        import { Reflector } from '@nestjs/core';
        import type { Request } from 'express';

        @Injectable()
        export class RoleGuard implements CanActivate {
            // 依赖注入
            constructor(private Reflector: Reflector) {}

            canActivate(
                context: ExecutionContext,
            ): boolean | Promise<boolean> | Observable<boolean> {
                // 反射获取设置的信息
                // string[] 返回类型 自身设置
                // role SetMetadata 中设置的key
                const admin = this.Reflector.get<string[]>('role', context.getHandler());
                // 获取前端传入的 Request 对象
                const request = context.switchToHttp().getRequest<Request>();
                // 传入参数化中含有的角色
                // 一般是根据token获取用户，然后根据用户角色去验证，这里省略了
                if (admin.includes(request.query.role as string)) {
                    // 验证通过
                    return true;
                } else {
                    // 验证不通过 会报错
                    return false;
                }
            }
        }

        ```

    - 运行结果

        - 角色正确

            ![](/backend/senior/nest/032.png)
        - 角色错误

            ![](/backend/senior/nest/033.png)

## 3.5 自定义装饰器

在Nestjs 中我们使用了大量装饰器 decorator ，所以Nestjs 也允许我们去自定义装饰器。

1. 生成装饰器

    ```sh
    nest g d role
    ```

2. controller 使用装饰器

      - role.decorator 代码

        ```ts
        import { SetMetadata } from '@nestjs/common';

        export const Role = (...args: string[]) => SetMetadata('role', args);
        ```

    - controller 代码

        ```ts{19-23}
        import { Controller, Get, SetMetadata, UseGuards } from '@nestjs/common';
        import { RoleGuard } from './role/role.guard';
        import { Role } from './role/role.decorator';

        @UseGuards(RoleGuard)
        @Controller('guard')
        export class GuardController {
            @Get('verify1')
            verify1() {
                return '验证 controller 中的守卫';
            }

            @Get('verifyRole')
            @SetMetadata('role', ['admin'])
            verifyRole() {
                return '验证 角色控制';
            }

            @Get('verifyDecorator')
            @Role('admin')
            verifyDecorator() {
                return '验证 自定义装饰器';
            }
        }
        ```
  
    - 运行结果

        ![](/backend/senior/nest/034.png)

3. 自定义参数装饰器返回一个url

     - role.decorator 代码

        ```ts{1-2,6-10}
        import { SetMetadata,createParamDecorator,ExecutionContext } from '@nestjs/common';
        import type { Request } from 'express';

        export const Role = (...args: string[]) => SetMetadata('role', args);

        export const ReqUrl = createParamDecorator((data:string,ctx:ExecutionContext)=>{
            const req = ctx.switchToHttp().getRequest<Request>()
            return req.url
        })

        ```
    - controller 代码

        ```ts{25-29}
        import { Controller, Get, SetMetadata, UseGuards } from '@nestjs/common';
        import { RoleGuard } from './role/role.guard';
        import { Role, ReqUrl } from './role/role.decorator';

        @UseGuards(RoleGuard)
        @Controller('guard')
        export class GuardController {
            @Get('verify1')
            verify1() {
                return '验证 controller 中的守卫';
            }

            @Get('verifyRole')
            @SetMetadata('role', ['admin'])
            verifyRole() {
                return '验证 角色控制';
            }

            @Get('verifyDecorator')
            @Role('admin')
            verifyDecorator() {
                return '验证 自定义装饰器';
            }

            @Get('verifyReqUrl')
            @Role('admin')
            verifyReqUrl(@ReqUrl() url) {
                return '返回的是url路径' + url;
            }
        }

        ```
    - 运行结果

        ![](/backend/senior/nest/035.png)

## 3.6 swagger接口文档

swagger 用于提供给前端接口文档



1. 安装swagger

    ```sh
    npm install  @nestjs/swagger swagger-ui-express
    ```
2. 全局配置

    - main.ts 注册swagger

        ```ts
        const options = new DocumentBuilder().setTitle('我的接口文档')
                            .setDescription('描述....')
                            .setVersion('1')
                            .build()
        const document = SwaggerModule.createDocument(app,options);
        SwaggerModule.setup("/api-docs",app,document)
        ```
    - 运行结果

        ![](/backend/senior/nest/036.png)


3. 具体配置

    - 新建模块

        ```sh
        nest g res swaager
        ```
    - ApiTags 添加分组

        - 修改 swagger.controller.ts

            ```ts{5,8}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/037.png)
    - ApiOperation 接口描述

        - 修改 swagger.controller.ts

            ```ts{5,18}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation, ApiTags } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                @ApiOperation({summary:"get请求测试",description:"api使用的rest风格"})
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/038.png)

    - ApiParam 动态参数描述

         - 修改 swagger.controller.ts

            ```ts{5,24}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation, ApiTags, ApiParam } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                @ApiOperation({summary:"get请求测试",description:"api使用的rest风格"})
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                @ApiParam({name:"id",description:"用户id",required:true})
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/039.png)

    - ApiQuery 修饰get

        - 修改 swagger.controller.ts

            ```ts{5,19}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation, ApiTags, ApiParam, ApiQuery } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                @ApiOperation({summary:"get请求测试",description:"api使用的rest风格"})
                @ApiQuery({name:"page",description:"分页信息"})
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                @ApiParam({name:"id",description:"用户id",required:true})
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/040.png)

    - ApiProperty 定义Post
    
        - 修改 create-swaager.dto.ts

            ```ts
            import { ApiProperty } from "@nestjs/swagger"

            export class CreateSwaagerDto {
                @ApiProperty({example:"zhangsan"})
                name:string
                @ApiProperty({example:18})
                age:number
            }
            ```
        - swagger界面

            ![](/backend/senior/nest/041.png)

    - ApiResponse 自定义返回信息

         - 修改 swagger.controller.ts

            ```ts{5,36}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation, ApiTags, ApiParam, ApiQuery, ApiResponse } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                @ApiOperation({summary:"get请求测试",description:"api使用的rest风格"})
                @ApiQuery({name:"page",description:"分页信息"})
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                @ApiParam({name:"id",description:"用户id",required:true})
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                @ApiResponse({status:403,description:"自定义返回信息"})
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/042.png)

    - ApiBearerAuth  jwt token

        - 修改 main.ts 

            ```ts{2}
            const options = new DocumentBuilder().setTitle('我的接口文档')
                          .addBearerAuth()
                          .setDescription('描述....')
                          .setVersion('1')
                          .build()
            const document = SwaggerModule.createDocument(app,options);
            SwaggerModule.setup("/api-docs",app,document)
            ```
        - 修改 swagger.controller.ts

            ```ts{6,10}
            import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
            import { SwaagerService } from './swaager.service';
            import { CreateSwaagerDto } from './dto/create-swaager.dto';
            import { UpdateSwaagerDto } from './dto/update-swaager.dto';
            import { ApiOperation, ApiTags, ApiParam, ApiQuery, ApiResponse } from '@nestjs/swagger';
            import { ApiBearerAuth } from '@nestjs/swagger';

            @Controller('swaager')
            @ApiTags("swagger分组")
            @ApiBearerAuth()
            export class SwaagerController {
            constructor(private readonly swaagerService: SwaagerService) {}

                @Post()
                create(@Body() createSwaagerDto: CreateSwaagerDto) {
                    return this.swaagerService.create(createSwaagerDto);
                }

                @Get()
                @ApiOperation({summary:"get请求测试",description:"api使用的rest风格"})
                @ApiQuery({name:"page",description:"分页信息"})
                findAll() {
                    return this.swaagerService.findAll();
                }

                @Get(':id')
                @ApiParam({name:"id",description:"用户id",required:true})
                findOne(@Param('id') id: string) {
                    return this.swaagerService.findOne(+id);
                }

                @Patch(':id')
                update(@Param('id') id: string, @Body() updateSwaagerDto: UpdateSwaagerDto) {
                    return this.swaagerService.update(+id, updateSwaagerDto);
                }

                @Delete(':id')
                @ApiResponse({status:403,description:"自定义返回信息"})
                remove(@Param('id') id: string) {
                    return this.swaagerService.remove(+id);
                }
            }

            ```
        - swagger界面

            ![](/backend/senior/nest/043.png)
## 3.7 orm

### 3.7.1 连接数据库

1. 安装插件

    ```sh
    npm install --save @nestjs/typeorm typeorm mysql2
    ```
2. 创建数据库
    
    - vscode 安装 数据库客户端

        ![](/backend/senior/nest/044.png)
    - 连接数据库

        ![](/backend/senior/nest/045.png)
    - 创建库

        ![](/backend/senior/nest/046.png)

3. 使用数据接库

    - 添加数据库配置 app.module.ts

        ```ts
        import { Module } from '@nestjs/common';
        import { AppController } from './app.controller';
        import { AppService } from './app.service';
        // 引入 TypeOrmModule 模块
        import { TypeOrmModule } from '@nestjs/typeorm';

        @Module({
            imports: [
                TypeOrmModule.forRoot({
                    type: 'mysql', //数据库类型
                    username: 'root', //账号
                    password: '123456', //密码
                    host: 'localhost', //host
                    port: 3306, //
                    database: 'netsmysql', //库名
                    entities: [__dirname + '/**/*.entity{.ts,.js}'], //实体文件
                    synchronize: true, //synchronize字段代表是否自动将实体类同步到数据库
                    retryDelay: 500, //重试连接数据库间隔
                    retryAttempts: 10, //重试连接数据库的次数
                    autoLoadEntities: true, //如果为true,将自动加载实体 forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中
                }),
            ],
            controllers: [AppController],
            providers: [AppService],
        })
        export class AppModule {}

        ```
    - 创建新模块

        ```sh
        nest g res test
        ```
    - 修改实体类 test.entity.ts

        ```ts
        import { Entity,Column,PrimaryGeneratedColumn } from "typeorm"

        @Entity()
        export class Test {
            @PrimaryGeneratedColumn()
            id:number
            @Column()
            name:string
            @Column()
            password:string
            @Column()
            age:number
        }
        ```
    - module中引入 test.module.ts

        ```ts{5,8}
        import { Module } from '@nestjs/common';
        import { TestService } from './test.service';
        import { TestController } from './test.controller';
        import { Test } from './entities/test.entity';
        import { TypeOrmModule } from '@nestjs/typeorm';

        @Module({
            imports: [TypeOrmModule.forFeature([Test])],
            controllers: [TestController],
            providers: [TestService],
        })
        export class TestModule {}
        ```

4. 重启后，查看数据库

    ![](/backend/senior/nest/047.png)

### 3.7.2 实体

实体是一个映射到数据库表的类。 你可以通过定义一个新类来创建一个实体，并用@Entity()来标记

1. 简单列


    - 主列：
        
        - 自动递增的主键

            ```ts
            @PrimaryGeneratedColumn()
            id:number
            ```
        - 自动递增uuid

            ```ts
            @PrimaryGeneratedColumn("uuid")
            id:number
            ```

    - 列类型(当前数据的类型)

        ```ts
        @Column({type:"varchar",length:200})
        password: string

        @Column({ type: "int"})
        age: number

        @CreateDateColumn({type:"timestamp"})
        create_time:Date
        ```


    - 自动生成列

        ```ts
        @Generated('uuid')
        uuid:string
        ```

    - 枚举列

        ```ts
        @Column({
            type:"enum",
            enum:['1','2','3','4'],
            default:'1'
        })
        xx:string
        ```

2. 列选项

    - 代码

        ```ts
        @Column({
            type:"varchar",
            name:"ipaaa", //数据库表中的列名
            nullable:true, //在数据库中使列NULL或NOT NULL。 默认情况下，列是nullable：false
            comment:"注释",
            select:true,  //定义在进行查询时是否默认隐藏此列。 设置为false时，列数据不会显示标准查询。 默认情况下，列是select：true
            default:"xxxx", //加数据库级列的DEFAULT值
            primary:false, //将列标记为主要列。 使用方式和@ PrimaryColumn相同。
            update:true, //指示"save"操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为"true"
            collation:"", //定义列排序规则。
        })
        ip:string
        ```

    - `ColumnOptions`中可用选项列表：

        *   `type: ColumnType` - 列类型。其中之一在[上面](https://typeorm.biunav.com/zh/entities.html#column-types "上面").
        *   `name: string` - 数据库表中的列名。

        默认情况下，列名称是从属性的名称生成的。 你也可以通过指定自己的名称来更改它。

        *   `length: number` - 列类型的长度。 例如，如果要创建`varchar（150）`类型，请指定列类型和长度选项。
        *   `width: number` - 列类型的显示范围。 仅用于[MySQL integer types(opens new window)](https://dev.mysql.com/doc/refman/5.7/en/integer-types.html "MySQL integer types(opens new window)")
        *   `onUpdate: string` - `ON UPDATE`触发器。 仅用于 [MySQL (opens new window)](https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html "MySQL (opens new window)").
        *   `nullable: boolean` - 在数据库中使列`NULL`或`NOT NULL`。 默认情况下，列是`nullable：false`。
        *   `update: boolean` - 指示"save"操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为"true"。
        *   `select: boolean` - 定义在进行查询时是否默认隐藏此列。 设置为`false`时，列数据不会显示标准查询。 默认情况下，列是`select：true`
        *   `default: string` - 添加数据库级列的`DEFAULT`值。
        *   `primary: boolean` - 将列标记为主要列。 使用方式和`@ PrimaryColumn`相同。
        *   `unique: boolean` - 将列标记为唯一列（创建唯一约束）。
        *   `comment: string` - 数据库列备注，并非所有数据库类型都支持。
        *   `precision: number` - 十进制（精确数字）列的精度（仅适用于十进制列），这是为值存储的最大位数。仅用于某些列类型。
        *   `scale: number` - 十进制（精确数字）列的比例（仅适用于十进制列），表示小数点右侧的位数，且不得大于精度。 仅用于某些列类型。
        *   `zerofill: boolean` - 将`ZEROFILL`属性设置为数字列。 仅在 MySQL 中使用。 如果是`true`，MySQL 会自动将`UNSIGNED`属性添加到此列。
        *   `unsigned: boolean` - 将`UNSIGNED`属性设置为数字列。 仅在 MySQL 中使用。
        *   `charset: string` - 定义列字符集。 并非所有数据库类型都支持。
        *   `collation: string` - 定义列排序规则。
        *   `enum: string[]|AnyEnum` - 在`enum`列类型中使用，以指定允许的枚举值列表。 你也可以指定数组或指定枚举类。
        *   `asExpression: string` - 生成的列表达式。 仅在[MySQL (opens new window)](https://dev.mysql.com/doc/refman/5.7/en/create-table-generated-columns.html "MySQL (opens new window)")中使用。
        *   `generatedType: "VIRTUAL"|"STORED"` - 生成的列类型。 仅在[MySQL (opens new window)](https://dev.mysql.com/doc/refman/5.7/en/create-table-generated-columns.html "MySQL (opens new window)")中使用。
        *   `hstoreType: "object"|"string"` -返回`HSTORE`列类型。 以字符串或对象的形式返回值。 仅在[Postgres](https://typeorm.biunav.com/zh/%28https://www.postgresql.org/docs/9.6/static/hstore.html%29 "Postgres")中使用。
        *   `array: boolean` - 用于可以是数组的 postgres 列类型（例如 int \[\]）
        *   `transformer: { from(value: DatabaseType): EntityType, to(value: EntityType): DatabaseType }` - 用于将任意类型`EntityType`的属性编组为数据库支持的类型`DatabaseType`。

3. 复杂列

    - simple-array 列类型

        有一种称为`simple-array`的特殊列类型，它可以将原始数组值存储在单个字符串列中。 所有值都以逗号分隔

        ```ts
        @Entity()
        export class User {
            @PrimaryGeneratedColumn()
            id: number;

            @Column("simple-array")
            names: string[];
        }
        ```

    - `simple-json列类型`

        还有一个名为`simple-json`的特殊列类型，它可以存储任何可以通过 JSON.stringify 存储在数据库中的值。 当你的数据库中没有 json 类型而你又想存储和加载对象，该类型就很有用了。 例如:

        ```ts
        @Entity()
        export class User {
            @PrimaryGeneratedColumn()
            id: number;

            @Column("simple-json")
            profile: { name: string; nickname: string };
        }
        ```