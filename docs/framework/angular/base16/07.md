# 七、生命周期

## 7.1 生命周期详解

### 7.1.1 组件生命周期钩子执行过程
　
1. 组件初始化过程中，生命周期钩子执行顺序：

    1. constructor()构造函数,初始化class，(constructor不属于Angular生命周期钩子的范畴，这里只是说明组件组件初始化会先调用构造函数)。
    2. ngOnChanges()--如果组件没有输入属性(@Input()),或者使用时没有提供任何输入属性，那么angular不会调用它；会调用多次。
    3. ngOnInit()--只调用一次，一般用来初始化数据，如请求数据。
    4. ngDoCheck()--紧跟在每次执行变更检测时的ngOnChanges()和首次执行变更检测的ngOnInit()后调用；会调用多次。
    5. ngAfterContentInit()--当Angular把外部内容投影进组件视图或指令所在的视图之后调用，第一次ngDoCheck()之后调用，只调用一次。
    6. ngAfterContentChecked()--每当Angular检查完被投影到组件或指令中的内容之后调用，在ngAfterContentInit()和每次ngDoCheck()之后调用，会调用多次。
    7. ngAfterViewInit()--当Angular初始化玩玩组件视图及其子视图之后调用，只调用一次。
    8. ngAfterViewChecked()--当Angular做完组件视图和子视图的变更检测之后调用；在ngAfterViewInit()和每次ngAfterContentChecked()之后调用，会调用多次。
    9. ngOnDestroy()--当Angular每次销毁组件或指令之前调用并清扫。在这里取消订阅可观察对象和分离事件处理器，以防内存泄漏。

2. 示例图

    ![](/framework/angular/base16/022.png)

### 7.1.2 父子组件生命周期钩子过程

1. 父子组件生命周期钩子执行顺序
    1. 首先调用父组件的构造函数，然后调用子组件的构造函数。
    2. 当调用父组件的ngAfterContentChecked()钩子之后，会调用子组件的生命周期函数。
    3. 子组件的ngAfterContentChecked()钩子执行完之后，会在调用子组件的子组件的生命周期钩子(如果有的话)。
    4. 子组件执行ngAfterViewChecked()钩子后，父组件继续执行其余的生命周期钩子。
    5. 当发生变更检测时，父组件先触发ngDoCheck() => ngAfterContentChecked()，然后子组件触发 ngOnChanges() => ngDoCheck() => ngAfterContentChecked() => ngAfterViewChecked(),最后父组件调用ngAfterViewChecked()。

2. 示例图

    ![](/framework/angular/base16/023.png)

### 7.1.3 代码验证

1. 代码

    ```ts
    import {
        Component,
        Input,
        OnChanges,
        OnInit,
        DoCheck,
        AfterContentInit,
        AfterContentChecked,
        AfterViewInit,
        AfterViewChecked,
        OnDestroy,
        SimpleChanges,
    } from '@angular/core';

    @Component({
        selector: 'rec-01',
        template: `
            <h2>生命周期演示</h2>
            <p>输入属性值: {{ inputValue }}</p>
            <p>计数器: {{ counter }}</p>
            <button (click)="increment()">增加计数器</button>
            <button (click)="updateInput()">更改输入属性</button>
        `,
    })
    export class Rec01Component
        implements
            OnChanges,
            OnInit,
            DoCheck,
            AfterContentInit,
            AfterContentChecked,
            AfterViewInit,
            AfterViewChecked,
            OnDestroy
        {
        @Input() inputValue = '初始值';
        counter = 0;

        ngOnChanges(changes: SimpleChanges) {
            console.log('ngOnChanges:', changes);
        }

        ngOnInit() {
            console.log('ngOnInit');
        }

        ngDoCheck() {
            console.log('ngDoCheck');
        }

        ngAfterContentInit() {
            console.log('ngAfterContentInit');
        }

        ngAfterContentChecked() {
            console.log('ngAfterContentChecked');
        }

        ngAfterViewInit() {
            console.log('ngAfterViewInit');
        }

        ngAfterViewChecked() {
            console.log('ngAfterViewChecked');
        }

        ngOnDestroy() {
            console.log('ngOnDestroy');
        }

        increment() {
            this.counter++;
        }

        updateInput() {
            this.inputValue = '新值 ' + Date.now();
        }
    }
    ```

2. 路由

    ```ts
     {
        path: 'rec',
        children:[
            { path: '01',component: Rec01Component, title: '生命周期代码' },
        ]
    },    
    ```

3. 结果

    ![](/framework/angular/base16/024.png)

## 7.2 生命周期案例


### 7.2.1 ngOnChanges()

1. 介绍
    -  **调用时机**：当输入属性发生变化时调用（首次调用在 `ngOnInit()` 之前）
    -  **使用场景**：
        *   监控输入属性的变化
        *   根据输入属性变化执行特定逻辑
            
2. 代码案例

    ```ts
    import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

    @Component({
        selector: 'example-01-child',
        template: `<p>用户名: {{ name }}，年龄: {{ age }}</p>`,
    })
    export class Example01ChildComponent implements OnChanges {
        @Input() name!: string;
        @Input() age!: number;

        ngOnChanges(changes: SimpleChanges) {
            console.log('ngOnChanges 触发');

            for (const propName in changes) {
                const change = changes[propName];
                console.log(
                    `${propName} 变化:`,
                    `当前值: ${change.currentValue},`,
                    `之前值: ${change.previousValue}`,
                    `是否是首次变化: ${change.firstChange}`
                );
            }
        }
    }

    // 使用示例
    @Component({
        selector: 'example-01',
        template: `
            <example-01-child [name]="parentName" [age]="parentAge" />
        `,
    })
    export class Example01Component {
        parentName = '张三';
        parentAge = 18;
    }

    ```
3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/025.png)

### 7.2.2 ngOnInit()

1. 介绍
    - **调用时机**：在第一个 `ngOnChanges()` 之后调用，只调用一次
    - **使用场景**：
        *   组件初始化逻辑 
        *   获取初始数据
        *   设置初始状态
2. 代码案例

    ```ts
    import { Component, OnInit } from '@angular/core';

    @Component({
        selector: 'example-02',
        template: `<p>组件已初始化</p>`,
    })
    export class Example02Component implements OnInit {
        ngOnInit() {
            console.log('ngOnInit 触发');
            // 这里适合进行初始化操作
            this.fetchData();
            this.setupInitialState();
        }

        private fetchData() {
            console.log('获取初始数据...');
        }

        private setupInitialState() {
            console.log('设置初始状态...');
        }
    }
    ```
3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/026.png)

### 7.2.3 ngDoCheck()

1. 介绍
    - **调用时机**：在每个变更检测周期中调用
    - **使用场景**：
        *   自定义变更检测逻辑
        *   手动检查复杂对象的变化

2. 代码案例

    ```ts
    import { Component, DoCheck } from '@angular/core';

    @Component({
        selector: 'example-03',
        template: `
            <p>计数器: {{ counter }}</p>
            <button (click)="increment()">增加</button>
        `,
    })
    export class Example03Component implements DoCheck {
        counter = 0;
        previousCounter = 0;

        increment() {
            this.counter++;
        }

        ngDoCheck() {
            console.log('ngDoCheck 触发');

            if (this.counter !== this.previousCounter) {
            console.log(`计数器从 ${this.previousCounter} 变为 ${this.counter}`);
            this.previousCounter = this.counter;
            }
        }
    }
    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/027.png)
        

### 7.2.4 ngAfterContentInit()

1. 介绍
    -  **调用时机**： 在 Angular 将外部内容投影到组件视图后调用（只调用一次）
    -  **使用场景**：
        *   访问投影内容
        *   在内容投影完成后执行操作
    
2. 代码案例

    ```ts
   import { Component, AfterContentInit, ContentChild } from '@angular/core';

    @Component({
        selector: 'example-04-child',
        template: `
            <ng-content></ng-content>
            <p>内容投影已完成</p>
        `,
    })
    export class Example04ChildComponent implements AfterContentInit {
        @ContentChild('projectedContent') projectedContent: any;

        ngAfterContentInit() {
            console.log('ngAfterContentInit 触发');
            console.log('投影内容:', this.projectedContent);
        }
    }

    // 使用示例
    @Component({
        selector: 'example-04',
        template: `
            <example-04-child>
            <div #projectedContent>这是投影内容</div>
            </example-04-child>
        `,
    })
    export class Example04Component {}

    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
            { path: '04',component: Example04Component, title: '生命周期AfterContentInit' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/028.png)
        

### 7.2.5 ngAfterContentChecked()
1. 介绍
    - **调用时机**：在 Angular 检查投影内容后调用（每次变更检测后都会调用）
    - **使用场景**：
        *   在每次内容检查后执行逻辑
        *   监控投影内容的变化
2. 代码案例

    ```ts
    import { Component, AfterContentChecked } from '@angular/core';

    @Component({
        selector: 'example-05',
        template: `
            <ng-content></ng-content>
            <p>内容已检查</p>
        `
    })
    export class Example05Component implements AfterContentChecked {
        ngAfterContentChecked() {
            console.log('ngAfterContentChecked 触发');
        }
    }
    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
            { path: '04',component: Example04Component, title: '生命周期AfterContentInit' },
            { path: '05',component: Example05Component, title: '生命周期AfterContentChecked' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/029.png)


### 7.2.6 ngAfterViewInit()

1. 介绍
    -  **调用时机**：在 Angular 初始化组件视图和子视图后调用（只调用一次）
    -  **使用场景**：
        *   访问 DOM 元素
        *   访问子组件
        *   视图初始化后执行操作

2. 代码案例

    ```ts
    import { Component, AfterViewInit, ViewChild, ElementRef } from '@angular/core';

    // 子组件
    @Component({
        selector: 'example-05-child',
        template: `<p>子组件</p>`,
    })
    export class Example06ChildComponent {}

    // 父组件
    @Component({
        selector: 'example-06',
        template: `
            <p #viewParagraph>视图元素</p>
            <example-05-child></example-05-child>
        `,
    })
    export class Example06Component implements AfterViewInit {
        @ViewChild('viewParagraph') viewParagraph!: ElementRef;
        @ViewChild(Example06ChildComponent) childComponent!: Example06ChildComponent;

        ngAfterViewInit() {
            console.log('ngAfterViewInit 触发');
            console.log('视图元素:', this.viewParagraph.nativeElement.textContent);
            console.log('子组件:', this.childComponent);
        }
    }
    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
            { path: '04',component: Example04Component, title: '生命周期AfterContentInit' },
            { path: '05',component: Example05Component, title: '生命周期AfterContentChecked' },
            { path: '06',component: Example06Component, title: '生命周期AfterViewInit' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/030.png)

### 7.2.7 ngAfterViewChecked()

1. 介绍

    - **调用时机**：在 Angular 检查组件视图和子视图后调用（每次变更检测后都会调用）
    - **注意**：在此钩子中避免修改组件状态，否则会导致无限循环。

2. 代码案例

    ```ts
    import { Component, AfterViewChecked } from '@angular/core';

    @Component({
        selector: 'example-07',
        template: `<p>视图已检查</p>`,
    })
    export class Example07Component implements AfterViewChecked {
        ngAfterViewChecked() {
            console.log('ngAfterViewChecked 触发');
        }
    }
    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
            { path: '04',component: Example04Component, title: '生命周期AfterContentInit' },
            { path: '05',component: Example05Component, title: '生命周期AfterContentChecked' },
            { path: '06',component: Example06Component, title: '生命周期AfterViewInit' },
            { path: '07',component: Example07Component, title: '生命周期AfterViewChecked' },
        ],
    },
    ```

4. 运行结果

    ![](/framework/angular/base16/031.png)

### 7.2.8 ngOnDestroy()

1. 介绍
    -  **调用时机**：在组件销毁前调用
    -  **使用场景**：清理时间循环

2. 代码案例

    ```ts
    import { Component, OnDestroy } from '@angular/core';
    import { interval, Subscription } from 'rxjs';

    @Component({
        selector: 'app-timer',
        template: `<p>计时器: {{count}}</p>`    
    })
    export class TimerComponent implements OnDestroy {
        count = 0;
        private subscription: Subscription;

        constructor() {
            this.subscription = interval(1000).subscribe(() => {
                this.count++;
                console.log('计时:', this.count);   
            });
        }

        ngOnDestroy() {
            console.log('ngOnDestroy 触发');
            this.subscription.unsubscribe();
            console.log('已取消订阅，清理资源');
        }
    }
    ```

3. 路由

    ```ts
    {
        path: 'example',
        children: [
            { path: '01',component: Example01Component, title: '生命周期OnChanges' },
            { path: '02',component: Example02Component, title: '生命周期OnInit' },
            { path: '03',component: Example03Component, title: '生命周期DoCheck' },
            { path: '04',component: Example04Component, title: '生命周期AfterContentInit' },
            { path: '05',component: Example05Component, title: '生命周期AfterContentChecked' },
            { path: '06',component: Example06Component, title: '生命周期AfterViewInit' },
            { path: '07',component: Example07Component, title: '生命周期AfterViewChecked' },
            { path: '08',component: Example08Component, title: '生命周期OnDestroy' },
        ],
    },
    ```
## 7.3 综合练习

1. 案例组件

    ```ts
    import {
        Component, Input, OnChanges, OnInit, DoCheck,
        AfterContentInit, AfterContentChecked,
        AfterViewInit, AfterViewChecked, OnDestroy,
        SimpleChanges, ContentChild, ViewChild, ElementRef
    } from '@angular/core';
    import { interval, Subscription } from 'rxjs';


    // 用户列表子组件
    @Component({
        selector: 'app-user-list',
        template: `
            <div class="user-list">
            <h3>用户列表 ({{users.length}})</h3>
            <ul>
                <li *ngFor="let user of users">{{user}}</li>
            </ul>
            </div>
        `,
        styles: [`
            .user-list {
                margin-top: 15px;
                padding: 10px;
                background-color: #f5f5f5;
            }
        `]
    })
    export class UserListComponent {
        @Input() users: string[] = [];
    }


    // 父组件
    @Component({
        selector: 'app-user-counter',
        template: `
            <div class="counter-container">
            <h2 #counterTitle>用户计数器</h2>

            <div class="content-projection">
                <ng-content></ng-content>
            </div>

            <div class="counter-display">
                <p>当前用户数: {{currentCount}}</p>
                <p>最大用户数: {{maxCount}}</p>
                <p>变化次数: {{changeCount}}</p>
            </div>

            <div class="actions">
                <button (click)="increment()">增加用户</button>
                <button (click)="decrement()">减少用户</button>
            </div>

            <app-user-list [users]="getUsers()"></app-user-list>
            </div>
        `,
        styles: [`
            .counter-container {
                border: 1px solid #ccc;
                padding: 20px;
                margin: 20px;
                max-width: 500px;
            }
            .actions {
                margin: 15px 0;
            }
            button {
                margin-right: 10px;
            }
        `]
    })
    export class UserCounterComponent implements
    OnChanges, OnInit, DoCheck,
    AfterContentInit, AfterContentChecked,
    AfterViewInit, AfterViewChecked, OnDestroy {

        @Input() initialCount = 0;
        @Input() maxCount = 10;

        @ContentChild('projectedContent') projectedContent!: ElementRef;
        @ViewChild('counterTitle') counterTitle!: ElementRef;
        @ViewChild(UserListComponent) userListComponent!: UserListComponent;

        currentCount = 0;
        changeCount = 0;
        previousCount = 0;
        private countSubscription!: Subscription;
        private users: string[] = [];

        // 1. ngOnChanges - 输入属性变化时调用
        ngOnChanges(changes: SimpleChanges) {
            console.log('ngOnChanges 触发', changes);

            if (changes['initialCount'] && !changes['initialCount'].firstChange) {
                this.currentCount = changes['initialCount'].currentValue;
                console.log('初始计数更新为:', this.currentCount);
            }

            if (changes['maxCount']) {
                console.log('最大计数从', changes['maxCount'].previousValue,
                            '变为', changes['maxCount'].currentValue);
            }
        }

        // 2. ngOnInit - 组件初始化
        ngOnInit() {
            console.log('ngOnInit 触发');
            this.currentCount = this.initialCount;
            this.previousCount = this.currentCount;

            // 模拟从API获取用户数据
            this.users = this.generateRandomUsers(5);

            // 设置定时器更新计数
            this.countSubscription = interval(5000).subscribe(() => {
                console.log('定时检查用户数...');
                this.checkCount();
            });
        }

        // 3. ngDoCheck - 自定义变更检测
        ngDoCheck() {
            console.log('ngDoCheck 触发');

            if (this.currentCount !== this.previousCount) {
                this.changeCount++;
                console.log(`计数从 ${this.previousCount} 变为 ${this.currentCount}`);
                this.previousCount = this.currentCount;

                // 当计数变化时更新用户列表
                this.updateUsers(); 
            }
        }

        // 4. ngAfterContentInit - 内容投影初始化后
        ngAfterContentInit() {
            console.log('ngAfterContentInit 触发');
            if (this.projectedContent) {
                console.log('投影内容:', this.projectedContent.nativeElement.textContent);
            }
        }

        // 5. ngAfterContentChecked - 内容投影检查后
        ngAfterContentChecked() {
            console.log('ngAfterContentChecked 触发');
        }

        // 6. ngAfterViewInit - 视图初始化后
        ngAfterViewInit() {
            console.log('ngAfterViewInit 触发');
            console.log('标题元素:', this.counterTitle.nativeElement.textContent);
            console.log('用户列表组件:', this.userListComponent);
        }

        // 7. ngAfterViewChecked - 视图检查后
        ngAfterViewChecked() {
            console.log('ngAfterViewChecked 触发');
        }

        // 8. ngOnDestroy - 组件销毁前
        ngOnDestroy() {
            console.log('ngOnDestroy 触发');
            this.countSubscription.unsubscribe();
            console.log('已取消订阅定时器');
        }

        // 组件方法
        increment() {
            if (this.currentCount < this.maxCount) {
                this.currentCount++;
            }
        }

        decrement() {
            if (this.currentCount > 0) {
                this.currentCount--;
            }
        }

        getUsers(): string[] {
            return this.users.slice(0, this.currentCount);
        }

        private generateRandomUsers(count: number): string[] {
            const names = ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank', 'Grace', 'Henry'];
            return Array.from({length: count}, () => {
                const randomName = names[Math.floor(Math.random() * names.length)];
                return `${randomName}${Math.floor(Math.random() * 100)}`;
            });
        }

        private updateUsers() {
            if (this.currentCount > this.users.length) {
                const newUsers = this.generateRandomUsers(this.currentCount - this.users.length);
                this.users = [...this.users, ...newUsers];  
            }
        }

        private checkCount() {
            console.log('当前用户数检查:', this.currentCount);
            if (this.currentCount > this.maxCount * 0.8) {
                console.warn('警告: 用户数接近最大值!');
            }
        }
    }
    ```

2. 调用组件

    ```ts
    import { Component } from '@angular/core';

    @Component({
        selector: 'case-02',
        template: `
            <h1>Angular 生命周期演示</h1>

            <app-user-counter
            [initialCount]="initialCount"
            [maxCount]="maxCount">

            <div #projectedContent class="projected-content">
                这是投影到计数器组件中的内容
            </div>
            </app-user-counter>

            <div class="controls">
                <button (click)="changeInitialCount()">更改初始计数</button>
                <button (click)="changeMaxCount()">更改最大计数</button>
                <button (click)="toggleCounter()">{{showCounter ? '移除' : '添加'}}计数器</button>
            </div>
        `,
        styles: [`
            .projected-content {
                padding: 10px;
                background-color: #eef;
                margin: 10px 0;
            }
            .controls {
                margin: 20px;
            }
            button {
                margin-right: 10px;
            }
        `]
    })
    export class Case02Component {
        initialCount = 3;
        maxCount = 5;
        showCounter = true;

        changeInitialCount() {
            this.initialCount = Math.floor(Math.random() * 5) + 1;
        }

        changeMaxCount() {
            this.maxCount = Math.floor(Math.random() * 10) + 5;
        }

        toggleCounter() {
            this.showCounter = !this.showCounter;
        }
    }
    ```

3. 路由

    ```ts
     {
        path: 'case',
        component: Case02Component,
        title: '综合案例'
    },
    ```
