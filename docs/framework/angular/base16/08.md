
# 八、网络路径

## 8.1 前端路由

### 8.1.1 路由文件简单配置

1. 模块文件设置

    - 普通路由模块

        ```ts
        import { Component } from '@angular/core';

        // 普通路由
        @Component({
            selector: 'route-home',
            template: `
                <h1>首页</h1>
                <span>可重定向进入</span>
            `,
        })
        export class HomeComponent {}

        // 普通路由
        @Component({
            selector: 'route-about',
            template: `
                <h1>关于</h1>
            `,
        })
        export class AboutComponent {}

        // 普通路由
        @Component({
            selector: 'route-contact',
            template: `
                <h1>关于</h1>
            `,
        })
        export class ContactComponent {}
        ```
    - 带参数路由模块

        ```ts
        import { Component,OnInit } from '@angular/core';
        import { ActivatedRoute } from '@angular/router';

        // 普通路由
        @Component({
            selector: 'route-home',
            template: `
                <h1>带参数路由</h1>
            `,
        })
        export class UserProfileComponent implements OnInit {

            // 依赖注入
            constructor(private route: ActivatedRoute) {}

            ngOnInit() {

                // 方式1: snapshot (适用于只获取一次)
                const id1 = this.route.snapshot.paramMap.get('id');

                // 方式2: observable (适用于参数会变化的情况)
                this.route.paramMap.subscribe((params) => {
                    const id2 = params.get('id');
                });
            }
        }
        ```
    - 子路由模块

        ```ts
        import { Component } from '@angular/core';

        // 默认子路由
        @Component({
            selector: 'route-product-01',
            template: `
                <h1>默认子路由</h1>
            `,
        })
        export class Product01Component {}

        // 普通路由
        @Component({
            selector: 'route-product-02',
            template: `
                <h1>普通路由</h1>
            `,
        })
        export class Product02Component {}

        // 带参数路由
        @Component({
            selector: 'route-product-03',
            template: `
                <h1>带参数路由</h1>
            `,
        })
        export class Product03Component {}
        ```
    - 404模块

        ```ts
        import { Component } from '@angular/core';

        // 无后缀路由
        @Component({
            selector: 'route-404',
            template: `
                <h1>404</h1>
            `,
        })
        export class PageNotFoundComponent {}
        ```
2. 路由文件配置 app-routing.module.ts

    ```ts
    import { NgModule } from '@angular/core';
    import { RouterModule, Routes } from '@angular/router';
    import { HomeComponent,AboutComponent,ContactComponent } from './01-routes/01.component';
    import { UserProfileComponent } from './01-routes/02.component';
    import { Product01Component,Product02Component,Product03Component } from './01-routes/03.component';
    import { PageNotFoundComponent } from './01-routes/04.component';

    const routes: Routes = [
        // 1. 路由重定向 - 默认路径重定向到首页
        { path: '', redirectTo: '/home', pathMatch: 'full' },

        // 2. 普通路由
        { path: 'home', component: HomeComponent, title: '首页' },
        { path: 'about', component: AboutComponent, title: '关于我们' },
        { path: 'contact', component: ContactComponent, title: '联系我们' },

        // 3. 带参数的路由
        { path: 'user/:id', component: UserProfileComponent },

        // 4. 含有子路由的路由
        {
            path: 'products',
            children: [
                { path: '', component: Product01Component }, // 默认子路由 /products
                { path: 'count', component: Product02Component },  // 普通路由
                { path: ':id', component: Product03Component } // /products/123
            ]
        },

        // 5. 404页面 - 通配符路由必须放在最后
        { path: '**', component: PageNotFoundComponent, title: '页面未找到' },

    ];

    @NgModule({
        imports: [RouterModule.forRoot(routes)],
        exports: [RouterModule],
    })
    export class AppRoutingModule {}
    ```
3. 在根模块中导入路由模块

    ```ts
    import { AppRoutingModule } from './app-routing.module';

    @NgModule({
        declarations: [/* 组件列表 */],
        imports: [
            AppRoutingModule
            /* 其他模块 */
        ],
        bootstrap: [AppComponent]
    })
    export class AppModule { }
    ```

### 8.1.2 懒加载路由

懒加载是Angular中优化应用性能的重要技术，它允许你将应用拆分为多个功能模块，并按需加载这些模块。

1. 创建新的模块

    ```sh
    ng generate module lazy --route lazy 
    ```
2. 文件内容

    - 组件 lazy.component.ts

        ```ts
        import { Component } from '@angular/core';

        @Component({
            selector: 'lazy-01',
            template:`
                <h1>懒加载路由1</h1>
            `
        })
        export class Lazy01Component {}


        @Component({
            selector: 'lazy-02',
            template:`
                <h1>懒加载路由2</h1>
            `
        })
        export class Lazy02Component {}


        @Component({
            selector: 'lazy-03',
            template:`
                <h1>懒加载路由3</h1>
            `
        })
        export class Lazy03Component {}

        ```
    - 路由 lazy-routing.module.ts

        ```ts
        import { NgModule } from '@angular/core';
        import { RouterModule, Routes } from '@angular/router';
        import { Lazy01Component,Lazy02Component,Lazy03Component } from './lazy.component';

        const routes: Routes = [
            { path: '01', component: Lazy01Component },
            { path: '02', component: Lazy02Component },
            { path: '03', component: Lazy03Component },
        ];

        @NgModule({
            imports: [RouterModule.forChild(routes)],
            exports: [RouterModule]
        })
        export class LazyRoutingModule { }
        ```
    - 模块入口 lazy.module.ts

        ```ts
        import { NgModule } from '@angular/core';
        import { CommonModule } from '@angular/common';

        import { LazyRoutingModule } from './lazy-routing.module';
        import { Lazy01Component,Lazy02Component,Lazy03Component } from './lazy.component';

        @NgModule({
            declarations: [
                Lazy01Component,
                Lazy02Component,
                Lazy03Component
            ],
            imports: [
                CommonModule,
                LazyRoutingModule
            ]
        })
        export class LazyModule { }
        ```

3. 主路由懒加载 功能模块

    ```ts
    // 懒加载路由
    {
        path: 'lazy',
        loadChildren: () => import('./lazyModule/lazy.module').then(m => m.LazyModule)
    },
    ```


### 8.1.3 声明式路由

1. 核心指令
    - routerLink 指令
    
        routerLink 是声明式路由的核心指令，用于在模板中创建导航链接。

        ```html
        <!-- 基本用法 -->
            <a routerLink="/home">首页</a>
        
        <!-- 动态路径 -->
            <a [routerLink]="['/products', productId]">产品详情</a>
        

        <!-- 相对路径导航 -->

            <!-- 相对于当前路由 -->
            <a [routerLink]="['../sibling']">兄弟路由</a>
            <!-- 相对于特定路由 -->
            <a [routerLink]="['./child']" [relativeTo]="currentRoute">子路由</a>
        ```

    - routerLinkActive 指令

        用于为活动路由链接添加 CSS 类。

        

        ```html
        <!-- 基本用法 -->
        <a routerLink="/home" routerLinkActive="active">首页</a>
        
        <!-- 精确匹配 -->
        <a routerLink="/home" routerLinkActive="active" [routerLinkActiveOptions]="{exact: true}">首页</a>

        <!-- 多个类名： -->
        <a routerLink="/home" routerLinkActive="active selected">首页</a>
        ```


2. 路由参数处理

```html

<!-- 路径参数 -->

    <!-- 传递单个参数 -->
    <a [routerLink]="['/products', product.id]">产品详情</a>

    <!-- 传递多个参数 -->
    <a [routerLink]="['/category', category.id, 'product', product.id]">产品详情</a>
    
<!-- 查询参数 -->
    <!-- 静态查询参数 -->
    <a [routerLink]="['/products']" [queryParams]="{page: 1, sort: 'price'}">第一页产品</a>

    <!-- 动态查询参数 -->
    <a [routerLink]="['/products']" [queryParams]="{page: currentPage, sort: sortBy}">产品列表</a>

<!-- 片段标识 -->
    <a [routerLink]="['/help']" fragment="faq">常见问题</a>
```

3. 高级路由配置
    -  命名路由出口
        - 配置命名出口：

            ```ts
            // app-routing.module.ts
            {
                path: 'messages',
                component: MessagesComponent,
                outlet: 'popup'
            }
            ```
        - 模板中使用：

            ```html
            <a [routerLink]="[{ outlets: { popup: ['messages'] } }]">显示消息</a>
            <router-outlet name="popup"></router-outlet>
            ```

    - 多路由出口导航
        ```html
        <!-- 同时更新主出口和侧边栏出口 -->

        <a [routerLink]="[
        { outlets: 
            { 
            primary: ['products'], 
            sidebar: ['categories'] 
            }
        }
        ]">产品与分类</a>
        ```

4. 路由状态与事件
    - 获取路由数据

        在组件中获取路由参数：

        ```ts
        import { ActivatedRoute } from '@angular/router';

        constructor(private route: ActivatedRoute) {
            // 路径参数
            this.productId = this.route.snapshot.paramMap.get('id');
            
            // 查询参数
            this.page = this.route.snapshot.queryParamMap.get('page');
            
            // 片段
            this.section = this.route.snapshot.fragment;
        }
        ```

    - 响应式参数变化

        ```ts
        ngOnInit() {
            this.route.paramMap.subscribe(params => {
                this.productId = params.get('id');
                this.loadProduct();
            });
            
            this.route.queryParamMap.subscribe(params => {
                this.page = params.get('page');
                this.loadData();
            });
        }
        ```

5. 代码中简单使用

    由于用了routerLink指令，必须要在app.moudle.ts中注册

    ```ts
    import { Component } from '@angular/core';

    @Component({
        selector: 'use-01',
        template:`
            <a routerLink="/home">首页</a><br>
            <a routerLink="/about">关于</a><br>
            <a routerLink="/contact">内容</a>
        `
    })
    export class Use01Component {}
    ```

### 8.1.4 编程式导航


1. 基本导航方法

    - `navigate()` 方法

        最常用的导航方法，接收一个链接参数数组：

        ```ts
        // 绝对路径导航
        this.router.navigate(['/products']);

        // 带参数导航
        this.router.navigate(['/products', productId]);

        // 多级路径导航
        this.router.navigate(['/admin', 'users', userId]);
        ```

    - `navigateByUrl()` 方法

        直接使用完整URL字符串进行导航：

        ```ts
        this.router.navigateByUrl('/products/123?sort=price#details');
        ```

2. 高级导航选项

    -  导航配置对象

        `navigate()` 方法的第二个参数可以接受配置对象：

        ```ts
        this.router.navigate(['/products'], {
            queryParams: { page: 1, sort: 'price' },
            fragment: 'section2',
            queryParamsHandling: 'merge', // 或 'preserve'
            preserveFragment: true,
            skipLocationChange: false,
            replaceUrl: false
        });
        ```

    - 相对路径导航

        ```ts
        import { ActivatedRoute } from '@angular/router';

        constructor(
            private router: Router,
            private route: ActivatedRoute
        ) {}

        // 相对于当前路由
        this.router.navigate(['../sibling'], { relativeTo: this.route });

        // 相对于父路由
        this.router.navigate(['../../parent'], { relativeTo: this.route });

        // 相对于根路由
        this.router.navigate(['/absolute']);
        ```

3. 参数传递技术

    - 路径参数

        ```ts
        // 传递参数
        this.router.navigate(['/products', productId]);

        // 获取参数 (在目标组件中)
        this.productId = this.route.snapshot.paramMap.get('id');
        ```

    -  查询参数

        ```ts
        // 设置查询参数
        this.router.navigate(['/products'], {
        queryParams: { page: 1, sort: 'price' }
        });

        // 获取查询参数
        this.page = this.route.snapshot.queryParamMap.get('page');
        ```

    -  状态数据传递

        ```ts
        // 传递状态数据
        this.router.navigate(['/checkout'], {
        state: { discountCode: 'SUMMER2023' }
        });

        // 获取状态数据 (在目标组件中)
        this.discountCode = this.router.getCurrentNavigation()?.extras.state?.discountCode;
        ```
4. 导航事件与生命周期

    - 监听导航事件
        ```ts
        import { NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';

        constructor(private router: Router) {
            this.router.events.subscribe(event => {
                if (event instanceof NavigationStart) {
                    this.showLoading = true;
                }
                
                if (event instanceof NavigationEnd || 
                    event instanceof NavigationCancel || 
                    event instanceof NavigationError) {
                    this.showLoading = false;
                }
            });
        }
        ```

    -  取消当前导航
        ```ts
        import { NavigationExtras } from '@angular/router';

        let navigation: Promise<boolean>;

        startNavigation() {
            navigation = this.router.navigate(['/long-process']);
        }

        cancelNavigation() {
            if (navigation) {
                // 实际应用中需要更复杂的取消逻辑
                this.router.navigate(['/cancel-page']);
            }
        }
        ```

5. 高级场景实现

    - 重定向后保留参数

        ```ts
        login() {
        const returnUrl = this.route.snapshot.queryParamMap.get('returnUrl') || '/';
            this.authService.login().subscribe(() => {
                this.router.navigateByUrl(returnUrl);
            });
        }
        ```
    - 动态路由生成

        ```ts
        generateDynamicRoute() {
            const dynamicPath = this.generatePathBasedOnUserRole();
            this.router.navigate([dynamicPath]);
        }

        private generatePathBasedOnUserRole(): string {
            return this.userService.isAdmin() ? '/admin/dashboard' : '/user/dashboard';
        }
        ```
    - 页面滚动控制

        ```ts
        navigateToSection(sectionId: string) {
            this.router.navigate([], {
                fragment: sectionId,
                scrollPositionRestoration: 'enabled',
                anchorScrolling: 'enabled'
            });
        }
        ```
6. 代码中简单使用

    ```ts
    import { Component } from '@angular/core';
    import { Router } from '@angular/router';

    @Component({
        selector: 'use-02',
        template:`
            <a (click)="enterHome()">首页</a><br>
            <a (click)="enterAbout()">关于</a><br>
            <a (click)="enterContact()">内容</a>
        `
    })
    export class Use02Component {
        constructor(private router: Router) {}
        enterHome(){
            this.router.navigate(['/home']);
        }
        enterAbout(){
            this.router.navigate(['/about']);
        }
        enterContact(){
            this.router.navigate(['/contact']);
        }
    }

    ```


## 8.2 路由守卫（权限控制）

### 8.2.1 守卫介绍

1. 守卫类型
    - CanActivate：控制是否可以进入路由
    - CanActivateChild：控制是否可以进入子路由
    - CanDeactivate：控制是否可以离开路由
    - CanMatch (CanLoad 已过时)：控制是否可以延迟加载特性模块
    - Resolve：在路由激活前获取路由数据（严格来说不是守卫，但常用于类似场景）

2. 守卫执行顺序
    - CanDeactivate (先检查当前路由是否可以离开)
    - CanMatch (如果路由是延迟加载的)
    - CanActivate 和 CanActivateChild
    - Resolve

3. 实际应用场景
    - 身份验证：使用 CanActivate 限制未登录用户访问某些路由
    - 权限控制：使用 CanActivateChild 控制对子路由的访问
    - 表单保护：使用 CanDeactivate 防止用户意外离开未保存的表单
    - 模块懒加载控制：使用 CanMatch 控制哪些用户可以加载特定模块
    - 数据预加载：使用 Resolve 在路由激活前获取必要数据

4. 函数式守卫
    - 所有守卫现在都有对应的函数式版本（*Fn 后缀）
    - 使用 inject() 函数获取依赖而不是构造函数注入
    - 更简洁的语法，适合简单场景

### 8.2.2 CanActivate

1. 用户登录 auth.service.ts

    ```ts
    import { Injectable } from '@angular/core';
    import { BehaviorSubject } from 'rxjs';

    @Injectable({ providedIn: 'root' })
    export class AuthService {
        private isLoggedInSubject = new BehaviorSubject<boolean>(false);
        isLoggedIn$ = this.isLoggedInSubject.asObservable();

        login(username: string, password: string): boolean {
            // 实际项目中这里应该是API调用
            if (username === 'admin' && password === '123456') {
            this.isLoggedInSubject.next(true);
            return true;
            }
            return false;
        }

        logout(): void {
            this.isLoggedInSubject.next(false);
        }

        isAuthenticated(): boolean {
            return this.isLoggedInSubject.value;
        }
    }
    ```
2. 路由守卫 auth.guard.ts

    ```ts
    import { CanActivateFn } from '@angular/router';
    import { inject } from '@angular/core';
    import { AuthService } from './auth.service';
    import { Router } from '@angular/router';

    export const authGuard: CanActivateFn = (route, state) => {
        const authService = inject(AuthService);
        const router = inject(Router);

        if (authService.isAuthenticated()) {
            return true;
        }

        // 重定向到登录页面并携带返回URL
        router.navigate(['/login'], { queryParams: { returnUrl: state.url } });
        return false;
    };
    ```
3. 登录页面 login.component.ts

    ```ts
    import { Component } from '@angular/core';
    import { AuthService } from './auth.service';
    import { Router, ActivatedRoute } from '@angular/router';

    @Component({
        selector: 'app-login',
        template: `
            <div class="login-container">
                <h2>用户登录</h2>
                <form (ngSubmit)="onSubmit()">
                    <div>
                        <label>用户:</label>
                        <input type="text" [(ngModel)]="username" name="username" required>
                    </div>
                    <div>
                        <label>密码:</label>
                        <input type="password" [(ngModel)]="password" name="password" required>
                    </div>
                    <button type="submit">登录</button>
                </form>
                <div *ngIf="error" class="error">{{ error }}</div>
            </div>
        `,
    })
    export class LoginComponent {
        username = '';
        password = '';
        error = '';
        returnUrl = '';

        constructor(
            private authService: AuthService,
            private router: Router,
            private route: ActivatedRoute
        ) {
            // 获取当前用户跳转前的url 跳转后再次进入
            this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';
        }

        onSubmit(): void {
            // 使用 authService 判断是否登录
            if (this.authService.login(this.username, this.password)) {
                this.router.navigateByUrl(this.returnUrl);
            } else {
                this.error = 'Invalid credentials';
            }
        }
    }
    ```
4. 主页

    ```ts
    import { Component } from '@angular/core';

    @Component({
        selector: 'app-home',
        template: `
            <h1>首页</h1>
        `,
    })
    export class HomeComponent {}

    ```

5. 路由配置

    ```ts
    // 登录
    { path: 'login', component: LoginComponent },
    // 自动跳转到主页
    { path: '', redirectTo: '/home', pathMatch: 'full' },
    // 使用authGuard进行路由守卫
    { path: 'home', component: HomeComponent,canActivate: [authGuard]},
    ```

6. 页面效果

    ![](/framework/angular/base16/050.gif)

### 8.2.3 CanActivateChild

1. 守卫设置 admin.guard.ts

    ```ts
    import { CanActivateChildFn } from '@angular/router';
    import { inject } from '@angular/core';
    import { Router } from '@angular/router';

    export const adminGuard: CanActivateChildFn = (childRoute, state) => {

        // 改变role页面效果不同
        const user = {
            name: 'zhangsan',
            role: 'admin1',
        };

        const router = inject(Router);

        // 判断用户权限
        if ("admin" === user.role) {
            return true;
        }

        // 访问拒绝页面
        router.navigate(['/access-denied']);
        return false;
    };

    ```
2. 子路由 child.componet.ts

    ```ts
    import { Component } from '@angular/core';

    // 子路由1
    @Component({
        selector: 'child-route-01',
        template: `
            <h1>子路由1</h1>
        `,
    })
    export class Child01Component {}

    // 子路由2
    @Component({
        selector: 'child-route-02',
        template: `
            <h1>子路由2</h1>
        `,
    })
    export class Child02Component {}

    // 子路由3
    @Component({
        selector: 'child-route-03',
        template: `
            <h1>子路由3</h1>
        `,
    })
    export class Child03Component {}
    ```
3. 权限不足页面 access-denied.component.ts

    ```ts
    import { Component } from '@angular/core';

    @Component({
        selector: 'access-denied',
        template: `
            <h1>访问被拒绝</h1>
        `,
    })
    export class AccessDeniedComponent {}
    ```

4. 路由配置

    ```ts
    // 权限不足页面
    { path: 'access-denied', component: AccessDeniedComponent},
    {
        path: 'admin',
        children:[
            { path: '', redirectTo: '01', pathMatch: 'full' },
            { path: '01', component: Child01Component, title: '子页面1' },
            { path: '02', component: Child02Component, title: '子页面2' },
            { path: '03', component: Child03Component, title: '子页面3' },
        ],
        // 判断子路由守卫是否有权限
        canActivateChild: [adminGuard]
    },
    ```
5. 页面效果

    ![](/framework/angular/base16/051.gif)

### 8.2.4 CanDeactivate

1. 路由守卫 unsaved-changes.guard.ts

    ```ts
    import { CanDeactivateFn } from '@angular/router';
    import { inject } from '@angular/core';
    import { ConfirmDialogService } from './confirm-dialog.service';
    import {Observable} from 'rxjs'

    export interface CanComponentDeactivate {
        canDeactivate: () => boolean | Promise<boolean> | Observable<boolean>;
    }

    export const unsavedChangesGuard: CanDeactivateFn<CanComponentDeactivate> =
    (component: CanComponentDeactivate) => {
        const confirmService = inject(ConfirmDialogService);

        console.log("步骤一：判断是是否提交!");

        return component.canDeactivate() ?
        component.canDeactivate() :
        confirmService.confirm('您有未保存的更改，要离开吗？');
    };
    ```

2. 调用页面 edit-profile.component.ts

    ```ts
    import { Component } from '@angular/core';
    import { FormGroup, FormBuilder, Validators } from '@angular/forms';
    import { CanComponentDeactivate } from './unsaved-changes.guard';

    @Component({
        selector: 'app-edit-profile',
        template: `
            <form [formGroup]="profileForm" (ngSubmit)="onSubmit()">
                <!-- 表单字段 -->
                <div>
                    <label>用户名: </label>
                    <input type="text" formControlName="name">
                </div>

                <div>
                    <label>邮箱: </label>
                    <input type="email" formControlName="email">
                </div>
                <button type="submit">保存</button>
            </form>
            <hr>
            <button routerLink="/">跳转到主页</button>
        `
    })
    export class EditProfileComponent implements CanComponentDeactivate {
        profileForm: FormGroup;
        saved = false;

        constructor(private fb: FormBuilder) {
            // 验证
            this.profileForm = this.fb.group({
                name: ['', Validators.required],
                email: ['', [Validators.required, Validators.email]]
            });
        }

        // 用于守卫的验证
        canDeactivate(): boolean {
            return this.saved || !this.profileForm.dirty;
        }

        onSubmit(): void {
            console.log(this.profileForm);

            if (this.profileForm.valid) {
                // 保存逻辑后 可以进行跳转
                this.saved = true;
            }else{
                console.log("验证失败！");
            }
        }
    }
    ```


3. 弹窗

    - 弹窗模块

        ```ts
        import { Injectable } from '@angular/core';
        import { MatDialog } from '@angular/material/dialog';
        import { Observable } from 'rxjs';
        import { ConfirmDialogComponent } from './confirm-dialog.component';

        @Injectable({ providedIn: 'root' })
        export class ConfirmDialogService {
            constructor(private dialog: MatDialog) {}

            confirm(message: string): Observable<boolean> {
                console.log("步骤二：初始化弹框！");

                const dialogRef = this.dialog.open(ConfirmDialogComponent, {
                    width: '350px',
                    data: { message }
                });

                return dialogRef.afterClosed();
            }
        }
        ```
    - 弹窗模板

        ```ts
        import { Component, Inject } from '@angular/core';
        import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';

        @Component({
            selector: 'app-confirm-dialog',
            template: `
                <h2 mat-dialog-title>{{ data.title }}</h2>

                <mat-dialog-content>
                    <p>{{ data.message }}</p>
                </mat-dialog-content>

                <mat-dialog-actions align="end">
                    <button mat-button (click)="onCancel()">{{ data.cancelText }}</button>
                    <button mat-raised-button color="primary" (click)="onConfirm()">
                        {{ data.confirmText }}
                    </button>
                </mat-dialog-actions>
            `,
            styles:[`
                /* 可以添加自定义样式 */
                .mat-dialog-content {
                    padding: 20px 24px;
                    margin: 0;
                    font-size: 16px;
                    line-height: 1.5;
                }

                .mat-dialog-actions {
                    padding: 8px 24px;
                    margin-bottom: 0;
                    justify-content: flex-end;
                }

                button {
                    margin-left: 8px;
                }
            `]
        })
        export class ConfirmDialogComponent {
            constructor(
                public dialogRef: MatDialogRef<ConfirmDialogComponent>,
                @Inject(MAT_DIALOG_DATA) public data: {
                    title?: string;
                    message: string;
                    confirmText?: string;
                    cancelText?: string;
                }
            ) {
                console.log("步骤三：调用弹框模板！");
                // 设置默认值
                this.data.title = this.data.title || '确认';
                this.data.confirmText = this.data.confirmText || '确认';
                this.data.cancelText = this.data.cancelText || '取消';
            }

            onConfirm(): void {
                this.dialogRef.close(true);
            }

            onCancel(): void {
                this.dialogRef.close(false);
            }
        }

        ```
4. 路由

    ```ts
    {
        path: 'profile',
        component: EditProfileComponent,
        // 判断表单是否提交了
        canDeactivate: [unsavedChangesGuard]
    },
    ```

5. 运行结果

    ![](/framework/angular/base16/052.gif)

### 8.2.5 CanMatch

1. 路由守卫

    ```ts
    import { CanMatchFn  } from '@angular/router';
    import { inject } from '@angular/core';
    import { Router } from '@angular/router';

    export const adminModuleGuard: CanMatchFn  = (childRoute, state) => {

        // 改变role页面效果不同
        const user = {
            name: 'zhangsan',
            role: 'admin2',
        };

        const router = inject(Router);

        // 判断用户权限
        if ("admin" === user.role) {
            return true;
        }

        // 访问拒绝页面
        router.navigate(['/access-denied']);
        return false;
    };
    ```

2. 路由配置

    ```ts
    {
        path: 'lazy',
        loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule),
        canMatch: [adminModuleGuard]  // 使用 canMatch 替代 canLoad
    },
    ```

3. 运行结果

    ![](/framework/angular/base16/053.gif)

### 8.2.6 Resolve

1. 路由守卫

    ```ts
    import { ResolveFn } from '@angular/router';
    import { inject } from '@angular/core';
    import { UserService } from './user.service';
    import { User } from './user.model';

    export const userResolver: ResolveFn<User> = (route, state) => {
        const userService = inject(UserService);
        // 获取路由中的 id
        const userId = parseInt(route.paramMap.get('id')!);

        // 通过 id 查询数据
        return userService.getUser(userId);
    };

    ```
2. 页面展示

    ```ts
    import { Component, OnInit } from '@angular/core';
    import { ActivatedRoute } from '@angular/router';

    @Component({
        selector: 'app-user-detail',
        template: `
            <div *ngIf="user">
            <h2>{{ user.name }}</h2>
            <p>邮箱: {{ user.email }}</p>
            </div>
        `
    })
    export class UserDetailComponent implements OnInit {
        user: any;

        constructor(private route: ActivatedRoute) {}

        ngOnInit() {
            this.user = this.route.snapshot.data['user'];
        }
    }

    ```
3. service 调用

    ```ts
    import { Injectable } from '@angular/core';
    import { delay, of,Observable } from 'rxjs';

    interface User {
        id: number;
        name: string;
        email: string;
    }

    @Injectable({ providedIn: 'root' })
    export class UserService {

        private mockUsers: User[] = [
            { id: 1, name: 'zhangsan', email: 'zhangsan@163.com' },
            { id: 2, name: 'lisi', email: 'lisi@163.com' },
            { id: 3, name: 'wangwu', email: 'wangwu@163.com' },
            { id: 4, name: 'zhaoliu', email: 'zhaoliu@163.com' }
        ];

        getUser(id: number): Observable<User> {
            // 如果没有查询到返回默认用户
            const user = this.mockUsers.find(u => u.id === id) || this.getDefaultUser();

            // 模拟网络延迟
            return of(user).pipe(delay(500));
        }

        private getDefaultUser(): User {
            return {
                id: 0,
                name: 'Unknown',
                email: '空',
            };
        }
    }

    ```
4. 实体模型

    ```ts
    export class User {
        id: number = 0;
        name: string ="";
        email: string = "";
    }
    ```
5. 路由配置

    ```ts
    {
        path: 'user/:id',
        component: UserDetailComponent,
        resolve: { user: userResolver }
    },
    ```
6. 运行结果

    ![](/framework/angular/base16/054.gif)

## 8.3 向后端请求

### 8.3.1 构建后端数据

1. 安装json-server

    ```sh
    npm install -g json-server
    ```
2. json文件

    ```json
    {
        "users":[
            {"id":1,"userName":"张三","age":12,"sex":"男"},
            {"id":2,"userName":"李四","age":21,"sex":"女"},
            {"id":3,"userName":"王五","age":56,"sex":"男"},
            {"id":4,"userName":"赵六","age":23,"sex":"女"},
            {"id":5,"userName":"严七","age":12,"sex":"男"},
            {"id":6,"userName":"沈八","age":43,"sex":"女"},
            {"id":7,"userName":"钱九","age":13,"sex":"男"},
            {"id":8,"userName":"张十","age":12,"sex":"女"}
        ]
    }
    ```

### 8.3.2 增删改查

1. 导入 HttpClientModule


    ```ts
    // app.module.ts
    import { HttpClientModule } from '@angular/common/http';

    @NgModule({
        imports: [
            HttpClientModule,
            // 其他模块...
        ]
    })
    export class AppModule {}
    ```

2. 创建服务与添加增删改查方法（所有的返回都是RXJS的Observable）

    ```ts
    import { Injectable } from '@angular/core';
    import { HttpClient } from '@angular/common/http';
    import { Observable } from 'rxjs';

    @Injectable({
        providedIn: 'root', // 全局单例服务
    })
    export class ApiService {

        private apiUrl = 'http://localhost:3000';

        constructor(private http: HttpClient) {}

        /* =================== get 请求  =================== */

        // 获取所有数据
        getAllUsers(): Observable<any[]> {
            return this.http.get<any[]>(`${this.apiUrl}/users`);
        }

        // 带参数的 GET 请求
        getUserById(id: number): Observable<any> {
            return this.http.get<any>(`${this.apiUrl}/users/${id}`);
        }

        // 带查询参数的 GET 请求
        searchUsers(keyword: string): Observable<any[]> {
            return this.http.get<any[]>(`${this.apiUrl}/users`, {
            params: { name: keyword },
            });
        }

        /* =================== post 请求  =================== */

        createUser(user: any): Observable<any> {
            return this.http.post<any>(`${this.apiUrl}/users`, user);
        }

        // 带 headers 的 POST
        createUserWithAuth(user: any): Observable<any> {
            const headers = { Authorization: 'Bearer your-token' };
            return this.http.post<any>(`${this.apiUrl}/users`, user, { headers });
        }

        /* =================== put 请求  =================== */

        // 完整更新 (PUT)
        updateUser(id: number, user: any): Observable<any> {
            return this.http.put<any>(`${this.apiUrl}/users/${id}`, user);
        }

        /* =================== PATCH 请求  =================== */

        // 部分更新 (PATCH)
        partialUpdateUser(id: number, updates: any): Observable<any> {
            return this.http.patch<any>(`${this.apiUrl}/users/${id}`, updates);
        }

        /* =================== delete 请求  =================== */

        // 删除
        deleteUser(id: number): Observable<void> {
            return this.http.delete<void>(`${this.apiUrl}/users/${id}`);
        }
    }
    ```
3. 在组件中使用 01.component.ts

    ```ts
    import { Component, OnInit } from '@angular/core';
    import { ApiService } from '../api.service';
    import { Observable } from 'rxjs';

    @Component({
        selector: 'app-items',
        template: `
            <ul>
                <li *ngFor="let item of items$ | async">
                    姓名：{{ item.userName }}
                    年龄：{{ item.age }}
                    性别：{{ item.sex }}
                </li>
            </ul>

            <hr>
            <h1>新增用户</h1>
            <div>
                姓名：<input type="text" [(ngModel)]="userForm.userName" name="username"/><br>
                年龄：<input type="number" [(ngModel)]="userForm.age" name="age"/><br>
                性别：<select name="sex" id="sex" [(ngModel)]="userForm.sex" >
                        <option value="男">男</option>
                        <option value="女">女</option>
                        </select>
            </div>
            <button (click) = "createUser()">点击新增</button>
        `
    })
    export class HttpComponent implements OnInit {

        // 列表数据
        items$: Observable<any[]> = new Observable<any[]>;

        // 新建用户
        userForm:{userName:string,age:number,sex:string} = {userName:"",age:18,sex:"男"}

        // apiservice 注入
        constructor(private apiService: ApiService) {}

        // 初始化 获取数据
        ngOnInit() {
            this.items$ =  this.apiService.getAllUsers();
        }

        // 按钮点击后 创建用户
        createUser() {
            this.apiService.createUser(this.userForm).subscribe({
                next: (response) => {
                    console.log('创建成功', response);
                    // 刷新列表
                    this.items$ = this.apiService.getAllUsers();
                },
                error: (err) => console.error('创建失败', err)
            });
        }
    }
    ```

4. 运行结果

    ![](/framework/angular/base16/040.gif)

### 8.3.3 网络处理(请求 响应 错误)

1. 拦截器文件 api.interceptor.ts

    ```ts
    import { Injectable } from '@angular/core';
    import {
        HttpRequest,
        HttpHandler,
        HttpEvent,
        HttpInterceptor,
        HttpResponse,
        HttpErrorResponse
    } from '@angular/common/http';
    import { Observable, throwError } from 'rxjs';
    import { catchError, map, tap  } from 'rxjs/operators';

    @Injectable()
    export class ApiInterceptor implements HttpInterceptor {
        intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
            // 请求处理逻辑
            const modifiedRequest = this.handleRequest(request);

            // 执行请求
            return next.handle(modifiedRequest).pipe(
                tap(event => {
                    if (event instanceof HttpResponse) {
                    this.handleResponse(event);
                    }
                }),
                catchError(error => this.handleError(error))
            );
        }

        // 请求拦截器
        private handleRequest(request: HttpRequest<any>): HttpRequest<any> {
            console.log("请求拦截开始",request.url);


            // 从本地存储获取token
            const authToken = localStorage.getItem('auth_token');

            // 克隆请求并添加头部
            return request.clone({
            setHeaders: {
                'Authorization': `Bearer ${authToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            });
        }

        // 响应拦截器
        private handleResponse(response: HttpResponse<any>) {
            console.log("响应拦截开始");

            // 统一处理JSON响应格式
            if (response.body && response.body.code !== undefined) {
            // 如果后端有统一的响应格式，可以在这里处理
            const { code, data, message } = response.body;

            if (code !== 200) {
                throw new Error(message || '请求处理失败');
            }

            // 替换响应体为实际数据
            return response.clone({ body: data });
            }

            // 没有特殊格式，直接返回原始响应
            return response;
        }

        // 错误拦截器
        private handleError(error: HttpErrorResponse): Observable<never> {
            let errorMessage = '发生未知错误';

            if (error.error instanceof ErrorEvent) {
                // 客户端错误
                errorMessage = `客户端错误: ${error.error.message}`;
            } else {
                // 服务器端错误
                switch (error.status) {
                    case 400:
                        errorMessage = error.error?.message || '请求参数错误';
                        break;
                    case 401:
                        errorMessage = '未授权，请重新登录';
                        // 可以在这里跳转到登录页
                        break;
                    case 403:
                        errorMessage = '拒绝访问';
                        break;
                    case 404:
                        errorMessage = '请求资源不存在';
                        break;
                    case 500:
                        errorMessage = '服务器内部错误';
                        break;
                    default:
                        errorMessage = error.error?.message || `服务器错误: ${error.status}`;
                }
            }

            console.error(errorMessage);
            // 可以在这里显示全局错误提示
            return throwError(() => new Error(errorMessage));
        }
    }
    ```


2. 提供出 ApiInterceptor

    ```ts
    // app.module.ts
    import { HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';
    import { ApiInterceptor } from './api.interceptor';

    @NgModule({
        imports: [
            HttpClientModule,
            // 其他模块...
        ],
        providers: [
            { provide: HTTP_INTERCEPTORS, useClass: ApiInterceptor, multi: true }
        ],
    })
    export class AppModule {}
    ```
3. 运行结果

    ![](/framework/angular/base16/041.png)

### 8.3.4 跨域处理

1. 创建代理配置文件
    
    - 在 Angular 项目根目录下创建 proxy.conf.json 文件：

        ```json
        {
            "/api": {
                "target": "http://localhost:3008",
                "secure": false,
                "changeOrigin": true,
                "logLevel": "debug",
                "pathRewrite": {
                    "^/api": ""
                }
            }
        }
        ```
    - 配置参数说明：
        - /api：要代理的路径前缀
        - target：目标服务器地址
        - secure：是否验证 SSL 证书（开发环境通常设为 false）
        - changeOrigin：修改请求头中的 host 为目标 URL
        - logLevel：日志级别（debug/info/warn/error/silent）
        - pathRewrite：路径重写规则

2. 修改启动配置 package.json

    ```json
    "scripts": {
        "start": "ng serve --port 3308 --proxy-config proxy.conf.json"
    },
    ```
3. 修改调用文件

    ```ts{9}
    import { Injectable } from '@angular/core';
    import { HttpClient } from '@angular/common/http';

    @Injectable({
        providedIn: 'root', // 全局单例服务
    })
    export class ApiService {

        private apiUrl = '/api';

        constructor(private http: HttpClient) {}
    }
    ```


  

