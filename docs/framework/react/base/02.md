# 二、面向组件编程

## 2.1 基本理解与使用

1. 安装开发者工具

    ![](/framework/react/base/003.png)

2. 创建函数式组件

    ```js
     // 1.创建函数式组件
    function MyComponent(){
        console.log(this);  // 此处的this是undefined，因为babel编译后开启了严格模式
        return <h2>我是用函数定义的组件（适用于【简单组件】的定义）</h2>
    }
    
    // 2.绑定根节点
    const root = ReactDOM.createRoot(document.querySelector('#test'));
    // 3.渲染虚拟DOM到页面
    root.render(<MyComponent/>);
    ```

    执行了`ReactDOM.render(<MyComponent/>)`...之后，发生了什么？

    1. React解析组件标签，找到了MyComponent组件
    2. 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DMO转为真实DOM，随后呈现在页面中

3. 类的基本知识

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>1_类的基本知识</title>
    </head>
    <body>
        <script>
            /* 
                总结：
                    1. 类中构造器不是必须写的，要对实例进行一些初始化的操作，如果添加指定属性才与
                    2. 如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的。
                    3. 类中所定义的方法，都是放在了类的圆形对象上，供实例去使用
            */


            // 创建一个Person类
            class Person{
                // 构造器方法
                constructor(name,age){
                    // 构造器中的this是谁？ - 类的实例对象
                    this.name = name
                    this.age = age
                    this.school = "尚硅谷"
                }

                // 一般方法
                speak(){
                    // speak方法放在了哪里？ - 类的原型对象上，供实例使用
                    // 通过Person实例调用speak时，speak中的this就是Person实例
                    console.log(`我叫${this.name},我的年龄是${this.age}`);
                }
            }

            // 创建Person的实例对象
            const p1 = new Person("tom",19)
            const p2 = new Person("jerry",55)
            // 查看对象
            console.log(p1);
            console.log(p2);
            // 调用方法
            p1.speak()
            p2.speak()


            // 创建一个Student类，继承于Person类
            class Student extends Person{
                constructor(name,age,grade){
                    super(name,age)
                    this.grade = grade
                }
                // 重写从父类继承过来的方法
                speak(){
                    console.log(`我叫${this.name},我的年龄是${this.age},我读的是${this.grade}`);
                }
                study(){
                    // study方法放在了哪里？ - 类的原型对象上，供实例使用
                    // 通过Student实例调用speak时，speak中的this就是Student实例
                    console.log('我很努力的学习');
                }
            }
            
        </script>
    </body>
    </html>
    ```

4. 创建类式组件

    ```js
    // 1.创建类式组件
    class MyComponent extends React.Component{
        render(){
            // render是放在哪里的？ - MyComponent的原型对象上，供实例调用
            // render中this是谁？ - MyComponent的实例对象 <=> MyComponent组件实例对象
            console.log('render中的this:',this); 
            return <h2>我是用类定义的组件（适用于【复杂组件】的定义）</h2>
        }
    }
    
    // 2.绑定根节点
    const root = ReactDOM.createRoot(document.querySelector('#test'));
    // 3.渲染虚拟DOM到页面
    root.render(<MyComponent/>);
    ```

    执行了`ReactDOM.render(<MyComponent/>)`...之后，发生了什么？

    1. React解析组件标签，找到了MyComponent组件
    2. 发现组件是使用类定义的，随后new 出该类的实例，并通过该实例调用到原型上的render方法。
    3. 将render返回的虚拟DM转为真实DOM，随后呈现在页面中。


## 2.2 组件的三大属性1: state

1. 初始化state 

    ```js
    // 1.创建组件
    class MyComponent extends React.Component{
        // 初始化
        constructor(props){
            super(props)
            // 初始化状态
            this.state = {isHot:true}
        }

        render(){
            const {isHot} = this.state
            return <h1>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
        }
    }
    
    // 2.绑定根节点
    const root = ReactDOM.createRoot(document.querySelector('#test'));
    // 3.渲染虚拟DOM到页面
    root.render(<MyComponent/>);
    ```

2. 绑定事件

    ```js{6,21-23}
     // 1.创建组件
    class MyComponent extends React.Component{
        // 初始化
        constructor(props){
            super(props)
            // 初始化状态
            this.state = {isHot:true}
        }

        render(){
            const {isHot} = this.state
            return <h1 onClick={demo}>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
        }
    }
    
    // 2.绑定根节点
    const root = ReactDOM.createRoot(document.querySelector('#test'));
    // 3.渲染虚拟DOM到页面
    root.render(<MyComponent/>);

    function demo(){
        console.log("标题被点击了");
    }
    ```

3. 类中方法中的this

    - 外部方法中使用this

        ```js{1,9,25}
        let that;
        // 1.创建组件
        class MyComponent extends React.Component{
            // 初始化
            constructor(props){
                super(props)
                // 初始化状态
                this.state = {isHot:true}
                that = this
            }

            render(){
                const {isHot} = this.state
                return <h1 onClick={changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
            }
        }
        
        // 2.绑定根节点
        const root = ReactDOM.createRoot(document.querySelector('#test'));
        // 3.渲染虚拟DOM到页面
        root.render(<MyComponent/>);

        function changeWeather(){
            // 打印状态
            console.log(that.state.isHot);
        }
        ```
    - 内部方法this的问题

        ```js{15-20}
        // 1.创建组件
        class MyComponent extends React.Component{
            // 初始化
            constructor(props){
                super(props)
                // 初始化状态
                this.state = {isHot:true}
            }

            render(){
                const {isHot} = this.state
                return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
            }

            changeWeather(){
                // changeWeather放在哪里？ - weather的原型对象上，供实例使用
                // 由于changeWeather是作为onclick的回调，所以不是通过实例调用的，是直接调用
                // 类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
                console.log(this);
            }
        }
        
        // 2.绑定根节点
        const root = ReactDOM.createRoot(document.querySelector('#test'));
        // 3.渲染虚拟DOM到页面
        root.render(<MyComponent/>);
        ```

    - 内部方法使用this的解决方法

        ```js{9-12}
        // 1.创建组件
        class MyComponent extends React.Component{
            // 初始化
            constructor(props){
                super(props)
                // 初始化状态
                this.state = {isHot:true}

                // 解决changeWeather中this指向问题
                // 1. 更改this指向 
                // 2. 赋值给自身上一个新的changeWeather方法
                this.changeWeather = this.changeWeather.bind(this)
            }

            render(){
                const {isHot} = this.state
                return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
            }

            changeWeather(){
                // changeWeather放在哪里？ - weather的原型对象上，供实例使用
                // 由于changeWeather是作为onclick的回调，所以不是通过实例调用的，是直接调用
                // 类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
                console.log(this);
            }
        }

        // 2.绑定根节点
        const root = ReactDOM.createRoot(document.querySelector('#test'));
        // 3.渲染虚拟DOM到页面
        root.render(<MyComponent/>);
        ```

4. setState的使用

    - 基础使用

        ```js{15-23}
        // 1.创建组件
        class MyComponent extends React.Component{
            // 初始化
            constructor(props){
                super(props)
                // 初始化状态
                this.state = {isHot:true}
                this.changeWeather = this.changeWeather.bind(this)
            }

            render(){
                const {isHot} = this.state
                return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"}</h1>
            }

            changeWeather(){            
                // 获取原来的isHot值
                const isHot = this.state.isHot;
                // 严重注意：状态必须通过setState进行修改
                this.setState({isHot:!isHot})
                
                // 严重注意：状态（state）不可直接更改，下面这行就是直接更改！！！
                // this.state.isHot = !isHot; // 这是错误的写法
            }
        }
        
        // 2.绑定根节点
        const root = ReactDOM.createRoot(document.querySelector('#test'));
        // 3.渲染虚拟DOM到页面
        root.render(<MyComponent/>);
        ```

    - 问题与判断

        ```js{3,13,19,21}
        // 1.创建组件
        class MyComponent extends React.Component{
            // 构造器调用几次？ ———— 1次
            constructor(props){
                console.log('constructor');
                
                super(props)
                // 初始化状态
                this.state = {isHot:true,wind:'微风'}
                this.changeWeather = this.changeWeather.bind(this)
            }

            // render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
            render(){
                const {isHot,wind} = this.state
                return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"},{wind}</h1>
            }

            // changeWeather 调用几次？ ———— 点几次调用几次
            changeWeather(){
                // 问题：更新数据是合并还是替换？ ———— 更新是一种合并，不是替换

                // 获取原来的isHot值
                const isHot = this.state.isHot;
                // 严重注意：状态必须通过setState进行修改
                this.setState({isHot:!isHot})
                
                // 严重注意：状态（state）不可直接更改，下面这行就是直接更改！！！
                // this.state.isHot = !isHot; // 这是错误的写法
            }
        }
        
        // 2.绑定根节点
        const root = ReactDOM.createRoot(document.querySelector('#test'));
        // 3.渲染虚拟DOM到页面
        root.render(<MyComponent/>);
        ```

5. state的简写方式

    ```js
    // 1.创建组件
    class MyComponent extends React.Component{

        // 初始化状态
        state = {isHot:true,wind:'微风'}

        render(){
            const {isHot,wind} = this.state
            return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' :"凉爽"},{wind}</h1>
        }

        // 箭头函数使用外层的this
        // 自定义方法 ———— 要用赋值语句 + 箭头函数和
        changeWeather = () =>{
            const isHot = this.state.isHot;
            this.setState({isHot:!isHot})
        }
    }
    
    // 2.绑定根节点
    const root = ReactDOM.createRoot(document.querySelector('#test'));
    // 3.渲染虚拟DOM到页面
    root.render(<MyComponent/>);
    ```

6. 总结

    - 理解←
        1. state 是组件对象最重要的属性,值是对象(可以包含多个key-value 的组合)
        2. 组件被称为"状态机",通过更新组件的 state 来更新对应的页面显示(重新渲染组件)
    - 强烈注意
        1. 组件中 render 方法中的 this 为组件实例对象
        2. 组件自定义的方法中this为undefined，如何解决?
            1. 强制绑定 this; 通过函数对象的 bind()
            2. 箭头函数
        3. 状态数据，不能直接修改或更新

## 2.3 组件的三大属性2：props

1. props基本使用

    ```js
    class Person extends React.Component{
        // 可以直接使用state 但数据需要从外部传递的
        state = {name:"tom",age:18,sex:"女"}
        render(){
            // 自身的props会出现数据
            console.log(this);
            const {name,age,sex} = this.props

            return (
                <ul>
                    <li>姓名：{name}</li>  
                    <li>年龄：{age}</li>   
                    <li>性别：{sex}</li>   
                </ul>
            )
            
        }
    }

    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Person name="tom" age="18" sex="男"/>);
    ```

2. 批量传递props

    ```js
    class Person extends React.Component{
        render(){
            const {name,age,sex} = this.props
            return (
                <ul>
                    <li>姓名：{name}</li>  
                    <li>年龄：{age}</li>   
                    <li>性别：{sex}</li>   
                </ul>
            )
            
        }
    }
    
    const root = ReactDOM.createRoot(document.querySelector('#test'));

    const p = {name:"zhangsan",age:"19",sex:"女"}

    // 直接使用对象中属性
    // root.render(<Person name={p.name} age={p.age} sex={p.sex}/>);
    root.render(<Person {...p}/>);
    ```
3. props是只读的

    ```js{6-7}
     class Person extends React.Component{
        state = {name:"tom",age:18,sex:"女"}
        render(){
            const {name,age,sex} = this.props

            // props是只读的
            // this.props.name = 'jack' // 此行代码会报错，因为props是只读的

            return (
                <ul>
                    <li>姓名：{name}</li>  
                    <li>年龄：{age}</li>   
                    <li>性别：{sex}</li>     
                </ul>
            )
        }
    }
    
    const root = ReactDOM.createRoot(document.querySelector('#test'));

    const p = {name:"zhangsan",age:"19",sex:"女"}
    root.render(<Person {...p}/>);
    ```

4. 对props的限制

    1. recat提供的类型检查
        - propTypes:类型检查，还可以限制不能为空
        - defaultProps：默认值

    2. 下载插件 

        地址：`https://unpkg.com/prop-types@15.8.1/prop-types.min.js`

    3. 代码

        ```html
        <!-- 准备好容器 -->
        <div id="test1"></div>
        <div id="test2"></div>
        <div id="test3"></div>

        <!-- 引入react核心库 -->
        <script type="text/javascript" src="../js/react.development.js"></script>
        <!-- 引入react-dom，用于支持react操作DOM -->
        <script type="text/javascript" src="../js/react-dom.development.js"></script>
        <!-- 引入babel，用于将jsx转为js -->
        <script type="text/javascript" src="../js/babel.min.js"></script>
        <!-- 限制props传递 -->
        <script type="text/javascript" src="../js/prop-types.min.js"></script>

        <script type="text/babel">
            class Person extends React.Component{
                render(){
                    // 自身的props会出现数据
                    console.log(this);
                    const {name,age,sex} = this.props

                    return (
                        <ul>
                            <li>姓名：{name}</li>  
                            <li>年龄：{age}</li>   
                            <li>性别：{sex}</li>    
                        </ul>
                    )
                    
                }
            }
            // 对标签属性进行类型，必要性的限制
            Person.propTypes = {
                name:PropTypes.string.isRequired,   // 限制name必传，且为字符串
                sex:PropTypes.string,   // 限制sex为字符串
                age:PropTypes.number,   // 限制age为数值
                speak:PropTypes.func    // 限制speak为函数
            }

            // 指定默认标签属性值
            Person.defaultProps = {
                sex:"男", // sex默认值为男
                age:18  // age默认值为18
            }

            
            const root1 = ReactDOM.createRoot(document.querySelector('#test1'));
            const root2 = ReactDOM.createRoot(document.querySelector('#test2'));
            const root3 = ReactDOM.createRoot(document.querySelector('#test3'));

            root1.render(<Person name="jerry" speak={speak}/>)
            root2.render(<Person name="tom" age={18} sex="女"/>)

            const p = {name:"zhangsan",age:"19",sex:"女"}
            // 直接使用对象中属性
            root3.render(<Person {...p}/>);

            function speak(){
                
            }
        </script>
        ```
    4. 运行结果

        ![](/framework/react/base/004.png)

5. props的简写方式

    ```js
    class Person extends React.Component{
        // 对标签属性进行类型，必要性的限制
        static propTypes = {
            name:PropTypes.string.isRequired,   // 限制name必传，且为字符串
            sex:PropTypes.string,   // 限制sex为字符串
            age:PropTypes.number,   // 限制age为数值
            speak:PropTypes.func    // 限制speak为函数
        }

        // 指定默认标签属性值
        static defaultProps = {
            sex:"男", // sex默认值为男
            age:18  // age默认值为18
        }
        
        render(){
            const {name,age,sex} = this.props
            return (
                <ul>
                    <li>姓名：{name}</li>  
                    <li>性别：{age}</li>   
                    <li>年龄：{sex}</li>     
                </ul>
            )  
        }
    }
    
    const root1 = ReactDOM.createRoot(document.querySelector('#test1'));
    const root2 = ReactDOM.createRoot(document.querySelector('#test2'));
    const root3 = ReactDOM.createRoot(document.querySelector('#test3'));

    root1.render(<Person name="jerry" speak={speak}/>)
    root2.render(<Person name="tom" age={18} sex="女"/>)

    const p = {name:"zhangsan",age:"19",sex:"女"}
    // 直接使用对象中属性
    root3.render(<Person {...p}/>);

    function speak(){
        
    }
    ```

6. 类式组件中的构造器于props

    ```js
    constructor(props){
        // 构造器是否接收props，是否传递给super,取决于：是否希望在构造器中通过this访问props
        console.log(props);
        super(props)
        console.log('constructor',props);
    }
    ```
7. 函数式组件中的构造器于props

    ```js
    // 创建组件
    function Person(props){
        const {name,age,sex} = props

        return (
            <ul>
                <li>姓名：{name}</li>  
                <li>性别：{age}</li>   
                <li>年龄：{sex}</li>     
            </ul>
        )  
    }

    // 对标签属性进行类型，必要性的限制
    Person.propTypes = {
        name:PropTypes.string.isRequired,  
        sex:PropTypes.string,  
        age:PropTypes.number,  
    }

    // 指定默认标签属性值
    Person.defaultProps = {
        sex:"男",
        age:18 
    }
    
    const root1 = ReactDOM.createRoot(document.querySelector('#test1'));
    root1.render(<Person name="jerry" />)
    ```
8. 总结

    1. 理解
        - 每个组件对象都会有props(properties 的简写)属性
        - 组件标签的所有属性都保存在props中
    2. 作用
        - 标签属性从组件外向且件内传递变化的数据
        - 注意: 组件内部不要修改 props 数据

## 2.4 组件的三大属性：refs与事件处理

1. 

## 2.5 收集表单数据

## 2.6 组件生命周期

## 2.7 虚拟DOM与DOM Diff 算法

