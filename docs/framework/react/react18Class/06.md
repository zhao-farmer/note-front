# 六、redux

## 6.1 redux 理解

1. 学习文档
    1. 英文文档: `https://redux.js.org/`
    2. 中文文档: `http://www.redux.org.cn/`
    3. Github: `https://github.com/reactjs/redux`

2. redux 是什么
    - redux 是一个专门用于做状态管理的JS库(不是 react 插件库)。
    - 它可以用在 react, angular,vue等项目中,但基本与 react 配合使用
    - 作用: 集中式管理 react 应用中多个组件共享的状态。

3. 什么情况下需要使用 redux
    1. 某个组件的状态，需要让其他组件可以随时拿到(共享)。
    2. 一个组件需要改变另一个组件的状态(通信)。
    3. 总体原则:能不用就不用,如果不用比较吃力才考虑使用。

4. 原理图

    ![](/framework/react/react18Class/036.png)

5. Redux 三大核心概念详解

    1. Store（存储） - 单一数据源

        - ​​概念​​：整个应用的状态存储在一个 JavaScript 对象中，这个对象就是 Store。
        - 特点：
            - ​​单一性​​：整个应用只有一个 Store
            - ​​只读性​​：不能直接修改 Store 中的状态
            - ​​可预测性​​：状态变化通过纯函数处理
    2. Action（动作） - 状态变化的描述

        - ​​概念​​：Action 是一个普通 JavaScript 对象，用于描述发生了什么变化。

    3. Reducer（归约器） - 纯函数处理状态变化
        - ​​概念​​：Reducer 是一个纯函数，接收当前状态和 action，返回新的状态。
        - Reducer 特点：
            - ​纯函数​​：相同的输入总是得到相同的输出
            - ​无副作用​​：不修改传入的参数，不进行API调用
            - ​不可变更新​​：总是返回新的状态对象

    4. 运行流程图

        ![](/framework/react/react18Class/039.gif)

## 6.2 求和案例

### 6.2.1 纯 react 版

1. App.jsx

    ```jsx
    import React, { Component } from 'react'
    import Count from "./components/Count"

    export default class App extends Component {
        render() {
            return (
                <div>
                    <Count/>
                </div>
            )
        }
    }
    ```
2. count.jsx

    ```jsx
    import React, { Component } from "react";

    export default class Count extends Component {
        state = { count: 0 };
        // 加法
        increment = () => {
            const { value } = this.selectNumber;
            const { count } = this.state;
            this.setState({ count: count + value * 1 });
        };
        // 减法
        decrement = () => {
            const { value } = this.selectNumber;
            const { count } = this.state;
            this.setState({ count: count - value * 1 });
        };
        // 奇数再减
        incrementIfOdd = () => {
            const { value } = this.selectNumber;
            const { count } = this.state;
            if (count % 2 !== 0) {
                this.setState({ count: count + value * 1 });
            }
        };
        // 异步减
        incrementAsync = () => {
            const { value } = this.selectNumber;
            const { count } = this.state;
            setTimeout(() => {
                this.setState({ count: count + value * 1 });
            }, 500);
        };

        render() {
            return (
                <div>
                    <h1>当前求和为:{this.state.count}</h1>
                    <select ref={c => (this.selectNumber = c)}>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>{" "}
                    &nbsp;
                    <button onClick={this.increment}>+</button> &nbsp;
                    <button onClick={this.decrement}>-</button> &nbsp;
                    <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                    <button onClick={this.incrementAsync}>异步加</button>
                </div>
            );
        }
    }
    ```

### 6.2.2 redux精简版

1. 安装redux

    ```sh
    npm install redux
    ```
2. 代码编写

    - redux/store.js

        ```js
        // 引入legacy_createStore 创建redusx中最为核心的store对象
        // createStore 已过时
        import { legacy_createStore } from "redux"
        // 引入为Count组件服务的reducer
        import countReducer from "./count_reducer"

        // 创建store
        const store = legacy_createStore(countReducer)

        export default store
        ```
    - redux/count_reducer.js

        ```js
        export default function countReducer(preState, action) {
            // 查看初始化状态
            console.log(preState,action);
            
            // 初始化状态
            if (preState === undefined) {
                preState = 0
            }

            // 从action对象中获取
            const { type, data } = action;
            // 根据type决定如何加工数据
            switch (type) {
                case "increment":
                    return preState + data * 1;
                case "decrement":
                    return preState - data * 1;
                default:
                    // 初始化时调用这个
                    return preState;
            }
        }
        ```
    - Count组件

        ```jsx
        import React, { Component } from "react";
        import store from "../redux/store";

        export default class Count extends Component {

            // 检测redux中状态的变化，只要变化就调用render
            // componentDidMount(){
            //     // redux 任何一个状态的改变都会调用这个回调
            //     store.subscribe(()=>{
            //         this.setState({})
            //     })
            // }

            // 加法
            increment = () => {
                const { value } = this.selectNumber;
                // 通知redux加value
                store.dispatch({ type: 'increment', data: value })
            };
            // 减法
            decrement = () => {
                const { value } = this.selectNumber;
                store.dispatch({type:"decrement",data:value})
            };
            // 奇数再减
            incrementIfOdd = () => {
                // 从store中获取状态
                const count = store.getState()
                const { value } = this.selectNumber
                if (count % 2 !== 0) {
                    store.dispatch({ type: 'increment', data: value })
                }
            };
            // 异步减
            incrementAsync = () => {
                const { value } = this.selectNumber;
                setTimeout(() => {
                    store.dispatch({ type: 'increment', data: value })
                }, 500);
            };

            render() {
                return (
                    <div>
                        <h1>当前求和为:{store.getState()}</h1>
                        <select ref={c => (this.selectNumber = c)}>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>{" "}
                        &nbsp;
                        <button onClick={this.increment}>+</button> &nbsp;
                        <button onClick={this.decrement}>-</button> &nbsp;
                        <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                        <button onClick={this.incrementAsync}>异步加</button>
                    </div>
                );
            }
        }

        ```
    - main.js 可以监控全局的redux变化

        ```js
        import ReactDOM from "react-dom/client"
        import App from "./App"
        import store from "./redux/store";


        const root = ReactDOM.createRoot(document.getElementById('root'));

        // 根组件中监控redux的变化，重新渲染页面
        // 组件多了会不会造成卡顿，react中有 diff 算法，只修改发生改变的
        store.subscribe(()=>{
            root.render(<App/>)
        })
        ```
3. 使用步骤

    1. 出去Count组件自身的状态
    2. src下建立：

        ```md
        redux
        ├── store.js
        └── count_reducer.js
        ```
    3. store.js:
        - 引入redux的`legacy_createStore`函数，创建一个store
        - `legacy_createStore` 调用时要传入一个为其服务的reducer
        - 记得暴漏store对象

    4. count_renducer.js
        - reducer的本质是一个函数，接收：preState,action 返回加工后的状态
        - reducer有两个作用： 初始化状态，加工状态
        - reducer被第一次调用时，是store自动触发的，
            - 传递的preState是undefined
            - 传递的action是 {type:'@@REDUX/INIT_xxxxx'}
    5. 在index.js中监测store中状态的改变，一旦发生改变重新渲染 `<App/>`

        备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己家写。

### 6.2.3 redux 完整版

1. 新增文件

    - src/redux/count_reducer.js

        ```js
        /* 
            1. 该文件是用于创建一个为Count组件服务的reducer,reducer本质就是一个函数

            2. reducer函数会接到两个函数，分别为之前的状态(previousState),动作对象(action)
        */

        import { INCREMENT,DECREMENT } from "./constant";

        const initState = 0
        export default function countReducer(preState = initState, action) {

            // 从action对象中获取
            const { type, data } = action;
            // 根据type决定如何加工数据
            switch (type) {
                case INCREMENT:
                    return preState + data * 1;
                case DECREMENT:
                    return preState - data * 1;
                default:
                    // 初始化时调用这个
                    return preState;
            }
        }
        ```
    - src/redux/constant.js

        ```js
        /* 
            该模块是用于定义action对象中type类型的常量值
            目的已有一个：防止程序员单词写错
        */
        export const INCREMENT = 'increment'
        export const DECREMENT = 'decrement'
        ```

2. 修改文件

    - src/redux/count_reducer.js

        ```js{7,16,18}
        /* 
            1. 该文件是用于创建一个为Count组件服务的reducer,reducer本质就是一个函数

            2. reducer函数会接到两个函数，分别为之前的状态(previousState),动作对象(action)
        */

        import { INCREMENT,DECREMENT } from "./constant";

        const initState = 0
        export default function countReducer(preState = initState, action) {

            // 从action对象中获取
            const { type, data } = action;
            // 根据type决定如何加工数据
            switch (type) {
                case INCREMENT:
                    return preState + data * 1;
                case DECREMENT:
                    return preState - data * 1;
                default:
                    // 初始化时调用这个
                    return preState;
            }
        }
        ```
    - count组件

        ```jsx{4-5,18,26,33}
        import React, { Component } from "react";
        // 引入store，用于获取redux中保存状态
        import store from "../redux/store";
        // 引入actionCreator 专门用于创建action对象
        import {createIncrementAction,createDecrementAction} from "../redux/count_action"

        export default class Count extends Component {

            // 加法
            increment = () => {
                const { value } = this.selectNumber;
                // 通知redux加value
                store.dispatch(createIncrementAction(value))
            };
            // 减法
            decrement = () => {
                const { value } = this.selectNumber;
                store.dispatch(createDecrementAction(value))
            };
            // 奇数再减
            incrementIfOdd = () => {
                // 从store中获取状态
                const count = store.getState()
                const { value } = this.selectNumber
                if (count % 2 !== 0) {
                    store.dispatch(createIncrementAction(value))
                }
            };
            // 异步减
            incrementAsync = () => {
                const { value } = this.selectNumber;
                setTimeout(() => {
                    store.dispatch(createIncrementAction(value))
                }, 500);
            };

            render() {
                return (
                    <div>
                        <h1>当前求和为:{store.getState()}</h1>
                        <select ref={c => (this.selectNumber = c)}>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>{" "}
                        &nbsp;
                        <button onClick={this.increment}>+</button> &nbsp;
                        <button onClick={this.decrement}>-</button> &nbsp;
                        <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                        <button onClick={this.incrementAsync}>异步加</button>
                    </div>
                );
            }
        }
        ```

3. 新增文件
    1. count _action.js 专门用于创建action对象
    2. constant.js 放置由于编码疏忽写错action中的type
### 6.2.4 异步action版

1. 安装插件

    ```sh
    npm install redux-thunk
    ```
2. 修改代码
    - 将 redux-chunk 添加到中间件

        ```js{3-4,6}
        import { applyMiddleware, legacy_createStore } from "redux"
        import countReducer from "./count_reducer"
        // 引入redux-thunk,用于支持异步action
        import {thunk} from 'redux-thunk'

        // 创建store
        const store = legacy_createStore(countReducer,applyMiddleware(thunk))

        export default store
        ```
    - sr/redux/count_action.js 添加异步方法

        ```js
        // 异步action，就是指action的值为函数,
        // 异步action中一般都会调用同步action,异步action不是必须要用的
        export const createIncrementAsyncAction = (data,time) => {
            return async (dispatch)=>{
                setTimeout(() => {
                    dispatch(createIncrementAction(data))
                }, time);
            }
        }
        ```
    - count 组件修改调用

        ```jsx
        import { createIncrementAsyncAction } from "../redux/count_action"

         // 异步加
        incrementAsync = () => {
            const { value } = this.selectNumber;
            store.dispatch(createIncrementAsyncAction(value, 1000))
        };
        ```

3. 总结

    1. 明确:延迟的动作不想交给组件自身，想交给action
    2. 何时需要异步action:想要对状态进行操作，但是具体的数据靠异步任务返回。
    3. 具体编码:
        - `npm install redux-thunk`,并配置在store中
        - 创建action的所数不再返回一般对象，而是一个所数，该函数中写异步任务。
        - 异步任务有结果后，分发一个同步的action去真正操作数据。
    4. 备注:异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。


## 6.3 react-redux

### 6.3.1 react-redux的基本使用

1. 安装插件

    ```sh
    npm install react-redux
    ```
2. 使用react-redux的基本流程

    ![](/framework/react/react18Class/038.png)

3. 新增 count 容器 src/containers/Count.jsx

    ```jsx
    // 引入Count的UI组件
    import CountUI from "../components/Count"
    // 引入connect用于连接UI组件与redux
    import { connect } from "react-redux"
    // 导入actcions中的方法
    import { 
        createIncrementAction, 
        createIncrementAsyncAction, 
        createDecrementAction 
    } from '../redux/count_action'


    /**
    * mapStateToProps()
    * 1. 用于传递状态
    * 2. 返回一个对象
    * 3. react-redux在调用该函数时已经传入了state
    * 4. 此处的值传入UI组件中，UI组件可使用this.props.xxx拿到对应的值
    */
    const mapStateToProps = (state) => {
        return {
            count: state
        }
    }

    /**
    * mapDispatchToProps()
    * 1. 用于传递操作状态的方法
    * 2. 返回一个对象，对象的value是一个方法
    */
    const mapDispatchToProps = (dispatch) => {
        return {
            add: (num) => {
                dispatch(createIncrementAction(num))
            },
            addAsync: (num, delay) => {
                dispatch(createIncrementAsyncAction(num, delay))
            },
            reduce: (num) => {
                dispatch(createDecrementAction(num))
            }
        }
    }

    // 使用connect() 创建一个Count的容器组件
    const CountContainer = connect(mapStateToProps,mapDispatchToProps)(CountUI)

    // 暴漏容器
    export default CountContainer
    ```

4. 修改代码

    - App.jsx 传递store

        ```jsx
        import React, { Component } from 'react'
        import Count from "./containers/Count"
        // 引入store
        import store from "./redux/store"

        export default class App extends Component {
            render() {
                return (
                    <div>
                        {/* 给容器传递store */}
                        <Count store={store}/>
                    </div>
                )
            }
        }
        ```
    - src/components/Count.jsx 使用props获取数据

        ```jsx
        import React, { Component } from "react";

        export default class Count extends Component {

            // 加法
            increment = () => {
                const { value } = this.selectNumber;
                // 通知redux加value
                this.props.add(value)
            };
            // 减法
            decrement = () => {
                const { value } = this.selectNumber;
                this.props.reduce(value)
            };
            // 奇数再减
            incrementIfOdd = () => {
                const count = this.props.count
                const { value } = this.selectNumber
                if (count % 2 !== 0) {
                    this.props.add(value)
                }
            };
            // 异步减
            incrementAsync = () => {
                const { value } = this.selectNumber;
                this.props.addAsync(value, 1000)
            };

            render() {
                return (
                    <div>
                        <h1>当前求和为:{this.props.count}</h1>
                        <select ref={c => (this.selectNumber = c)}>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                        </select>{" "}
                        &nbsp;
                        <button onClick={this.increment}>+</button> &nbsp;
                        <button onClick={this.decrement}>-</button> &nbsp;
                        <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                        <button onClick={this.incrementAsync}>异步加</button>
                    </div>
                );
            }
        }
        ```
5. 总结:

    1. 明确两个概念:
        - UI组件:不能使用任何redux的api，只负责页面的呈现、交互等。
        - 容器组件:负责种redux通信，将结果交给UI组件。
    2. 如何创建一个容器组件--靠peact-redux的 connect函数
        - connect(mapstateToProps,mapDispatchToProps)(UI组件)
            - mapstateToProps:映射状态，返回值是一个对象
            - mapDispatchToProps:映射操作状态的方法，返回值是一个对象
    3. 备注:容器组件中的store是华props传进去的，而不是在容器组件中直接引入

### 6.3.2 优化react-redux

1. 优化mapDispatchToProps 修改 Count 容器

    ```jsx
    // 引入Count的UI组件
    import CountUI from "../components/Count"
    // 引入connect用于连接UI组件与redux
    import { connect } from "react-redux"
    // 导入actcions中的方法
    import { 
        createIncrementAction, 
        createIncrementAsyncAction, 
        createDecrementAction 
    } from '../redux/count_action'


    // 使用connect() 创建一个Count的容器组件
    const CountContainer = connect(
        state => ({count:state}),

        // mapDispatchToProps的一般写法
        // dispatch => ({
        //     add:number=>dispatch(createIncrementAction(number)),
        //     reduce:number=>dispatch(createDecrementAction(number)),
        //     addAsync:(number,time)=>dispatch(createIncrementAsyncAction(number,time)),
        // })

        // mapDispatchToProps的简写
        {
            add:createIncrementAction,
            reduce:createDecrementAction,
            addAsync:createIncrementAsyncAction,
        }

    )(CountUI)

    // 暴漏容器
    export default CountContainer
    ```

2. 优化Provider组件 修改监控redux状态变化部分

    ```jsx
    import ReactDOM from "react-dom/client"
    import App from "./App"
    import store from "./redux/store";
    import { Provider } from "react-redux";

    const root = ReactDOM.createRoot(document.getElementById('root'));

    root.render(
        <Provider store={store}>
            <App />
        </Provider>
    )
    ```

3. 容器与UI组件放入一个文件中

    ```jsx
    import React, { Component } from "react";
    // 引入connect用于连接UI组件与redux
    import { connect } from "react-redux"
    // 导入actcions中的方法
    import { 
        createIncrementAction, 
        createIncrementAsyncAction, 
        createDecrementAction 
    } from '../redux/count_action'


    class Count extends Component {

        // 加法
        increment = () => {
            const { value } = this.selectNumber;
            // 通知redux加value
            this.props.add(value)
        };
        // 减法
        decrement = () => {
            const { value } = this.selectNumber;
            this.props.reduce(value)
        };
        // 奇数再减
        incrementIfOdd = () => {
            const count = this.props.count
            const { value } = this.selectNumber
            if (count % 2 !== 0) {
                this.props.add(value)
            }
        };
        // 异步减
        incrementAsync = () => {
            const { value } = this.selectNumber;
            this.props.addAsync(value, 1000)
        };

        render() {
            return (
                <div>
                    <h1>当前求和为:{this.props.count}</h1>
                    <select ref={c => (this.selectNumber = c)}>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>{" "}
                    &nbsp;
                    <button onClick={this.increment}>+</button> &nbsp;
                    <button onClick={this.decrement}>-</button> &nbsp;
                    <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                    <button onClick={this.incrementAsync}>异步加</button>
                </div>
            );
        }
    }


    // 使用connect() 创建一个Count的容器组件
    const CountContainer = connect(
        state => ({count:state}),
        {
            add:createIncrementAction,
            reduce:createDecrementAction,
            addAsync:createIncrementAsyncAction,
        }

    )(Count)

    // 暴漏容器
    export default CountContainer
    ```

4. 总结

    1. 容器组件和UI组件整合一个文件
    2. 无需自已给容器组件传递store，给`<App/>`包褰一个`<Provider store={store}>`即可。
    3. 使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。
    4. mapDispatchToProps也可以简单的写成一个对象
    5. 一个组件要和redux“打交道”要经过哪儿步?
        1. 定义好UI组件---不暴踪
        2. 引入connect生成一个容器组件，并暴路，写法如下:

            ```js:no-line-numbers
            connect(
                state =>({key:value})，//射状态
                {key:xxxxxAction} //映射操作状态的方法
            )(UI组件)
            ```
        3. 在UI组件中通过this.props.xxxxxxx读取和操作状态

## 6.4 添加Person组件


1. 调整目录结构

    ```md
    src/
    ├── containers/
    │   └── Count.jsx
    ├── redux/ 
    │   ├── actions/
    │   │   └── count.js
    │   ├── reducres/
    │   │   └── count.js
    │   ├── constant.js
    │   └── store.js
    ├── App.jsx 
    └── index.js
    ```

2. 安装nanoid插件

    ```sh
    npm install nanoid
    ```

3. 创建文件

    -  src/containers/Person.jsx

        ```jsx
        import React, { Component } from "react";
        import { connect } from "react-redux";
        import { nanoid } from "nanoid";
        import { addPersonAction } from "../redux/actions/person";

        // 定义UI组件
        class Person extends Component {
            addPerson = () => {
                const name = this.nameNode.value;
                const age = this.ageNode.value * 1;
                const personObj = {
                    id: nanoid(),
                    name: name,
                    age: age,
                };
                this.props.addPersonProps(personObj);

                this.nameNode.value = "";
                this.ageNode.value = "";
            };

            render() {
                return (
                    <div>
                        <h2>Person组件</h2>
                        <input type="text" ref={c => (this.nameNode = c)} placeholder="请输入名称" />
                        <input type="text" ref={c => (this.ageNode = c)} placeholder="请输入年龄" />
                        <button onClick={this.addPerson}>添加</button>
                        <ul>
                            {this.props.persons.map(item => {
                                return (
                                    <li key={item.id}>
                                        {item.name} --- {item.age}
                                    </li>
                                );
                            })}
                        </ul>
                    </div>
                );
            }
        }

        // 定义容器组件
        export default connect(
            state => ({
                persons: state.personsR,
            }),
            {
                addPersonProps: addPersonAction,
            }
        )(Person);
        ```
    
    -  src/redux/actions/person.js

        ```js
        import { ADD_PERSON } from '../constant'

        export const addPersonAction = (data) => {
            return { type: ADD_PERSON, data }
        }
        ```
    -  src/redux/reducres/person.js

        ```js
        import { ADD_PERSON } from "../constant";

        // 初始化人的列表
        const initState =  [
            { id: "001",name: "Tom", age: 23,},
            { id: "002",name: "Jerry", age:18,},
        ];
        export default function personReducer(preState=initState, action) {

            const { type, data } = action;

            switch (type) {
                case ADD_PERSON:
                    // 没有对preState进行push或unshift操作，因为redux默认若返回值和之前状态一致，则不更新页面
                    return [data, ...preState];
                default:
                    return preState;
            }
        }
        ```

3. 修改代码
    -  src/redux/constant.js

        ```js{3}
        export const INCREMENT = 'increment'
        export const DECREMENT = 'decrement'
        export const ADD_PERSON = 'addPerson'
        ```
    -  src/redux/store.js

        ```js{6-7,11-15}
        // 引入legacy_createStore 创建redusx中最为核心的store对象
        import { applyMiddleware, legacy_createStore,combineReducers } from "redux"
        // 引入为Count组件服务的reducer
        import countReducer from "./reducres/count"
        // 引入为Person组件服务的reducer
        import personReducer from "./reducres/person"
        // 引入redux-thunk,用于支持异步action
        import {thunk} from 'redux-thunk'

        // 汇总所有的reducer变为一个总的reducer
        const allReducer = combineReducers({
            countR:countReducer,
            personsR:personReducer
        })

        // 创建store
        const store = legacy_createStore(allReducer,applyMiddleware(thunk))

        export default store
        ```

    - App.jsx

        ```jsx{3,10-11}
        import React, { Component } from 'react'
        import Count from "./containers/Count"
        import Person from "./containers/Person"

        export default class App extends Component {
            render() {
                return (
                    <div>
                        <Count/>
                        <hr />
                        <Person/>
                    </div>
                )
            }
        }
        ```

4. 使用Count容器调用为Person组件提供服务的redux的reducer

    ```jsx{42-43,63-66}
    import React, { Component } from "react";
    // 引入connect用于连接UI组件与redux
    import { connect } from "react-redux"
    // 导入actcions中的方法
    import { 
        createIncrementAction, 
        createIncrementAsyncAction, 
        createDecrementAction 
    } from '../redux/actions/count'


    class Count extends Component {

        // 加法
        increment = () => {
            const { value } = this.selectNumber;
            // 通知redux加value
            this.props.add(value)
        };
        // 减法
        decrement = () => {
            const { value } = this.selectNumber;
            this.props.reduce(value)
        };
        // 奇数再减
        incrementIfOdd = () => {
            const count = this.props.count
            const { value } = this.selectNumber
            if (count % 2 !== 0) {
                this.props.add(value)
            }
        };
        // 异步减
        incrementAsync = () => {
            const { value } = this.selectNumber;
            this.props.addAsync(value, 1000)
        };

        render() {
            return (
                <div>
                    <h1>Count组件</h1>
                    <h2>当前求和为:{this.props.count}；下方组件总人数为{this.props.personNum}</h2>nbsp;
                    <select ref={c => (this.selectNumber = c)}>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>{" "}
                    &nbsp;
                    <button onClick={this.increment}>+</button> &nbsp;
                    <button onClick={this.decrement}>-</button> &nbsp;
                    <button onClick={this.incrementIfOdd}>当前求和为奇数再加</button> &nbsp;
                    <button onClick={this.incrementAsync}>异步加</button>
                </div>
            );
        }
    }


    // 使用connect() 创建一个Count的容器组件
    const CountContainer = connect(
        // 此处直接到persons的数据
        state => ({
            count: state.countR,
            personNum: state.personsR.length
        }),
        {
            add:createIncrementAction,
            reduce:createDecrementAction,
            addAsync:createIncrementAsyncAction,
        }

    )(Count)

    // 暴漏容器
    export default CountContainer
    ```

5. 总结

    1. 定义一个Pserson组件，和Count组件通过redux共享数。
    2. 为Person组作编写:reducer、action，配置constant常量。
    3. 重点:Person的reducer利Count的Reducer双使用combineReducers进行合并,合并后的总状态是一个对象!!!
    4. 交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”
