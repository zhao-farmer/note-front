# 七、Hooks


| Hook | 参数  | 返回值 | 主要用途 |
| --- | --- | --- | --- |
| `useState` | `initialValue` | `[state, setState]` | 状态管理 |
| `useEffect` | `effect, deps` | `undefined` | 副作用处理 |
| `useContext` | `context` | `contextValue` | 访问上下文 |
| `useReducer` | `reducer, initialState` | `[state, dispatch]` | 复杂状态管理 |
| `useMemo` | `create, deps` | `memoizedValue` | 缓存计算结果 |
| `useCallback` | `callback, deps` | `memoizedCallback` | 缓存函数引用 |
| `useRef` | `initialValue` | `{ current: value }` | DOM引用/值存储 |


## 7.1 useState - 状态管理

1. 介绍

    用于在函数组件中添加和管理状态（state）。

    - 参数
        - initialValue: 状态的初始值
        - 可以是任何类型：数字、字符串、对象、数组等
        - 也可以是函数（惰性初始化）：() => initialValue

    - 返回值
        - 数组 [state, setState]
            - state: 当前的状态值
            - setState: 更新状态的函数

    - 示例

        ```jsx
        const [count, setCount] = useState(0); // 数字
        const [name, setName] = useState(''); // 字符串
        const [user, setUser] = useState({ id: 1, name: '张三' }); // 对象
        const [items, setItems] = useState([]); // 数组

        // 惰性初始化（函数只在初始渲染时执行一次）
        const [data, setData] = useState(() => {
            const saved = localStorage.getItem('data');
            return saved ? JSON.parse(saved) : [];
        });
        ```

2. 代码示例

    ```jsx
    // 创建组件
    function Counter() {

        // 使用useState
        const [count, setCount] = React.useState(0);
        const [user, setUser] =  React.useState({ name: '张三', age: 25 });

        const updateName = () => {
            setUser(prev => ({ ...prev, name: '李四' }));
        };

        return (
            <div>
                <h2>计数器: {count}</h2>
                <button onClick={() => setCount(count + 1)}>+1</button>
                <button onClick={() => setCount(count - 1)}>-1</button>
                
                <h3>用户信息</h3>
                <p>姓名: {user.name}</p>
                <p>年龄: {user.age}</p>
                <button onClick={updateName}>更改姓名</button>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Counter/>)
    ```

3. 运行结果

    ![](/framework/react/react18Class/011.gif)

## 7.2 useEffect - 副作用处理

1. 介绍

    用于处理副作用操作：数据获取、DOM操作、订阅设置等。
    
    - 参数

        *   **`effect`**: 包含副作用逻辑的函数
            
        *   **`dependencies`** (可选): 依赖项数组
    
    - 三种使用方式

        ```jsx
        // 1. 每次渲染后都执行
        useEffect(() => {
            console.log('每次渲染后执行');
        });

        // 2. 只在挂载时执行一次（类似 componentDidMount）
        useEffect(() => {
            console.log('只在组件挂载时执行一次');
        }, []); // 空依赖数组

        // 3. 在依赖项变化时执行（类似 componentDidUpdate）
        useEffect(() => {
            console.log('count 变化时执行');
        }, [count]); // 依赖 count

        // 清理函数（类似 componentWillUnmount）
        useEffect(() => {
            const timer = setInterval(() => {}, 1000);
            
            return () => {
                clearInterval(timer); // 清理操作
            };
        }, []);
        ```

2. 代码示例

    ```js
    function Timer() {
        const [time, setTime] = React.useState(0);
        const [isRunning, setIsRunning] = React.useState(false);

        React.useEffect(() => {
            let intervalId;
            
            if (isRunning) {
                intervalId = setInterval(() => {
                    setTime(prev => prev + 1);
                }, 1000);
            }

            // 清理函数
            return () => {
                if (intervalId) clearInterval(intervalId);
            };
        }, [isRunning]); // 依赖 isRunning

        return (
            <div>
                <h2>计时器: {time} 秒</h2>
                <button onClick={() => setIsRunning(true)}>开始</button>
                <button onClick={() => setIsRunning(false)}>暂停</button>
                <button onClick={() => {
                    setIsRunning(false);
                    setTime(0);
                }}>重置</button>
            </div>
        );
    }


    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Timer/>)
    ```

3. 运行结果

    ![](/framework/react/react18Class/012.gif)

## 7.3 useContext - 上下文访问

1. 介绍

    用于访问 React 的 Context 值。

    - 参数

        *   **`context`**: 通过 `React.createContext()` 创建的 context 对象
    
    - 返回值

        *   Context 的当前值
    
    - 示例

        ```jsx
        const ThemeContext = createContext('light');

        function ThemedButton() {
            const theme = useContext(ThemeContext); // 获取 Context 值
            return <button className={theme}>按钮</button>;
        }
        ```
2. 代码示例

    ```js
    // 创建 Context
    const UserContext = React.createContext();

    function App() {
        const [user, setUser] = React.useState({ name: '张三', role: '用户' });

        return (
            <UserContext.Provider value={{ user, setUser }}>
            <div>
                <Header />
                <MainContent />
            </div>
            </UserContext.Provider>
        );
    }

    function Header() {
        const { user } = React.useContext(UserContext);
        
        return <header>欢迎, {user.name}</header>;
    }

    function MainContent() {
        const { user, setUser } = React.useContext(UserContext);
        
        const upgrade = () => {
            setUser(prev => ({ ...prev, role: 'VIP' }));
        };

        return (
            <main>
            <p>角色: {user.role}</p>
            <button onClick={upgrade}>升级为VIP</button>
            </main>
        );
    }


    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<App/>)
    ```

3. 运行结果

    ![](/framework/react/react18Class/013.gif)

## 7.4 useReducer - 复杂状态管理

1. 介绍

    用于管理复杂的状态逻辑（类似 Redux）。

    - 参数
        *   **`reducer`**: 处理状态更新的函数 `(state, action) => newState`
        *   **`initialState`**: 初始状态
        *   **`init`** (可选): 惰性初始化函数
    - 返回值
        *   数组 `[state, dispatch]`
            *   **`state`**: 当前状态  
            *   **`dispatch`**: 发送 action 的函数
    - 示例

        ```jsx
        function reducer(state, action) {
            switch (action.type) {
                case 'INCREMENT':
                    return { count: state.count + 1 };
                case 'DECREMENT':
                    return { count: state.count - 1 };
                default:
                    return state;
            }
        }

        function Counter() {
            const [state, dispatch] = useReducer(reducer, { count: 0 });
            
            return (
                <div>
                    Count: {state.count}
                    <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
                    <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
                </div>
            );
        }
        ```
2. 代码示例

    ```js
    // 初始状态
    const initialState = { count: 0 };

    // Reducer 函数
    function counterReducer(state, action) {
        switch (action.type) {
            case 'INCREMENT':
                return { count: state.count + 1 };
            case 'DECREMENT':
                return { count: state.count - 1 };
            case 'RESET':
                return { count: 0 };
            case 'SET':
                return { count: action.payload };
            default:
                return state;
        }
    }

    function Counter() {
        const [state, dispatch] = React.useReducer(counterReducer, initialState);

        return (
            <div>
                <h2>计数: {state.count}</h2>
                <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>
                <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>
                <button onClick={() => dispatch({ type: 'RESET' })}>重置</button>
                <button onClick={() => dispatch({ type: 'SET', payload: 10 })}>
                    设置为10
                </button>
            </div>
        );
    }


    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Counter/>)
    ```
3. 运行结果

    ![](/framework/react/react18Class/014.gif)
    
## 7.5 useMemo - 缓存计算结果

1. 介绍

    用于缓存昂贵的计算结果，避免每次渲染都重新计算。

    - 参数
        *   **`create`**: 返回计算值的函数
        *   **`dependencies`**: 依赖项数组
    - 返回值
        *   缓存的计算结果
    - 示例

        ```js
        const expensiveValue = useMemo(() => {
            console.log('重新计算...');
            let result = 0;
            for (let i = 0; i < 1000000000; i++) {
                result += i;
            }
            return result + count; // 依赖 count
        }, [count]); // 只有当 count 变化时才重新计算
        ```
2. 代码示例

    ```js
    function Calculator() {
        const [number, setNumber] = React.useState(1);
        const [multiplier, setMultiplier] = React.useState(2);

        // 使用 useMemo 缓存计算结果
        const result = React.useMemo(() => {
            console.log('重新计算...');
            return number * multiplier;
        }, [number, multiplier]); // 只有当 number 或 multiplier 变化时才重新计算

        return (
            <div>
            <h2>计算结果: {result}</h2>
            <div>
                <label>数字: </label>
                <input
                    type="number"
                    value={number}
                    onChange={(e) => setNumber(Number(e.target.value))}
                />
            </div>
            <div>
                <label>乘数: </label>
                <input
                    type="number"
                    value={multiplier}
                    onChange={(e) => setMultiplier(Number(e.target.value))}
                />
            </div>
            </div>
        );
    }


    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Calculator/>)
    ```
3. 运行结果

    ![](/framework/react/react18Class/015.gif)


## 7.6 useCallback - 缓存函数

1. 介绍

    用于缓存函数引用，避免子组件不必要的重新渲染。

    - 参数
        *   **`callback`**: 需要缓存的函数
        *   **`dependencies`**: 依赖项数组
    - 返回值

        *   缓存的函数引用

    - 示例

        ```jsx
        const handleClick = useCallback(() => {
            console.log('按钮被点击', count);
            setCount(count + 1);
        }, [count]); // 依赖 count，count 变化时返回新函数

        // 相当于
        const handleClick = useMemo(() => () => {
            console.log('按钮被点击', count);
            setCount(count + 1);
        }, [count]);
        ```
2. 代码示例

    ```js
    const ChildButton = React.memo(({ onClick, label }) => {
        console.log('子组件渲染');
        return <button onClick={onClick}>{label}</button>;
    });

    function Parent() {
        const [count, setCount] = React.useState(0);
        const [random, setRandom] = React.useState(0);

        // 使用 useCallback 缓存函数
        const increment = React.useCallback(() => {
            setCount(prev => prev + 1);
        }, []);

        const decrement = React.useCallback(() => {
            setCount(prev => prev - 1);
        }, []);

        return (
            <div>
                <h2>计数: {count}</h2>
                <ChildButton onClick={increment} label="增加" />
                <ChildButton onClick={decrement} label="减少" />
                
                <button onClick={() => setRandom(Math.random())}>
                    生成随机数: {random}
                </button>
            </div>
        );
    }
        

    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<Parent/>)
    ```
3. 运行结果

    ![](/framework/react/react18Class/016.gif)

## 7.7 useRef - DOM引用和值存储

1. 介绍
    
    用于访问DOM元素或在渲染之间存储可变值。

    - 参数

        *   **`initialValue`**: ref 对象的初始值
    - 返回值

        *   ref 对象 `{ current: initialValue }`
    
    - 两种主要用途

        ```jsx
        // 1. 访问DOM元素
        function TextInput() {
            const inputRef = useRef(null);
            
            const focusInput = () => {
                inputRef.current.focus(); // 访问DOM元素
            };
            
            return (
                <div>
                    <input ref={inputRef} />
                    <button onClick={focusInput}>聚焦</button>
                </div>
            );
        }

        // 2. 存储可变值（不会触发重新渲染）
        function Timer() {
            const countRef = useRef(0); // 存储数字
            const timerRef = useRef(null); // 存储定时器ID
            
            const startTimer = () => {
                timerRef.current = setInterval(() => {
                countRef.current += 1; // 修改不会触发重新渲染
                console.log(countRef.current);
                }, 1000);
            };
            
            const stopTimer = () => {
                clearInterval(timerRef.current);
            };
            
            return (
                <div>
                    <button onClick={startTimer}>开始</button>
                    <button onClick={stopTimer}>停止</button>
                </div>
            );
        }
        ```

2. 代码示例

    ```js
    function FocusAndValue() {
        const inputRef = React.useRef(null);
        const renderCount = React.useRef(0);
        const [text, setText] = React.useState('');

        React.useEffect(() => {
            renderCount.current += 1;
        });

        const focusInput = () => {
            inputRef.current.focus();
        };

        const showRenderCount = () => {
            alert(`组件已经渲染了 ${renderCount.current} 次`);
        };

        return (
            <div>
            <input
                ref={inputRef}
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="输入内容..."
            />
            <button onClick={focusInput}>聚焦输入框</button>
            <button onClick={showRenderCount}>显示渲染次数</button>
            <p>当前输入: {text}</p>
            </div>
        );
    }
        

    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<FocusAndValue/>)
    ```

3. 运行结果

    ![](/framework/react/react18Class/017.gif)

## 7.8 自定义 Hook

1. 介绍

    将组件逻辑提取到可重用的函数中。

    1. 什么是自定义 Hook？
        - 自定义 Hook 是一个 JavaScript 函数，其名称以 "use" 开头，可以调用其他 Hook。
        - 它让你能够将组件逻辑提取到可重用的函数中，实现逻辑复用而不需要改变组件结构。

    2. 注意项

        - 命名约定 - 自定义 Hook 必须以 "use" 开头
        - 调用位置 - 只能在函数组件的顶层调用 Hook
        - 依赖数组 - 正确声明 useEffect 和 useCallback 的依赖
  

2. 代码示例

    ```jsx
    // 自定义的hooks
    function useToggle(initialValue = false) {
        const [value, setValue] = React.useState(initialValue);

        const toggle = React.useCallback(() => {
            setValue(prev => !prev);
        }, []);

        const setTrue = React.useCallback(() => {
            setValue(true);
        }, []);

        const setFalse = React.useCallback(() => {
            setValue(false);
        }, []);

        return [value, toggle, setTrue, setFalse];
    }

    // 使用示例
    function ToggleComponent() {
        const [isOn, toggle, turnOn, turnOff] = useToggle(false);

        return (
            <div>
                <p>状态: {isOn ? '开启' : '关闭'}</p>
                <button onClick={toggle}>切换</button>
                <button onClick={turnOn}>开启</button>
                <button onClick={turnOff}>关闭</button>
            </div>
        );
    }
        

    const root = ReactDOM.createRoot(document.querySelector('#test'));
    root.render(<ToggleComponent/>)
    ```

3. 运行结果

    ![](/framework/react/react18Class/018.gif)
    
