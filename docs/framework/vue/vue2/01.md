# 一、Vue核心

## 1.1 初始vue

### 1.1.1 vue官网

- vue官网

https://cn.vuejs.org/

- vue2文档

https://v2.cn.vuejs.org/


### 1.1.2 下载vue.js

- 直接引入

```js
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
```

- 下载

打开这个网址

https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js

直接保存


### 1.1.3 html简单使用vue

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>初识vue</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h1>hello. {{name}}</h1>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
    
        //创建Vue实例
        new Vue({
            el:'#root' ,//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串
            data:{  //data 中用于存储数据，数据供el所指定的容器去使用，值我们暂时写成一个对象
                name:'世界'
            }
        })
    </script>
  
</body>
</html>
```


### 1.1.4 vue工作流程

1. 想让Vue工作，必须创建一个Vue实例，且要传入一个配置对象
2. root容器里的代码依然符合html规范，只不过混入了一些特殊的vue语法
3. root容器里的代码被称为【Vue模板】
4. Vue实例和容器是一一对应的
5. 真实开发中只有一个Vue实例，并且会配合着组件一起使用：
6. `{{xxx}}`中的xxx要写js表达式，且xxx金额图足底不过对于企业带data这个i不过的所有属性
7. 一旦data中的数据发生改变，那么模板中用到该数据的地方也会自动更新


注意区分：js表达式 和 js代码（语句）

1. 表达式：一个表达式会生成一个值，可以放在任何一个需要值的地方：
<br>     (1).  a
<br>     (2).  a+b
<br>     (3). demo(1)
<br>     (4). X == y ? 'a' : 'b'
    
2. js代码（语句）
<br>     (1). If(){}
<br>     (2). For(){}



## 1.2 模板语法

### 1.2.1 代码 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>模板语法</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h1>模板语法</h1>
        <h3>hello. {{name}}</h3>
        <hr/>
        <h1>语法指令</h1>
        <a v-bind:href="school.url"> 点我去{{school.name}}学习1！</a>
        <a :href="school.url.toUpperCase()"> 点我去{{school.name}}学习2！</a>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        new Vue({
            el:'#root',
            data:{
                name:'jack',
                school:{
                    name:'B站',
                    url:'https://www.bilibili.com/video/BV1Zy4y1K7SH'
                }
            }
          
        })
    </script>
  
</body>
</html>
```

### 1.2.2 总结

Vue模板语法由两大类

1. 插值语法：
    - 功能：用于解析标签体内容。
    - 写法：`{{xxx}}`,xxx是js表达式，且可以直接读取到data中的所有属性。

2. 指令语法：
    - 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件……）.
    - 举例：v-bing:href="xxx" 或 简写为 :href="xxx",xxx同样要写js表达式，且可以直接读取到data中的所有属性。
    - 备注：Vue中由很多的指令，且形式都是：v-????,此处只是拿v-bing举个例子


## 1.3 数据绑定

### 1.3.1 代码 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>模板语法</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 普通写法 -->
        单项数据绑定：<input type="text" v-bind:value="name"><br/>
        双向数据绑定：<input type="text" v-model:value="name"><br/>
        <!-- 简写 -->
        单项数据绑定：<input type="text" :value="name"><br/>
        双向数据绑定：<input type="text" v-model="name"><br/>

        <!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 -->
        <h2 v-model:x="name">你好啊</h2>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        new Vue({
            el:'#root',
            data:{
                name:'B站',
            }
        })
    </script>
</body>
</html>
```

### 1.3.2 总结
vue中由两种数据绑定的方式：

1. 单向绑定(v-bind): 数据只能从data流向页面.
2. 双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data.

备注：

1. 双向绑定一般都应用在表单类元素上（如：input、select等）
2. v-model:value 可以简写为v-model, 因为v-model默认收集的就是value值.


## 1.4 el与data的两种写法

### 1.4.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>el与data的两种写法</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      <h1>你好. {{name}}</h1>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        //el的两种写法
        //第一种写法
         new Vue({
             el:'#root', 
            data:{
                name:'B站',
            }
        })
        //第二种写法  更灵活 如使用定时任务去缓慢挂载
        const v1 = new Vue({
            data:{
                name:'B站',
            }
        })
        console.log(v1);
        v.$mount("#root")   

         //data的写法
        //data 第一种写法:对象式
         const v2 = new Vue({
            el:'#root', 
            data:{
                name:'B站',
            },
        })
        //data 的第二种写法 函数式
        const v3 = new Vue({
            el:'#root', 
            data:function(){
                console.log('@@',this); //此处的this式vue的实例函数
                return{
                    name:'B站'
                }
            },
            // 这种写法式错误的 不能使用箭头函数
            data:()=>{
                console.log('@@',this); //此处的this式window的实例函数
                return{
                    name:'B站'
                }
            },
            //最终的简写
            data(){
                return{
                    name:'B站'
                }
            },
        })
    </script>
</body>
</html>
```

### 1.4.2 总结

data与el的两种写法

1. el的2种写法
<br>    (1).new Vue时候配置el属性
<br>    (2).先创建Vue实例，随后通过vm.$('#root')指定el的值.

2. data有2种写法
<br>    (1).对象式
<br>    (2).函数式
<br>    如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错.

3. 一个重要的原则：

由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数。this就不再是Vue实例了


## 1.5 理解MVVM

### 1.5.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue种的MVVM</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      <h1>学校名称. {{name}}</h1>
      <h1>学校地址. {{address}}</h1>
      <h1>测试一下1. {{1+1}}</h1>
      <h1>测试一下2. {{$options}}</h1>
      <h1>测试一下3. {{$emit}}</h1>
      <h1>测试一下4. {{_c}}</h1>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
             el:'#root', 
            data:{
                name:'B站',
                address:'上海',
            }
        })
        console.log(vm);
    </script>
</body>
</html>
```

### 1.5.2 总结

- MVVM模型
    1. M：模型（Model）：data中的数据
    2. V：视图（View）: 模板代码
    3. VM： 视图模型（ViewModel）:Vue实例
- 观察发现：
    1. data种所有的属性，最后都出现在了vm身上。
    2. vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。


## 1.6 数据代理

### 1.6.1 回顾Object.defineProperty方法

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>1.回顾Object.defineProperty方法</title>
</head>
<body>
  
    <script type="text/javascript">
      let number = 18
      let person = {
        name:'张三',
        sex:'男',
        //age: 18
      }
      Object.defineProperty(person,'age',{
        // value:18,
        // enumerable:false,//控制属性是否可以枚举（遍历），默认值是false
        // writable:true,//控制属性是否可以被修改，默认值是false
        // configurable:true   //控制属性是否可以被删除，默认值是false
        //当有人读取person的age属性时，get函数（getter）就会被调用，且返回值就是age的值
        get(){
            console.log('有人读取age属性了');
            return number
        },
        //当有人修改person的age属性时，set函数（setter）就会被调用
        set(value){
            console.log('有人修改了age属性，且值是',value);
            number = value
        }
      })
    //   console.log(Object.keys(peson));
      
      console.log(person);
    </script>
</body>
</html>
```


### 1.6.2 简单的数据代理
 
 ```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>何为数据代理</title>
</head>
<body>
    <script type="text/javascript">
      let obj = {x:100}
      let obj2 = {y:200}
      Object.defineProperty(obj2,"x",{
        get(){
          return obj.x
        },
        set(value){
          obj.x = value
        }
      })
    </script>
</body>
</html>
```

### 1.6.3 vue中的数据代理

![](/framework/vue/vue2/001.png)

### 1.6.4 总结

1. Vue中的数据代理；
<br>    通过vm对象来代理data对象中属性的操作（读/写）

2. Vue中数据代理的好处：
<br>    更加方便的操作data中的数据

3. 基本原理：
    - 通过Object.defineProperty()把data中所有属性添加到vm上。
    - 为每一个添加到vm上的属性，都指定一个getter/setter
    - 在geetter/setter内部去操作（读/写）data中对应的属性


## 1.7 事件处理
### 1.7.1 事件的基本使用

#### 1.7.1.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>事件的基本使用</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>欢迎来到{{name}}学习</h2>
        <button v-on:click="showInfo">点我提示信息</button>
        <!-- 简写 -->
        <button @click="showInfo1">点我提示信息1</button>
        <button @click="showInfo2(66)">点我提示信息2</button>
        <button @click="showInfo3(66,$event)">点我提示信息3</button>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm =  new Vue({
             el:'#root', 
            data:{
                name:'B站',
                address:'上海',
            },
            methods: {
                showInfo(event){
                    // console.log(event.target.innerText);
                    console.log(this === vm);
                    // alert("同学你好！") //此处的this是vm
                },
                showInfo1(){
                    console.log('同学你好！');  
                },
                showInfo2(number){
                    // console.log('同学你好！！');
                    console.log(number);
                    
                },
                showInfo3(number,a){
                    // console.log('同学你好！！');
                    console.log(number,a);
                    
                },
            }
        })
        
    </script>
</body>
</html>
```

#### 1.7.1.2 总结

事件的基本使用：

1. 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；
2. 事件的回调需要配置在methods对象中，最终会在vm上；
3. methods中配置的函数，不要用箭头函数！否则this就不是vm了；
4. methods中配置的函数，都是被Vue所管理的函数。this的指向是vm或组件实例对象；
5. @click="demo" 和 @click="demo($event)" 效果一样，但后者可以传参；

### 1.7.2 事件修饰符


#### 1.7.2.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>事件修饰符</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
    <style>
        * {
            margin-top: 10px;
        }
        .demo1{
            height: 50px;
            background-color: skyblue;
        }
        .box1{
            padding: 10px;
            background-color: skyblue;
        }
        .box2{
            padding: 10px;
            background-color: orange;
        }
        .list{
            width: 200px;
            height: 200px;
            background-color: orange;
            overflow: auto;
        }
        li{
            height: 100px;
        }
    </style>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>欢迎来到{{name}}学习</h2>
        <!-- 阻止默认事件（常用） -->
        <a href="https://www.bilibili.com/" @click.prevent="showInfo">点击</a>
        <!-- 阻止事件冒泡（常用） -->
        <div class="demo1" @click="showInfo">
            <button  @click.stop="showInfo">点我提示信息</button>
        </div>
         <!-- 事件只处理一次 -->
        <button  @click.once="showInfo">点我提示信息2</button>
        <!-- 使用事件的捕获模式  先执行 加了capture修饰符的-->
        <div class="box1" @click.capture="showMsg(1)">
            div1
            <div class="box2" @click="showMsg(2)">
                div2
            </div>
        </div>
        <!-- 使用self操作当前元素才触发 -->
        <div class="demo1" @click.self="showInfo1">
            <button  @click="showInfo1">点我提示信息</button>
        </div>
        
        <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕： -->
        <!-- @scroll 滚动条的滚动  @wheel 鼠标滚轮滚动 -->
        
        <!-- 加上后鼠标滚轮触发demo函数，不会影响滚动条的变化 -->
        <ul @wheel.passive="demo" class="list">
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
        </ul>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm =  new Vue({
             el:'#root', 
            data:{
                name:'B站',
                address:'上海',
            },
            methods: {
                showInfo(){
                   alert('同学你好');
                },
                showInfo1(e){
                  console.log(e.target);
                },
                showMsg(e){
                    console.log(e);
                },
                demo(){
                    for(let i = 0; i<10000;i++){
                        console.log('#');
                    }
                    console.log('累坏了');
                }
            }
        })
        
    </script>
</body>
</html>
```

#### 1.7.2.2 总结

Vue中的事件修饰符

1. prevent 阻止默认事件（常用）
2. stop: 阻止事件冒泡（常用）
3. once：事件只触发一次（常用）
4. capture：使用事件的捕获模式
5. self：只有event.target是操作当前元素时才触发事件
6. passive:事件的默认行为立即执行，无需等待事件回调执行完毕

### 1.7.3 键盘事件

#### 1.7.3.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>键盘事件</title>
    <!-- 引入vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
 
</head>
<body>
     <!-- 创建一个容器 -->
    <div id="root">
        <h2>欢迎来到：{{name}}学习</h2>
        <!-- @keydown按下去触发  @keyup按下去抬起来提示 -->
        <input type="text" placeholder="按下回车提示输入" @keyup.enter="showInfo" >
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
         new Vue({
            el:'#root', 
            data:{
                name:'B站',
            },
            methods: {
                showInfo(e){
                    // keyCode代表点击键盘上出现的编号  13时enter的编号
                    if(e.keyCode != 13) return
                    console.log(e.target.value);
                },
                showInfo2(e){
                    console.log(e.target.value);
                },
                showInfo3(e){
                    console.log(e.key,e.keyCode);
                },
            }
        })
        
    </script>
</body>
</html>
```

#### 1.7.3.2 总结

1. Vue中常用的按键别名：
    - 回车 => enter
    - 删除 => delete (捕获“删除”和“退格”键，其中删除键不会影响数据变化)
    - 退出 => esc
    - 空格 => space
    - 换行 => tab (特殊，必须配合keydown去使用)
    - 上 => up
    - 下 => down
    - 左 => left
    - 右 =>right
    
2. Vue未提供别名的案件，可以使用案件原始的key只去绑定，但注意要转为kebab-case(短横线命名)
    - @keyup.enter = @keyup.Enter
    - capsLock 大写键触发  @keyup.caps-lock
3. 系统修饰键 （用法特殊）：ctrl、alt、shift\meta
    - 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
    - 配合keydown使用：正常触发事件
    
4. 也可以使用keyCode去指定具体的按键（不推荐，有些浏览器已经不支持了）
    - @keyup.enter = @keyup.13
5. Vue.config.keyCodes  自定义键名 = 键码，可以去定制键别名


小技巧：

1. 如果既要阻止冒泡又要阻止默认事件可以连着写

```
@Click.stop.prevent
```

2. 如果使用ctrl+y组合键 调用方法 

```
@keyup.ctrl.y 
```

### 1.7.4 一些案例技巧

聊天中的ctrl+enter换行与enter发送

利用输入键盘后附带的其他状态键


```vue
<template>
 <div>
  <el-input 
    type="textarea" 
    :rows="6" 
    placeholder="请输入您想要咨询的问题" 
    v-model="textValue" 
    @keydown.enter.native="keyDown" 
  />
 </div>
</template>
<script>
export default {
 data () {
  return {
    textValue:'',
  }
 },
 methods:{
  keyDown(e) {
    if (e.ctrlKey && e.keyCode == 13) {
        //用户点击了ctrl+enter触发  
        this.textarea += '\n';
    } else {
        //用户点击了enter触发  
        this.sendMessage();
    }
  },
  //发送消息
  sendMessage(){
  },
 },
}
</script>
```

## 1.8 计算属性

### 1.8.1 插值实现

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>姓名案例_插值语法实现</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      姓：<input type="text" v-model:value="firstName"></br></br>
      名：<input type="text" v-model="lastName"></br></br>
      全名：<span>{{firstName.sclice(0,3) }}-{{ lastName}}</span>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
               firstName:'张',
               lastName:'三',
            }
        })
        console.log(vm);
    </script>
</body>
</html>
```

### 1.8.2 methods方法实现


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>姓名案例_methods实现</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      姓：<input type="text" v-model:value="firstName"></br></br>
      名：<input type="text" v-model="lastName"></br></br>
      全名：<span>{{fullName()}}</span>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
               firstName:'张',
               lastName:'三',
            },
            methods: {
                fullName(){
                   return  this.firstName + '-' + this.lastName;
                },
            },
        })
        console.log(vm);
    </script>
</body>
</html>
```

### 1.8.3 计算属性

#### 1.8.3.1 总结

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>姓名案例_计算属性实现</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      姓：<input type="text" v-model:value="firstName"></br></br>
      名：<input type="text" v-model="lastName"></br></br>
      全名：<span>{{fullName}}</span>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
               firstName:'张',
               lastName:'三',
            },
            computed: {
              fullName:{
                //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
                //get 什么时候调用？1.初次读取fullName时， 2.所依赖的属性调用时
                get(){
                    console.log('get被调用了');
                    // console.log(this); 此处的this时vm
                    return this.firstName + '-' + this.lastName
                },
                //set什么时候调用？"fullName"修改时
                set(value){
                  console.log('set',value);
                  const arr = value.split('-')
                  this.firstName = arr[0]
                  this.lastName = arr[1]
                }
              }
            },
          
        })
        console.log(vm);
    </script>
</body>
</html>
```

#### 1.8.3.2 总结

1. 定义：要用的属性不存在，要通过已有属性计算得来。
2. 原理：底层借助了Object.defubeproperty方法提供的getter和setter
3. get函数什么时候执行？
<br>    （1）初次读取时会执行一次。
<br>    （2）当依赖的数据发生改变时会被再次调用。

4. 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。

5. 备注：
<br>    （1）计算属性最终会出现vm上，直接读取使用即可。
<br>    （2）如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生变化

### 1.8.4 计算属性简写

只考虑读取不考虑修改时进行简写

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>姓名案例_计算属性简写</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      姓：<input type="text" v-model:value="firstName"></br></br>
      名：<input type="text" v-model="lastName"></br></br>
      全名：<span>{{fullName}}</span>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
               firstName:'张',
               lastName:'三',
            },
            computed: {
              // 完整写法
              /*fullName:{
                get(){
                    console.log('get被调用了');
                    return this.firstName + '-' + this.lastName
                },
                set(value){
                  console.log('set',value);
                  const arr = value.split('-')
                  this.firstName = arr[0]
                  this.lastName = arr[1]
                }
              } */
              //简写 只考虑读取不考虑修改时调用
              fullName(){
                console.log('get被调用了');
                return this.firstName + '-' + this.lastName
              }
            },
          
        })
        console.log(vm);
    </script>
</body>
</html>
```



## 1.9 监视
### 1.9.1 天气案例

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>天气案例</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>今天天气很{{info}},{{x}}</h2>
        <button @click="changeWeather()">切换天气1</button>
        <!-- 绑定事件的时候：@xxx = "yyy" yyy可以写一些简单的语句 -->
        <button @click="isHot = !isHot">切换天气2</button>
        <!-- 多条运算可以使用;隔开使用 -->
        <button @click="isHot = !isHot;x++">切换天气3</button>
        <!-- alert在window上，默认指向到vm上，只有在data中配置了window才可以使用 -->
        <button @click="window.alert(1)">切换天气4</button>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
             isHot:true,
             x:1,
             window
            },
            computed: {
                info(){
                    return this.isHot ? '炎热' : '凉爽'
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot;
                } 
            }
        })
        console.log(vm);
    </script>
</body>
</html>
```


### 1.9.2 监视属性

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>天气案例_监控属性</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>今天天气很{{info}}</h2>
        <button @click="changeWeather()">切换天气</button>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
             isHot:true,
            },
            computed: {
                info(){
                    return this.isHot ? '炎热' : '凉爽'
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot;
                } 
            },
            watch:{
                info:{
                    //初始化时让handler调用
                    immediate:true,
                    //handler什么时候调用，当isHot发生改变的时候
                    handler(newValue,oldValue){
                        console.log('info被修改了',newValue,oldValue);
                    },
                }
            }
        })
        //第二种写法
        vm.$watch('isHot',{
            //初始化时让handler调用
            immediate:true,
            //handler什么时候调用，当isHot发生改变的时候
            handler(newValue,oldValue){
                console.log('isHot被修改了',newValue,oldValue);
            },
        })
    </script>
</body>
</html>
```

### 1.9.3 深度监视

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>天气案例_深度监视</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>今天天气很{{info}}</h2>
        <button @click="changeWeather()">切换天气</button>
        <hr/>
        <h3>a的值是{{numbers.a}}</h3>
        <button @click="numbers.a++">点我让a+1</button>
        <h3>b的值是{{numbers.b}}</h3>
        <button @click="numbers.b++">点我让b+1</button>
        <button @click="numbers = {a:666,b:888}">彻底替换掉numbers</button>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
             isHot:true,
             numbers:{
                a:1,
                b:1,
             }
            },
            computed: {
                info(){
                    return this.isHot ? '炎热' : '凉爽'
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot;
                } 
            },
            watch:{
                info:{
                    //初始化时让handler调用
                    immediate:true,
                    //handler什么时候调用，当isHot发生改变的时候
                    handler(newValue,oldValue){
                        console.log('info被修改了',newValue,oldValue);
                    },
                },
                // 'numbers.a':{
                //     handler(){
                //         console.log('a被改变了');
                        
                //     }
                // },
                //监视多级结构中所有属性中的变化
                numbers:{
                    deep:true,
                    handler(){
                        console.log('numbers被改变了');
                        
                    }
                },
            }
        })
      
    </script>
</body>
</html>
```

深度监控：
<br>     （1）Vue中的watch默认不监控对象内部值的改变（一层）
<br>     （2）配置deep：true 可以监控对象内布置的改变
改变：
<br>     （1）Vue自身可以监控对象内部值的改变。单Vue提供的watch默认不可以！
<br>     （2）使用watch时根据数据的具体结构，决定是否采用深度监控

### 1.9.4 监控简写

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>天气案例_深度监视</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>今天天气很{{info}}</h2>
        <button @click="changeWeather()">切换天气</button>
      
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
             isHot:true,
           
            },
            computed: {
                info(){
                    return this.isHot ? '炎热' : '凉爽'
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot;
                } 
            },
            watch:{
                //正常写法
                info:{
                    immediate:true,//初始化时让handler调用
                    deep:true,//深度监控
                    handler(newValue,oldValue){
                        console.log('info被修改了',newValue,oldValue);
                    },
                },
                //简写 只需要handler可以简写
                info(newValue,oldValue){
                    console.log('info被修改了',newValue,oldValue);
                }
                    
            }
        })
        //正常的写法
        vm.this.$watch( 'info',{
            immediate:true,//初始化时让handler调用
            deep:true,//深度监控
            handler(newValue,oldValue){
                console.log('info被修改了',newValue,oldValue);
            },
        })
        //简写
        vm.$watch('info',function(newValue,oldValue){
            console.log('info被修改了',newValue,oldValue);
        })
    </script>
</body>
</html>
```

### 1.9.5 监视与评估的区别

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>姓名案例_watch实现</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
      姓：<input type="text" v-model:value="firstName"></br></br>
      名：<input type="text" v-model="lastName"></br></br>
      全名：<span>{{fullName}}</span>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
               firstName:'张',
               lastName:'三',
               fullName:'张-三',
              
            },
            computed: {
              
            },
            watch:{
                firstName(val){
                    setTimeout(() => {
                        this.fullName = val + '-' + this.lastName
                    }, 1000);
                },
                lastName(val){
                    this.fullName = this.firstName + '-' + val
                }
            },
          
        })
    </script>
</body>
</html>
```

### 1.9.6 总结
- computed和watch之间的区别
    1. computed能完成的功能，watch都可以完成
    2. watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作
- 两个重要的小原则：
    1. 所被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象
    2. 所有不被vue所管理的函数（定时器的回调函数，ajax的回调函数等，promise的回调函数），最好写成箭头，这样this的指向才是vm 或 组件实例对象


## 1.10 绑定样式
### 1.10.1 基础使用

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>绑定样式</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
    <style>
        .basic{
            width: 400px;
            height: 100px;
            border: 1px solid black;
        }
        .happy{
            border: 4px solid red;  
            background-color: rgba(255, 255, 0, 0.64);
            background: linear-gradient(30deg,yellow,pink,orange,yellow);
        }
        .sad{
            background-color:gray;
            border: 4px solid green;
        }
        .normal{
            border: 2px solid black;
            background-color:skyblue;
        }
        .at1{
            background-color: chartreuse;
        }
        .at2{
            font-size: 20px;
        }
        .at3{
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 绑定class样式--字符串写法,适用于：样式的类名不确定，需要动态指定 -->
        <div class="basic" :class="mood" @click="changeMood">{{name}}</div>
        </br>
        <!-- 绑定class样式--数组写法,适用于：要绑定的样式个数不确定，名字也不确定 -->
        <div class="basic" :class="classArr">{{name}}</div>
        <div class="basic" :class="[a,b,c]">{{name}}</div>
        </br>
         <!-- 绑定class样式--对象写法,适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 -->
        <div class="basic" :class="classObj">{{name}}</div>
        <div class="basic" :class="{at1:true,at2:false}">{{name}}</div>
        </br>
        <!-- 绑定style样式--对象写法 -->
        <div class="basic" :style="{fontSize: fsize +'px'}">{{name}}</div>
        <div class="basic" :style="styleObj">{{name}}</div>
        <!-- 绑定style样式--数组写法 -->
        <div class="basic" :style="[styleObj,styleObj2]">{{name}}</div>
        <div class="basic" :style="styleArr">{{name}}</div>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        const vm = new Vue({
            el:'#root',
            data:{
                name:'绑定样式',
                mood:'normal',
                classArr: ['at1','at2','at3'],
                a:'at1',
                b:'at2',
                c:'at3',
                classObj:{
                    at1:false,
                    at2:false
                },
                fsize:40,
                styleObj:{
                    fontSize: '40px',
                    color:'red'
                },
                styleObj2:{
                    backgroundColor:'orange'
                },
                styleArr:[
                    {
                        fontSize: '40px',
                        color:'red'
                    },
                    {
                        backgroundColor:'green'
                    }
                ]
            },
            methods: {
                changeMood(){                 
                    const arr = ['happy','sad','normal']
                    let index = Math.floor(Math.random() * 3)
                    this.mood = arr[index]
                }
            }
        })
    </script>
</body>
</html>
```

### 1.10.2 绑定样式使用
1. class样式
    - 写法： :class='xxx' xxx可以是字符串，对象，数组。
        - 字符串写法适用于：类型不确定，要动态获取
        - 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
        - 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用
2. style样式
    - :style="{fontSize':xxx}" 或者 :style="{'font-size','xxx'}" 其中xxx是动态值。
    - :style="[a,b]" 其中a、b是样式对象

### 1.10.3 复杂使用

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>绑定样式_补充</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
    <style>
        .basic{
            width: 400px;
            height: 100px;
            border: 1px solid black;
        }
        .happy{
            border: 4px solid red;  
            background-color: rgba(255, 255, 0, 0.64);
            background: linear-gradient(30deg,yellow,pink,orange,yellow);
        }
        .sad{
            background-color:gray;
            border: 4px solid green;
        }
        .normal{
            border: 2px solid black;
            background-color:skyblue;
        }
        .at1{
            background-color: chartreuse;
        }
        .at2{
            font-size: 20px;
        }
        .at3{
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 使用方法得到数据 括号不能省略-->
        <div class="basic" :class="classWay()" >{{name}}</div>
        <div class="basic" :style="styleWay()" >{{name}}</div>
        </br>
         <!-- 修改绑定的对象 使样式改变 -->
        <div class="basic" :class="classArr" @click="changeClassWay">{{name}}</div>
        <div class="basic" :style="styleObj" @click="changeStyleWay">{{name}}</div>
        </br>
        <!-- 使用表达式直接判断要实现的样式 简单判断与复杂判断 -->
        <div class="basic" :class="{happy:divShow1 === 1}" @click="divShow1 = 1">{{name}}</div>
        <div class="basic" :class="[divShow2 === 1?'happy':'sad']" @click="divShow2 = 1">{{name}}</div>
        </br>
        <!-- 使用小括号进行计算使用 -->
        <div class="basic" :style="{'font-size': (fsize + 1) + 'px' }" @click="divShow2 = 1">{{name}}</div>
       
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        const vm = new Vue({
            el:'#root',
            data:{
                name:'绑定样式_补充',
                mood:'normal',
                classArr: ['at1','at2','at3'],
                a:'at1',
                b:'at2',
                c:'at3',
                classObj:{
                    at1:false,
                    at2:false
                },
                fsize:40,
                styleObj:{
                    fontSize: '40px',
                    color:'red'
                },
                styleObj2:{
                    backgroundColor:'orange'
                },
                styleArr:[
                    {
                        fontSize: '40px',
                        color:'red'
                    },
                    {
                        backgroundColor:'green'
                    }
                ],
                divShow1:0,
                divShow2:0,
            },
            methods: {
                classWay(){
                    let tt =  ['at1','at2']
                    return tt
                },
                styleWay(){
                    return {'font-size':'30px','color':'yellow'}
                },
                changeClassWay(){
                    this.classArr = [this.a,this.b]
                },
                changeStyleWay(){
                    this.styleObj = {  fontSize: '20px',color:'blue'}
                },

                changeMood(){                 
                    const arr = ['happy','sad','normal']
                    let index = Math.floor(Math.random() * 3)
                    this.mood = arr[index]
                }
            }
        })
    </script>
</body>
</html>
```

### 1.10.4 总结
1. 使用样式逻辑非常多的时候，可以直接使用方法判断逻辑
2. 样式不确定时，根据执行中的方法，修改样式对象绑定的值进而展示不同风格
3. class类型是否展示可根据对象判断，三元表达式使用数组进行绑定
4. style中运算要使用小括号给括起来


## 1.11 条件渲染

### 1.11.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>条件渲染</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <h2>当前的n值是:{{n}}</h2>
        <button @click="n++">点我n+1</button>
        <!-- 使用v-show做条件渲染 -->
        <!-- <h2 v-show="a">欢迎来到{{name}}</h2>
        <h2 v-show="1 === 1">欢迎来到{{name}}</h2> -->
        <!-- 使用v-if做条件渲染 -->
        <!-- <h2 v-if="a">欢迎来到{{name}}</h2>
        <h2 v-if="1 === 1">欢迎来到{{name}}</h2> -->
        <div v-show="n === 1">Angular</div>
        <div v-show="n === 2">React</div>
        <div v-show="n === 3">Vue</div>
        
        <!-- v-else 和 v-else-if -->
        <div v-if="n === 1">Angular</div>
        <div v-else-if="n === 2">React</div>
        <div v-else>Vue</div>
        
        <template v-if="n === 1">
            <h2>你好</h2>
            <h2>n站</h2>
            <h2>上海</h2>
        </template>
       
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
                name:'条件渲染',
                a:false,
                n:0,
            },
                     
        })
    </script>
</body>
</html>
```

### 1.11.2 总结

1. v-if
    - 写法：
        - （1）v-if="表达式"
        - （2）v-else-if="表达式"
        - （3）v-else="表达式"
    - 适用于：切换频率较低的场景
    - 特点：不展示的DOM元素直接被移除
    - 注意：v-if可以和：v-else-if、v-else 一起使用
2. v-show
    - 写法：v-show="表达式"，
    - 适用于：切换频率较高的场景。
    - 特定：不显示的DOM元素未被移除，仅仅是使用样式隐藏掉
3. 备注：使用v-if时，元素可能无法获取到，而使用v-show一定能够获取到
     - 使用templete标签时，智能使用v-if

## 1.12 列表渲染

### 1.12.1 基础列表

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>基本列表</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 遍历数组 -->
        <h2>人员列表(遍历数组)</h2>
        <ul>
          <li v-for="(person,index) of persons" :key="person.id">
              {{person.name}}-{{person.age}}
          </li>
        </ul>
        <!-- 遍历对象 -->
        <h2>汽车信息(遍历对象)</h2>
        <ul>
          <li v-for="(value,k) of car" :key="k">
              {{k}}-{{value}}
          </li>
        </ul>
        <!-- 遍历字符串 -->
        <h2>测试遍历字符串(用的少)</h2>
        <ul>
          <li v-for="(char,index) of strs" >
              {{char}}-{{index}}
          </li>
        </ul>
         <!-- 遍历指定次数 -->
         <h2>测试遍历指定次数(用的少)</h2>
         <ul>
           <li v-for="(number,index) of 5" :key="index">
               {{number}}-{{index}}
           </li>
         </ul>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
              persons:[
                {id:'001',name:'张三',age:18},
                {id:'002',name:'李四',age:19},
                {id:'003',name:'王五',age:20},
              ],
              car:{
                name:'奥迪A8',
                privce:'70万',
                color:'黑色',
              },
              strs:"hello",
            },
          
          
        })
    </script>
</body>
</html>
```

v-for指令

1. 用于展示列表数据
2. 语法：v-for="(item,index) in xxx" :key="yyy"
3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）


### 1.12.2 key值的原理

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>key的原理</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 遍历数组 -->
        <h2>人员列表(遍历数组)</h2>
        <button @click.once ="add">添加一个老刘</button>
        <ul>
          <li v-for="(person,index) of persons" :key="index">
              {{person.name}}-{{person.age}}
              <input type="text">
          </li>
        </ul>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:'#root', 
            data:{
              persons:[
                {id:'001',name:'张三',age:18},
                {id:'002',name:'李四',age:19},
                {id:'003',name:'王五',age:20},
              ],
           
            },
            methods: {
              add(){
                const p = {id:'004',name:'老刘',age:40}
                //添加到第一个
                this.persons.unshift(p)
              }
            }
        })
    </script>
</body>
</html>
```

面试题

react vue中的key有什么作用？(key的内部原理)
1. 虚拟DOM中key的作用：
<br>    key时虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则：
<br>     （1）旧虚拟DOM中找到了与新虚拟DOM相同的key
<br>         a、若虚拟DOM中内容没变，直接使用之前的真实DOM!
<br>         b、若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
<br>     （2）旧虚拟DOM中未找到与新虚拟DOM相同的key，创建新的真实DOM,随后替换掉页面中之前的真实DOM.


3. 用index作为key可能会引发的问题：
    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作：
        - 会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。
    2. 如果结构中还包含输入类DOM:
        - 会产生错误DOM更新 ==>界面有问题
4. 开发中如何选中key?
    1. 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证好、学号等唯一值
    2. 如果不窜对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示。使用index作为key是没有问题的


### 1.12.3 列表过滤

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>列表的过滤</title>
    <!-- 引入Vue -->
    <script  type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <!-- 遍历数组 -->
        <h2>人员列表</h2>
        <input type="text" v-model="keyWord" placeholder="请输入姓名" >
        <ul>
          <li v-for="(person,index) of filterPersons" :key="index">
              {{person.name}}-{{person.age}}-{{person.sex}}
          </li>
        </ul>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        
        //用watch实现
        //#region
      /*  const vm = new Vue({
            el:'#root', 
            data:{
              keyWord:'',
              persons:[
                {id:'001',name:'马冬梅',age:18,sex:'女'},
                {id:'002',name:'周冬雨',age:19,sex:'女'},
                {id:'003',name:'周杰伦',age:20,sex:'男'},
                {id:'004',name:'温兆伦',age:21,sex:'男'},
              ],
              filterPersons:[],
            },
            watch: {
              keyWord:{
                immediate:true,
                handler(val){
                    this.filterPersons = this.persons.filter((p)=>{
                        //函数体
                        return p.name.indexOf(val) !== -1
                    })
                }
              }
            },
        }) */
        //用computed实现
        const vm = new Vue({
            el:'#root', 
            data:{
              keyWord:'',
              persons:[
                {id:'001',name:'马冬梅',age:18,sex:'女'},
                {id:'002',name:'周冬雨',age:19,sex:'女'},
                {id:'003',name:'周杰伦',age:20,sex:'男'},
                {id:'004',name:'温兆伦',age:21,sex:'男'},
              ],
            },
            computed:{
              filterPersons(){
                return this.persons.filter((p)=>{
                    return p.name.indexOf(this.keyWord) !== -1
                })
              }
            }
        })
   </script>
</body>
</html>
```

总结：

1. 使用数组的filter方法进行过滤，返回一个数组类型
2. 空字符每个字符都有种都含有，使用空字符去匹配时能够匹配全部的字符

### 1.12.4 数据监测

```html
<!-- 创建一个容器 -->
<div id="root">
  <h1>学生信息</h1>
  <button @click="student.age++">年龄+1岁</button><br />
  <button @click="addSex">添加一个性别属性,默认值是男</button><br />
  <button @click="student.sex = '未知'">修改性别</button><br />
  <button @click="addFriend">在列表首位添加一个朋友</button><br />
  <button @click="updateFirstFriendName">修改第一个朋友的名字为：张三</button><br />
  <button @click="addHobby">添加一个爱好</button><br />
  <button @click="updateHobby">修改第一个爱好为：开车</button><br />
  <h2>姓名：{{student.name}}</h2>
  <h2>年龄：{{student.age}}</h2>
  <h2 v-if="student.sex">性别：{{student.sex}}</h2>
  <h2>爱好</h2>
  <ul>
    <li v-for="(h,index) in student.hobby" :key="index">
      {{h}}
    </li>
  </ul>
  <h2>朋友们</h2>
  <ul>
    <li v-for="(f,index) in student.friends" :key="index">
      {{f.name}} -- {{f.age}}
    </li>
  </ul>
</div>
<script type="text/javascript">
  Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
  //用computed实现
  const vm = new Vue({
    el: '#root',
    data: {
      student: {
        name: "tom",
        age: 18,
        hobby: ['抽烟', '喝酒', '烫头'],
        friends: [
          { name: 'jerry', age: 35 },
          { name: 'tony', age: 36 }
        ]
      }
    },
    methods: {
      addSex() {
        // Vue.set(this.student, 'sex', '男')
        this.$set(this.student, 'sex', '男')
      },
      addFriend() {
        this.student.friends.unshift({ name: 'jack', age: 70 })
      },
      updateFirstFriendName() {
        this.student.friends[0].name = 'zhangsan'
      },
      addHobby() {
        this.student.hobby.push("学习")
      },
      updateHobby() {
        // this.student.hobby.splice(0, 1, '开车')
        Vue.set(this.student.hobby, 0, '开车')
      },
    }
  })
</script>
```

### 1.12.5 总结

Vue 监测数据的原理

1. vue会监测data中所有层次的数据

2. 如何监测对象中的数据？
    - 通过setter实现监视，且要在new Vue时就传入要监测的数据。
    - （1）.对象中后最佳的属性，Vue默认不做响应式处理
    - （2）.如需给后添加的属性做响应式，请使用如下API:
        - Vue.set(target,propertyName/index,value) 或
        - vm.$set(target,propertyName/index,value)
3. 如何监测数组中的数据？
    - 通过包裹数组更新元素的方法实现，本质就是做了两件事：
        - （1）.调用原生对象的方法对数组进行更新.
        - （2）.重写解析模板，进而更新页面
4. 在Vue修改数组中的某个袁术一定要使用如下方法：
    1. 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
    2. Vue.set() 或 vm.$set()


特别注意：Vue.set() 和vm.$set() 不能给vm或vm的根数据对象 添加属性！！


## 1.13 收集表单数据


### 1.13.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>基本列表</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <form @submit.prevent="demo">
            账号：<input type="text" v-model.trim="userInfo.account"> <br /><br />
            密码：<input type="password" v-model="userInfo.password"><br /><br />
            密码：<input type="number" v-model.number="userInfo.age"><br /><br />
            性别：
            男<input type="radio" name="gender" v-model="userInfo.sex" value="male">
            女<input type="radio" name="gender" v-model="userInfo.sex" value="famale">
            <br /><br />
            爱好：
            学习<input type="checkbox" v-model="userInfo.hobby" value="study">
            打游戏<input type="checkbox" v-model="userInfo.hobby" value="game">
            吃饭<input type="checkbox" v-model="userInfo.hobby" value="eat">
            <br /><br />
            所属校区
            <select v-model="userInfo.city">
                <option value="">请选择校区</option>
                <option value="beijing">北京</option>
                <option value="shanghai">上海</option>
                <option value="shenzhen">深圳</option>
                <option value="wuhan">深圳</option>
            </select>
            <br /><br />
            其他信息：
            <textarea v-model.lazy="userInfo.otherInfo"></textarea>
            <br /><br />
            <input type="checkbox" v-model="userInfo.agree">阅读并接收<a href="http://wwww.baidu.com">《用户协议》</a>
            <button>提交</button>
        </form>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        const vm = new Vue({
            el: '#root',
            data: {
                userInfo: {
                    account: '',
                    password: '',
                    hobby: [],
                    sex: 'famale',
                    city: '',
                    otherInfo: '',
                    agree: '',
                    age: '',
                }
            },
            methods: {
                demo() {
                    console.log(JSON.stringify(this._data));
                }
            }
        })
    </script>
</body>
</html>
```

### 1.13.2 总结

- 若：`<input type="text">`,则v-model收集的是value值，用户输入的就是value值
- 若：`<input type = "radio"/>` 则v-model收集的是value值，且要给标签配置value值
- 若：`<input type="checkbox" />`
    1. 没有配置input的value属性，那么收集就是checked（勾选 or 未勾选，是布尔值）
    2. 配置input的value属性：
        - （1）v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
        - （2）v-model的初始值是数组，那么收集的就是value组成的数组
    
备注：v-model的三个修饰符

- lazy:失去焦点再收集数据
- number:输入字符串转为有效的数字
- trim：输入首位空格过滤


## 1.14 过滤器
  
### 1.14.1 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>基本列表</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
    <script type="text/javascript" src="../js/dayjs.min.js"></script>
</head>
<body>
    <!-- 创建一个容器 -->
    <div id="root">
        <div>显示格式化后的时间</div>
        <!-- 就算属性实现 -->
        <div>现在是：{{fmtTime}}</div>
        <!-- methods实现 -->
        <div>现在是：{{getFmtTime()}}</div>
        <!-- 过滤器实现 -->
        <div>现在是：{{time | timeFormater}}</div>
        <div>现在是：{{time | timeFormater('YYYY-MM-DD')}}</div>
        <!-- 过滤实现（传参） -->
        <div>现在是：{{time | timeFormater('YYYY-MM-DD') | mySlice}}</div>
        <h3 :x="msg | mySlice">尚硅谷</h3>
    </div>
    <div id="root2">
        <h3>{{msg | mySlice}}</h3>
    </div>
    <script type="text/javascript">
        Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。
        // 第一种方式注册
        Vue.filter('mySlice', function (value) {
            return value.slice(0, 4);
        })
        const vm = new Vue({
            el: '#root',
            data: {
                time: 1695372809656,
                msg: '你好，尚硅谷',
            },
            computed: {
                fmtTime() {
                    return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
                }
            },
            methods: {
                getFmtTime() {
                    return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
                }
            },
            filters: {
                timeFormater(value, str = 'YYYY年MM月DD日 HH:mm:ss') {
                    console.log(value);
                    return dayjs(value).format(str)
                },
                             // 第二种方式注册
                mySlice(value) {
                    return value.slice(0, 4)
                },
            }
        })
        new Vue({
            el: '#root2',
            data: {
                msg: "hello,atguigu!"
            },
        })
    </script>
</body>
</html>
```

### 1.14.2 总结

定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。


- 语法：
    1. 注册过滤器：`Vue.filter(name,callback)` 或 `new Vue{filter:{}}`
    2. 使用过滤器：`{{ xxx | 过滤器名 }}` 或 v-bind:属性 = "xxx | 过滤器名"
- 备注：
    1. 过滤器也可以接收额外参数，多个过滤器也可以串联
    2. 并没有改变原本的数据，而是产生新的对应的数据


## 1.15 内置指令


vue自身提供的指令是内置指令

我们学过的指令：

- v-bind  : 单向绑定解析表达式，可简写未 :xxx
- v-model : 双向数据绑定
- v-for   : 遍历数组/对象/字符串
- v-on    : 绑定事件监听，可简写为@
- v-if    : 条件渲染（条件控制节点是否存在）
- v-else  : 条件渲染（动态控制节点是否存在）
- v-show  : 条件渲染（动态控制节点是否展示）

### 1.15.1 v-text_指令

v-text指令：

1. 作用：向其所在的节点中渲染文本内容
2. 与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <div>{{name}}</div>
        <div v-text="name"></div>
        <div v-text="str"></div>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            name: '尚硅谷',
            str: '<h3>你好啊！</h3>'
        }
    })
</script>
</html>
```


### 1.15.2 v-html指令

1. 作用：向指定节点中渲染包含html结构的内容
2. 与插值语法的区别
    - （1）.v-html会替换掉节点中所有的内容，{{xx}}则不会
    - （2）.v-html可以识别html结构
3. 严重注意：v-html有安全性问题！！
    - （1）.在网站上动态渲染任意HTML是非常危险的，容易导致xss攻击
    - （2）.一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <div>你好，{{name}}</div>
        <div v-text="str"></div>
        <div v-html="str"></div>
        <div v-html="str2"></div>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            name: '尚硅谷',
            str: '<h3>你好啊！</h3>',
            str2:'<a href=javascript:location.href="http://www.baidu.com?"+document.cookie>兄弟我找到你想看到的，点这里</a>'
        }
    })
</script>
</html>
```


### 1.15.3 v-clock指令（没有值）

1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性
2. 使用css配合v-cloak可以解决网速慢时页面展示出`{{xx}}`的问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>v-cloak</title>
   <style>
        [v-cloak]{
            display: none;
        }
   </style>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <div v-clock>{{name}}</div>
    </div>
     <!-- 引入Vue -->
     <script type="text/javascript" src="http://localhost:8080/resource/5s/vue.js"></script>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            name: '尚硅谷',
        }
    })
</script>
</html>
```

### 1.15.4 v-once指令：

1. v-once所在节点在初次动态渲染后，就视为静态内容了。
2. 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>v-once</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h2 v-once>初始化的n值是：{{n}}</h2>
        <h2>当前的n值是：{{n}}</h2>
        <button @click="n++">点我n+1</button>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            n: 1,
        }
    })
</script>
</html>
```

### 1.15.5 v-pre指令：

1. 跳过其所在节点的编译
2. 可利用它条跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>v-once</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h2 v-pre>Vue其实很简单</h2>
        <h2>当前的n值是：{{n}}</h2>
        <button @click="n++">点我n+1</button>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            n: 1,
        }
    })
</script>
</html>
```


## 1.16 自定义指令

### 1.16.1 需求

需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。
需求2：定义一个v-fbind指令，和v-bind功能雷士，但可以让其所绑定的input元素默认获取焦点


### 1.16.2 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>v-once</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h2>{{name}}</h2>
        <h2>当前的n值是：<span v-text="n"></span></h2>
        <h2>放大10倍后的n值是：<span v-big="n"></span></h2>
        <button @click="n++">点我n+1</button>
        <hr/>
        <input type="text" v-fbind:value="n">
    </div>
    <div id="root2">
        <input type="text" v-fbind-number:value="x">
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    
    //定义全局指令
    Vue.directive('fbind-number',{
        //指令与元素成功绑定时（一上来）
        bind(elment,binding){
            elment.value = binding.value;
        },
        //指令所在元素被插入页面时
        inserted(elment,binding){
            elment.focus();
        },
        //指令所在的模板被重新解析时
        update(elment,binding){
            elment.value = binding.value;
        },
    })


    
    new Vue({
        el: '#root',
        data: {
            n: 1,
            name:'尚硅谷'
        },
        directives:{
            //big函数何时会被调用？ 
            // 1.指令与元素成功绑定时（一上来）
            // 2.指令所在的模板被重新解析时。
            big(elment,binding){
                console.log('big',this); //这个this指向的是window
                elment.innerText = binding.value * 10;
            },
            fbind:{
                //指令与元素成功绑定时（一上来）
                bind(elment,binding){
                    console.log('bind');
                    elment.value = binding.value;
                },
                //指令所在元素被插入页面时
                inserted(elment,binding){
                    elment.focus();
                },
                //指令所在的模板被重新解析时
                update(elment,binding){
                    elment.value = binding.value;
                },
            },
           
        }
    })
  
</script>
</html>
```

### 1.16.3 总结


1. 定义语法：
    - （1）.局部指令
        ```html
        new Vue({
            directives:{指令名：配置对象}                      
        })

        或

        new Vue({
            directives:{指令名：配置对象}                      
        }) 
        ```          
    - （2）.全局指令
        - Vue.directive(指令名,配置对象)     或      
        - Vue.directive(指令名,回调函数)
2. 配置对象中常用的3个回调
    - （1）.bind: 指令与元素成功绑定时调用
    - （2）.inserted: 指令所在元素被插入页面时调用
    - （3）.update: 指令所在模板结构被重新解析时调用
3. 备注
    1. 指令定义时不加v-,但使用时要加v-
    2. 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCass命名。


## 1.17 生命周期

### 1.17.1 引出生命周期

生命周期

1. 又名：生命周期回调函数、生命周期函数、生命周期钩子
2. 是什么：Vue在关键时刻帮助我们调用的一些特殊名称的函数
3. 生命周期函数的名字不可更改，但函数的具体内容是程序员更具需求编写的
4. 生命周期函数忠的this指向是vm 或 组件实例对象


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>01引出生命周期</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h2 :style="{opacity}">欢迎学习Vue</h2>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    const vm = new Vue({
        el: '#root',
        data: {
            opacity: 1,
        },
        methods: {
            change() {
                setInterval(() => {
                    vm.opacity -= 0.01
                    if (vm.opacity <= 0) {
                        vm.opacity = 1
                    }
                }, 16)
            }
        },
        //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕） 调用完毕
        mounted() {
            this.change();
        },

    })
    //通过外部的定时器实现（不推荐）
    // setInterval(() =>{
    //     vm.opacity -= 0.01
    //     if(vm.opacity <= 0){
    //         vm.opacity = 1
    //     }
    // },16)
</script>
</html>
```

### 1.17.2 分析生命周期

![](/framework/vue/vue2/002.png)


查看每一步的vue的执行生命周期

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>02分析生命周期</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h2>当前n的值是{{n}}</h2>
        <button @click="add">点我n+1</button>
        <button @click="bye">点我销毁vm</button>
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        data: {
            n: 1
        },
        methods: {
            add() {
                this.n++;
            },
            bye() {
                console.log('bye');
                this.$destroy();
            }
        },
        beforeCreate() {
            console.log('beforeCreate');
            // console.log(this);
            // debugger;
        },
        created() {
            console.log('created');
            // console.log(this);
            // debugger;
        },
        beforeMount() {
            console.log('beforeMount');
            //看页面
            // document.querySelector('h2').innerText = '哈哈哈'
            // debugger;
        },
        mounted() {
            console.log('mounted');
        },
        beforeUpdate() {
            console.log('beforeUpdate');
            //  console.log(this);
            //   debugger;
        },
        updated() {
            console.log('updated');
            //  console.log(this);
            //   debugger;
        },
        beforeDestroy() {
            console.log('beforeDestroy');
        },
        destroyed() {
            console.log('distroyed');
        },
    })

</script>
</html>
```

在created与beforemount之间加载DOM是可以以模板的形式进行加载，出现来了template 直接将内容加载到el对应的标签中

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>02分析生命周期</title>
    <!-- 引入Vue -->
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
    </div>
</body>
<script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生成提示。
    new Vue({
        el: '#root',
        template: `
            <div>
                <h2>当前n的值是{{n}}</h2>
                <button @click="add">点我n+1</button>
            </div>
        `,
        data: {
            n: 1
        },
        methods: {
            add() {
                this.n++;
            },
            bye() {
                console.log('bye');
                this.$destroy();
            }
        },
        beforeCreate() {
            console.log('beforeCreate');
            // console.log(this);
            // debugger;
        },
        created() {
            console.log('created');
            // console.log(this);
            // debugger;
        },
        beforeMount() {
            console.log('beforeMount');
            //看页面
            // document.querySelector('h2').innerText = '哈哈哈'
            // debugger;
        },
        mounted() {
            console.log('mounted');
        },
    })

</script>
</html>
```

### 1.17.3 生命周期总结

常用的生命周期钩子：

1. created: 一些需要从数据库取得的常量、从url路由中获取的值都在这里取
2. mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
3. beforeDestroy: 清楚定时器、解绑自定义事件、取消订阅消息等【收尾工作】。
