# 三、使用vue脚手架

## 3.1 创建vue项目

### 3.1.1 说明
1. Vue脚手架是Vue官方提供的标准化开发工具（开发平台）。
2. 最新的版本是5.x(后续不会再更新，因为vue3使用vite进行构建)。
3. 文档:https://cli.vuejs.org/zh/


### 3.1.2 具体步骤
- 第一步（仅第一次执行）：全局安装@vue/cli。
```sh
npm install -g @vue/cli
```
- 第二步：切换到你要创建项目的目录，然后使用命令创建项目
```sh
vue create xxxx
```
- 第三步：启动项目
```sh
npm run serve
```

备注：

1. 如出现下载缓慢请配置npm淘宝镜像：
    ```sh
    npm config set registry https://registry.npm.taobao.org
    ```
2. Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpakc配置，请执行：
    ```sh
    vue inspect>output.js
    ```


### 3.1.3 启动后

![](/framework/vue/vue2/015.png)


## 3.2 分析脚手架配置

### 3.2.1 模板项目的结构

![](/framework/vue/vue2/016.png)

### 3.2.2 项目中的配置

main.js 配置解析

```js
/* 
  该文件是整个项目的入口文件
*/
//引入vue
import Vue from 'vue'
//引入App组件，他是所有组件的父组件
import App from './App.vue'
//关闭vue的生产提示
Vue.config.productionTip = false

//创建Vue实例对象 --vm
new Vue({
  el:'#app',
  render: h => h(App),
})

// 使用el配置等于$mount挂载
// new Vue({
//   render: h => h(App),
// }).$mount('#app')
```

index.js 解析

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器其以最高的渲染级别渲染页面 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 开启移动端的理想视口 -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- 配置页签图标  <%= BASE_URL %> 等于 ./ -->
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <!-- 配置网页标题 <%= htmlWebpackPlugin.options.title %> 找到package.json中的name -->
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <!-- 当浏览器不支持js时noscript中的元素就会被渲染 -->
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <!-- 容器 -->
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
```

### 3.2.3 render函数
当前vue在这个目录下引用

![](/framework/vue/vue2/016.png)

![](/framework/vue/vue2/017.png)


上一级目录下的vue.runtime.esm.js 是真正使用的版本

esm 代表 ES moudle

关于不同版本的Vue:
1. vue.js与vue.runtime.xxx.js的区别：
    - （1）. vue.js是完整版的Vue,包含核心功能+模板解析器。
    - （2）. vue.runtime.xxx.js是运行版的Vue,只包含：核心功能（没有模板解析器）

2. 因为Vue.runttime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用
    - render函数接收到的createElement函数去指定具体内容


验证render 函数

```js
import Vue from 'vue'
import App from './App.vue'
Vue.config.productionTip = false

new Vue({
  el:'#app',
  // render: h => h(App),
  /* 自己来操作 */
  render(createElement){
    return createElement("h1","你好啊！")
  }
})

```

![](/framework/vue/vue2/018.png)

之所以能够解析vue中template标签，完全是因为引入下面这个模板

![](/framework/vue/vue2/019.png)


### 3.2.4 修改默认配置
1. 查看默认配置

使用vue inspect>output.js 可以查看到Vue脚手架的默认配置

2. 修改默认配置

使用vue.config.js可以对当前脚手架进行个性化定制，详情见： https://cli.vuejs.org/zh/config





如：以下属性都可以修改

vue.config.js

```js
module.exports = {
  pages: {
    index: {
      // page 的入口
      entry: 'src/index/main.js',
      // 模板来源
      template: 'public/index.html',
      // 在 dist/index.html 的输出
      filename: 'index.html',
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>
      title: 'Index Page',
      // 在这个页面中包含的块，默认情况下会包含
      // 提取出来的通用 chunk 和 vendor chunk。
      chunks: ['chunk-vendors', 'chunk-common', 'index']
    },
    // 当使用只有入口的字符串格式时，
    // 模板会被推导为 `public/subpage.html`
    // 并且如果找不到的话，就回退到 `public/index.html`。
    // 输出文件名会被推导为 `subpage.html`。
    subpage: 'src/subpage/main.js'
  }
}
```

## 3.3 ref属性

代码：

App.vue

```vue
<template>
    <div>
        <h1 v-text="msg" id="title1"  ref="title2"></h1>
        <button @click="showDOM">点我输出上方的DOM元素</button>
        <School id="title3"  ref="title4"></School>
    </div>
</template>
<script>
import School from './components/School.vue'
export default {
    name:'App',
    components:{School},
    data(){
        return{
            msg:'欢迎学习vue'
        }
    },
    methods:{
        showDOM(){
            console.log(document.getElementById('title1')); //真实dom元素
            console.log(this.$refs.title2);                 //真实dom元素
            console.log(document.getElementById('title3')); //真实dom元素
            console.log(this.$refs.title4);                 //VueComponent 对象
            
        }
    }
   
}
</script>
```

School.vue

```vue
<template>
    <div>
        <div class="demo">
            <h2>学校名称：{{name}}</h2>
            <h2>学校地址：{{address}}</h2>
        </div>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷',
                address:'北京昌平',
            }
        },
    }
</script>
<style>
    /* 组件的样式 */
    .demo{
        background-color: gray;
    }
</style>
```

页面打印输出

![](/framework/vue/vue2/021.png)


## 3.4 props配置

### 3.4.1 代码

App.vue

```vue
<template>
    <div>
        <Student name='李四' sex="女" :age="18"/>
    </div>
</template>
<script>
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{Student},  
}
</script>
```

Student.vue

```vue
<template>
    <div>
        <div class="demo">
            <h1>{{msg}}</h1>
            <h2>学生姓名：{{name}}</h2>
            <h2>学生性别：{{sex}}</h2>
            <h2>学生年龄：{{age + 1}}</h2>
            <button @click="updateAge()">尝试修改收到的年龄</button>
        </div>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        data(){
            return {
                msg:'我是一个尚硅谷的学生！',
                myAge: this.age,
            }
        },
        methods:{
            updateAge(){
                this.myAge ++;
            }
        },
        // 简单接收
        // props:['name','age',"sex"],
        // 接收的同时对数据进行类型限制
        // props:{
        //     name:String,
        //     age:Number,
        //     sex:String
        // },
        // 接收的同时对数据进行类型限制 + 默认值的指定 + 必要值的限制
        props:{
            name:{
                type:String,    //name的类型是字符串
                required:true   //name是必要的
            },
            age:{
                type:Number,
                default:99      //默认值
            },
            sex:{
                type:String,
                required:true
            }
        }
       
    }
</script>
```

### 3.4.2 总结

功能： 让组件接收外部传过来的数据

- （1）传递数据
    ```html
    <Demo name="xxx"/>
    ```
- （2）接收数据
    - 第一种方式（只接收）：
        ```js
        props:['name']
        ```
    - 第二种方式（限制类型）：
        ```js
        props:{
            name:String
        }
        ```
    - 第三种方式（限制类型、限制必要性、指定默认值）
        ```js
        props:{
            name:{
                type:String,   //类型
                required:true, //必要性
                default:'老王'  //默认值
            }
        }
        ```

备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。


## 3.5 mixin混入

### 3.5.1 局部混入

混入mixin.js文件

```js
export const hunhe = {
    methods: {
        showName(){
           alert(this.name)
        }   
   },
   mounted(){
    console.log('挂载了');
   },
}
export const hunhe2 = {
    data(){
        return {
            x:100,
            y:200,
        }
    }
}
```

App.vue

```vue
<template>
    <div>
        <School></School>
        <hr>
        <Student/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
}
</script>
```

School.vue
```vue
<template>
    <div>
        <h2 @click="showName()">学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
    </div>
</template>

<script>
    // 引入一个混合
    import {hunhe,hunhe2} from '../mixin.js'
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷',
                address:'北京昌平',
                
                x:666,
            }
        },
       mixins:[hunhe,hunhe2],
       mounted(){
            console.log("自己挂载了");
       },
    }
</script>
```

Student.vue
```vue
<template>
    <div>
        <h2 @click="showName">学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
    </div>
</template>

<script>
    // 引入一个混合
    import {hunhe} from '../mixin.js'
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
        mixins:[hunhe],
    }
</script>
<style>
</style>
```

### 3.5.2 全局混入

Main.js
```js
import Vue from 'vue'
import App from './App.vue'

// 如果混入
import { hunhe,hunhe2 } from './mixin'
Vue.config.productionTip = false

// 配置混入
Vue.mixin(hunhe)
Vue.mixin(hunhe2)

new Vue({
    el:'#app',
    render: h => h(App),
})
```

### 3.5.3 总结

- 功能：可以把多个组件公用的配置提取成一个混入对象
- 使用方式：
    - 第一步定义混合：例如：
        ```JSON
        {
            data(){...},
            methods:{...}
            ...
        }
        ```
    - 第二步使用混入,例如：
        - (1). 全局混入：Vue.mixin(xxx)
        - (2). 局部混入：mixins:['xxx']

## 3.6 插件

### 3.6.1 代码

plugins.js

```js
export default {
    install(Vue,x,y,z){
        console.log(x,y,z);
        
        // 全局过滤器
        Vue.filter('mySlice', function (value) {
            return value.slice(0, 4);
        })
        //定义全局指令
        Vue.directive('fbind',{
            //指令与元素成功绑定时（一上来）
            bind(elment,binding){
                elment.value = binding.value;
            },
            //指令所在元素被插入页面时
            inserted(elment,binding){
                elment.focus();
            },
            //指令所在的模板被重新解析时
            update(elment,binding){
                elment.value = binding.value;
            },
        })
        //定义混入
        Vue.mixin({
            data(){
                return {
                    x:100,
                    y:200,
                }
            }
        })
        
        //给Vue原型上添加一个方法
        Vue.prototype.hello = () => { alert('你好啊')}
    }
}
```

main.js

```js
import Vue from 'vue'
import App from './App.vue'

// 引入插件
import plugins  from './plugins'
Vue.config.productionTip = false
// 使用 后续参数都是可以接收的
Vue.use(plugins,1,2,3)
//创建Vue实例对象 --vm
new Vue({
    el:'#app',
    render: h => h(App),
})
```

App.vue
```vue
<template>
    <div>
        <School></School>
        <hr>
        <Student/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
}
</script>
```

School.vue
```vue
<template>
    <div>
        <!-- 进行过滤 只包含前四位 -->
        <h2 >学校名称：{{name | mySlice}}</h2>
        <h2>学校地址：{{address}}</h2>
        <!-- 条用了vm与vc上的一个方法 -->
        <button @click="test">点我测试一个hello方法</button>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷atguigu',
                address:'北京昌平',
            }
        },
        methods:{
            test(){
                this.hello();
            }
        }
    }
</script>
```

Student.vue
```vue
<template>
    <div>
        <h2 >学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
        <!-- 会自动聚焦且将传入的值放到input框内 -->
        <input type="text" v-fbind:value="name">
    </div>
</template>
<script>
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
    }
</script>
```

### 3.6.2 总结

- 功能：用于增强Vue
- 本质：包含install方法的一个对象，install的第一个参数是Vue,第二个参数是插件使用者传递的数据。
- 定义插件：
    ```js
    对象.install = function(Vue,options){
        // 1.添加全局过滤器
        Vue.filter(...)

        // 2.添加全局指令
        Vue.directive(...)

        // 3.配置全局混入(合)
        Vue.mixin(...)

        //4.提娜佳实例方法
        Vue.prototype.$myNethod = function(){...}
        Vue.prototype.$myProperty = xxxx
    }
    ```
- 使用插件
    - Vue.use()


## 3.7 样式使用（scoped与lang）

### 3.7.1 scoped

问题？写多个模板 会导致样式重复

vue官方提供了scoped 属性


School.vue

```vue
<template>
    <div class="demo">
        <h2  class="title">学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷atguigu',
                address:'北京昌平',
            }
        },
    }
</script>
<style scoped>
    .demo{
        background-color: skyblue;
    }
</style>
```

Student.vue
```vue
<template>
    <div class="demo">
        <h2  class="title">学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
     
    </div>
</template>

<script>
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
    }
</script>
<style scoped >
    .demo{
        background-color: orange;
    }
</style>
```

在App.vue反而不应该使用scoped，其内有多个组件，样式直接作用于所有组件

App.vue
```vue
<template>
    <div>
        <School></School>
        <hr>
        <Student/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
}
</script>
<style>
    .title{
        color: red;
    }
</style>
```

原理：

![](/framework/vue/vue2/022.png)


### 3.7.2 lang属性
- 默认为lang='css' 可以写lang='less' /lang='scss'
- 使用前需要按照对应的插件 
    ```sh
    npm i less-loader@7
    ```


Student.vue

```vue
<template>
    <div class="demo">
        <h2  class="title">学生姓名：{{name}}</h2>
        <h2 class="atguigu">学生性别：{{sex}}</h2>
    </div>
</template>

<script>
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
    }
</script>
<style scoped lang="less">
    .demo{
        background-color: orange;
        .atguigu{
            font-size: 40px;
        }
    }
</style>
```

展示信息

![](/framework/vue/vue2/023.png)


## 3.8 TodoList案例


### 3.8.1 项目结构

![](/framework/vue/vue2/024.png)

### 3.8.2 代码

App.vue
```vue
<template>
   <div id="root">
  <div class="todo-container">
    <div class="todo-wrap">
        <!-- 传入了一个函数 -->
        <MyHeader :addTodo="addTodo"/>
        <MyList :todos="todos" :checkTodo="checkTodo" :deleteTodo="deleteTodo"/>
        <MyFooter :todos="todos" :checkAlltodo="checkAlltodo" :clearAllTodo="clearAllTodo"/>
    </div>
  </div>
</div>
</template>
<script>
import MyHeader from './components/MyHeader'
import MyList from './components/MyList'
import MyFooter from './components/MyFooter'
export default {
    name:'App',
    components:{MyHeader,MyList,MyFooter},
    data(){
        return {
            todos:[
                {id:'001',title:'抽烟',done:true},
                {id:'002',title:'喝酒',done:false},
                {id:'003',title:'开车',done:true},
            ]
        }
    },
    methods:{
        // 添加一个todo
        addTodo(todoObj){
           this.todos.unshift(todoObj)
        },
        //勾选or取消勾选一个todo
        checkTodo(id){
            this.todos.forEach((todo)=>{
                if(todo.id === id) todo.done = !todo.done
            })
        },
        // 删除一个todo
        deleteTodo(id){
            // this.todos = this.todos.filter((todo) => {
            //     return todo.id != id
            // })
            // 精简版
            this.todos = this.todos.filter(todo => todo.id != id)
        },
        // 全选 or 取消全选
        checkAlltodo(done){
            this.todos.forEach((todo)=>{
                todo.done = done;
            })
        },
        // 清除所有已完成的todo
        clearAllTodo(){
            this.todos =  this.todos.filter(todo =>{
                return !todo.done
            })
            console.log(this.todos);
            
        },
    }
}
</script>
<style>
/*base*/
body {
  background: #fff;
}
.btn {
  display: inline-block;
  padding: 4px 12px;
  margin-bottom: 0;
  font-size: 14px;
  line-height: 20px;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  border-radius: 4px;
}
.btn-danger {
  color: #fff;
  background-color: #da4f49;
  border: 1px solid #bd362f;
}
.btn-danger:hover {
  color: #fff;
  background-color: #bd362f;
}
.btn:focus {
  outline: none;
}
.todo-container {
  width: 600px;
  margin: 0 auto;
}
.todo-container .todo-wrap {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
}
</style>
```

MyFooter.vue
```vue
<template>
   <div class="todo-footer" v-show="total">
        <label>
         
            <!-- <input type="checkbox" :checked="isAll" @change="checkAll"/> -->
            <!-- 使用双向绑定 绑定的值不是data中的 而是计算属性（里面必须写上get与set） -->
            <input type="checkbox" v-model="isAll"/>
        </label>
        <span>
          <span>已完成 {{doneTotal}}</span> / 全部 {{total}}
        </span>
        <button class="btn btn-danger" @click="clearAll">清除已完成任务</button>
      </div>
</template>
<script>
export default {
    name:"MyFooter",
    props:["todos","checkAlltodo","clearAllTodo"],
    computed:{
        total(){
            return this.todos.length;
        },
        doneTotal(){
            // reduce执行length次数项
            // 传入两个值 第一个值是当前返回的值 第二个值是初始值
            // pre上一次的值 current是当前的对象
            // const x = this.todos.reduce((pre,current)=>{
            //     console.log('@',pre,current);
            //     return pre + (current.done ? 1 : 0)
            // },0)
            return this.todos.reduce((pre,todo)=>pre + (todo.done ? 1:0),0)
          
        },
        isAll:{
            get(){
                return this.doneTotal === this.total && this.total >0;
            },
            set(value){
                 this.checkAlltodo(value)
            }
           
        },
    },
    methods:{
        // checkAll(e){
        //     this.checkAlltodo(e.target.checked)
        // },
        clearAll(){
            this.clearAllTodo();
        }
    }
}
</script>
<style scoped>
/*footer*/
.todo-footer {
  height: 40px;
  line-height: 40px;
  padding-left: 6px;
  margin-top: 5px;
}
.todo-footer label {
  display: inline-block;
  margin-right: 20px;
  cursor: pointer;
}
.todo-footer label input {
  position: relative;
  top: -1px;
  vertical-align: middle;
  margin-right: 5px;
}
.todo-footer button {
  float: right;
  margin-top: 5px;
}
</style>
```

MyHeader.vue

```vue
<template>
    <div class="todo-header">
        <input type="text" placeholder="请输入你的任务名称，按回车键确认" @keyup.enter="add"/>
    </div>
</template>
<script>
import { nanoid } from "nanoid";
export default {
   
    name:'MyHeader',
    props:['addTodo'],
   
    methods:{
        // 将用户的输入包装成一个todo对象
        add(e){
            // 校验数据
            if(!e.target.value.trim()){
                return alert("请输入不能为空");
            }
            // 将用户的输入包装成一个todo对象
            const todoObj = {id:nanoid(),title:e.target.value,done:false}
            // 通知App组件去添加一个todo对象
            this.addTodo(todoObj)
            // 清空输入
            e.target.value = '';
        }
    }
}
</script>
<style scoped>
/*header*/
.todo-header input {
  width: 560px;
  height: 28px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 4px 7px;
}
.todo-header input:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);
}
</style>
```

MyItem.vue
```vue
<template>
   <li>
        <label>
        <!-- @click 与 @change 都可以 -->
        <input type="checkbox" :checked="todo.done" @change="handleCheck(todo.id)"/>
        
        <!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props -->
        <!-- <input type="checkbox" v-model="todo.done"/> -->
     
        <span>{{todo.title}}</span>
        </label>
        <button class="btn btn-danger" @click="handleDelete(todo.id)">删除</button>
    </li>
</template>
<script>
export default {
    name:'MyItem',
    //声明接收todo对象
    props:['todo',"checkTodo","deleteTodo"],
    methods:{
        // 勾选
        handleCheck(id){
           //通知App组件 将对应的todo对象的done取反
            this.checkTodo(id);
        },
        // 删除
        handleDelete(id){
            if(confirm('确定删除吗')){
                this.deleteTodo(id)
            }
        }
    }
}
</script>
<style scoped>

/*item*/
li {
  list-style: none;
  height: 36px;
  line-height: 36px;
  padding: 0 5px;
  border-bottom: 1px solid #ddd;
}
li label {
  float: left;
  cursor: pointer;
}
li label li input {
  vertical-align: middle;
  margin-right: 6px;
  position: relative;
  top: -1px;
}
li button {
  float: right;
  display: none;
  margin-top: 3px;
}
li:before {
  content: initial;
}
li:last-child {
  border-bottom: none;
}
li:hover{
    background-color: #ddd;
}
li:hover button{
    display: unset;
}
</style>
```

MyList.vue
```vue
<template>
    <ul class="todo-main">
        <MyItem 
            v-for="todoObj in todos" 
            :key="todoObj.id" 
            :todo="todoObj" 
            :checkTodo="checkTodo"
            :deleteTodo="deleteTodo"
        />
       
    </ul>
</template>
<script>
import MyItem from './MyItem.vue'
export default {
    name:'MyList',
    components:{
       MyItem, 
    },
    props:["todos","checkTodo","deleteTodo"],
}
</script>
<style scoped>
/*main*/
.todo-main {
  margin-left: 0px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0px;
}
.todo-empty {
  height: 40px;
  line-height: 40px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding-left: 5px;
  margin-top: 10px;
}
</style>
```

### 3.8.3 笔记总结
1. 组件化编码流程：
    - (1). 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。
    - (2). 实现动态组件：考虑好数据的存放位置，数据是一个组件再用，还是一些组件再用：
        - 1). 一个组件在用： 放在组件自身即可。
        - 2). 一些组件再用：放在他们共同的父组件上（`<span style="color:red">状态提升</span>`）
    - (3). 实现交互：从绑定事件开始。

2. props适用于：
    - (1). 父组件 ==> 子组件 通信
    - (2). 子组件 ==> 父组件 通信 （要求父先给子一个函数）
3. 使用v-model时要切记： v-model绑定的值不能是props传过来的值，因为props是不可以修改的！

4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。


## 3.9 浏览器本地存储

### 3.9.1 代码

1. localStorage.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>localStorage</title>
</head>
<body>
    <h2>localStorage</h2>
    <button onclick="saveData()">点我保存一个数据</button>
    <button onclick="readData()">点我读取一个数据</button>
    <button onclick="deleteData()">点我删除一个数据</button>
    <button onclick="deleteAllData()">点我清除一个数据</button>
    <script>
        function saveData(){
            let p = {name:'张三',age:18}
            //  window.localStorage 也可以
            localStorage.setItem('msg','hello!!!')
            localStorage.setItem('msg2',666)
            localStorage.setItem('peson',JSON.stringify(p))
        }
        function readData(){
            console.log( localStorage.getItem('msg'));
            console.log( localStorage.getItem('msg2'));
            const result = localStorage.getItem('peson');
            console.log(JSON.parse(result) );
        }
        function deleteData(){
            localStorage.removeItem("msg2");
        }
        function deleteAllData(){
            localStorage.clear();
        }
      
    </script>
</body>
</html>
```

2. sessionStorage.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sessionStorage</title>
</head>
<body>
    <!-- sessionStorage浏览器关闭的时候 -->
    <h2>sessionStorage</h2>
    <button onclick="saveData()">点我保存一个数据</button>
    <button onclick="readData()">点我读取一个数据</button>
    <button onclick="deleteData()">点我删除一个数据</button>
    <button onclick="deleteAllData()">点我清除一个数据</button>
    <script>
        function saveData(){
            let p = {name:'张三',age:18}
            //  window.sessionStorage 也可以
            sessionStorage.setItem('msg','hello!!!')
            sessionStorage.setItem('msg2',666)
            sessionStorage.setItem('peson',JSON.stringify(p))
        }
        function readData(){
            console.log( sessionStorage.getItem('msg'));
            console.log( sessionStorage.getItem('msg2'));
            const result = sessionStorage.getItem('peson');
            console.log(JSON.parse(result) );
        }
        function deleteData(){
            sessionStorage.removeItem("msg2");
        }
        function deleteAllData(){
            sessionStorage.clear();
        }
      
    </script>
</body>
</html>
```


### 3.9.2 总结

1. 存储内容大小一半支持5M左右（不同浏览器可能还不一样）

2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。

3. 相关API:
    1. xxxxxStorage.setItem('key','value');
        - 该方法接收一个键作为参数，会把键值添加到存储中，如果键名存在，则更新其对应的值
    2. xxxxxStorage.getItem('key');
        - 该方法接收一个键名作为参数，返回对应的值。
    3. xxxxxStorage.removeItemS('key');
        - 该方法接受以恶键名作为参数，并把该键名从存储中删除。
    4. xxxxxStorage.clear()
        - 该方法会清空存储中的所有数据。

## 3.10 自定义事件(this.$emit())

### 3.10.1 代码

App.vue
```vue
<template>
    <div class="app">
        <h1>{{msg}},学生姓名是：{{studentName}}</h1>
        <!-- 通过父组件给子组件传递函数类型的props实现，子给父传递数据 -->
        <School :getSchoolName="getSchoolName"></School>
        <!-- 由于v-on在student这个组件标签上，
            所以说给student这个组件的实例对象vc身上绑定了一个事件，
            事件名叫atguigu，如果以后有人触发的这个事件，
            那么demo函数就会被调用 -->
        <!-- 通过父组件给子组件绑定一个自定义事件实现，子给父传递数据
            （第一种写法,使用@或v-on） -->
        <!-- <Student v-on:atguigu="getStudentName"/> -->
        <!-- 简写方式 -->
        <!-- <Student @atguigu="getStudentName"/> -->
         <!-- 触发一次 -->
         <!-- <Student @atguigu.once="getStudentName"/> -->
        <!-- 通过父组件给子组件绑定一个自定义事件实现，子给父传递数据 
            （第二种写法,使用ref）-->
        <Student ref="student" @click.native="show"/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
    data(){
        return {
            msg:'你好啊！',
            studentName:'',
        }
    },
    methods:{
        getSchoolName(name){
            console.log("App收到了学校名",name);
            
        },
        getStudentName(name,...args){
            console.log("App收到了学生名",name,args);  
            this.studentName = name;
        },
        show(){
            console.log('123');
        },
    },
    mounted(){
        // 绑定自定义事件
        //this.$refs.student.$on("atguigu",this.getStudentName)
        // 可以更灵活的触发 等待数据加载完成
        // setTimeout(() => {
        //       this.$refs.student.$on("atguigu",this.getStudentName)
        // }, 3000);
        // 只触发一次
        //this.$refs.student.$once("atguigu",this.getStudentName)
        // 其中this是student组件实例
        // this.$refs.student.$on("atguigu",function(name,...args){
        //     console.log("App收到了学生名",name,args);  
        //     this.studentName = name;  
        // })
        // 箭头函数向外部寻找
         this.$refs.student.$on("atguigu",(name,...args)=>{
            console.log("App收到了学生名",name,args);  
            this.studentName = name;  
        })
    }
}
</script>
<style>
    .app{
        background-color: gray;
        padding: 5px;
    }
</style>
```

School.vue
```vue
<template>
    <div class="school">
        <h2  class="title">学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
        <button @click="sendSchoolName">把学校名给App</button>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        props:["getSchoolName"],
        data(){
            return {
                name:'尚硅谷',
                address:'北京昌平',
            }
        },
        methods:{
            sendSchoolName(){
                this.getSchoolName(this.name);
            }
        }
    }
</script>
<style scoped>
    .school{
        background-color: skyblue;
        padding: 5px;
    }
</style>
```

Student.vue
```vue
<template>
    <div class="student">
        <h2>学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
        <h2>当前求和为：{{number}}</h2>
        <button @click="add">点我number++</button>
        <button @click="sendStudentName" @demo="m1">把学生名给App</button>
        <button @click="unbind">解绑atguigu事件</button>
        <button @click="death">销毁当前Student组件的实例</button>
    </div>
</template>

<script>
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
                number:0,
            }
        },
        methods:{
            add(){
                console.log("add回调被调用了");
                
                this.number++;
            },
            sendStudentName(){
                this.$emit('atguigu',this.name)
                // 触发Student组件实例身上的atguigu
                // this.$emit('atguigu',this.name,666,888,900)
                // this.$emit('demo')
            },
            unbind(){
                // 解绑一个自定义事件
                this.$off("atguigu");
                // 解绑多个自定义事件
                // this.$off("atguigu","demo");
                // 解绑所有的自定义事件
                // this.$off() ;
            },
            m1(){
                console.log("demo触发了");
                
            },
            death(){
                // 销毁了当前Student组件的实例，销毁后所有Student实例的自定义事件全部不奏效。
                // console.log(this);
                
                this.$destroy()
            }
        }
    }
</script>
<style scoped lang="less">
    .student{
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    }
</style>
```

### 3.10.2 总结
1. 一种组件间通信的方式，适用于： 子组件 ===> 父组件

2. 使用场景： A是父组件，B是子组件，B向给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）
    
3. 帮顶顶自定义事件
    1. 第一种方式,在父组件中`<Demo @atguigu="test"/> `或 `<Demo v-on:atguigu="test"/>`
    2. 第二种方式，在父组件中
        ```vue
        <Demo ref = "demo"/>
        ...
        mounted(){
            this.$refs.xxx.$on("atguigu",this.test)
        }
        ```
     3. 若想让自定义事件只触发一次，可以使用once修饰符（第一种），或$once方法方法（第二种）

4. 触发自定义事件： 
    - 单个数据：this.$emit('atguigu',数据)
    - 多个数据：this.$emit('atguigu',数据1，数据2)
5. 解绑自定义事件 
    - 解绑一个事件：this.$off('atguigu')
    - 解绑多个事件：this.$off('atguigu')
    - 解绑所有事件：this.$off()
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符。
    - 如：`<Demo @click.native="test"/>`
7. 注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么使用箭头函数，否则this指向会出问题。


## 3.11 全局事件总线$bus
### 3.11.1 代码

main.js
```js
import Vue from 'vue'
import App from './App.vue'
Vue.config.productionTip = false
// 创建一个vc实例模板  组件实例对象 全局进行应用
// const demo = Vue.extend({})
// const d = new demo();
// Vue.prototype.x = d

//创建Vue实例对象 --vm
new Vue({
    el:'#app',
    render: h => h(App),
    beforeCreate(){
        Vue.prototype.$bus = this;  //安装全局事件总线
    }
})
```

App.vue
```vue
<template>
    <div class="app">
        <h1>{{msg}}</h1>
        <School/>
        <Student/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
    data(){
        return {
            msg:'你好啊！',
        }
    },
   
}
</script>
<style>
    .app{
        background-color: gray;
        padding: 5px;
    }
</style>
```

School.vue
```vue
<template>
    <div class="school">
        <h2  class="title">学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
    </div>
</template>

<script>
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷',
                address:'北京昌平',
            }
        },
        mounted(){
            // 开始绑定hello事件
            this.$bus.$on('hello',(data)=>{
                console.log("我是School组件，收到了数据",data);
            })
        },
        beforeDestroy(){
            this.$bus.$on('hello');
        }
      
    }
</script>
<style scoped>
    .school{
        background-color: skyblue;
        padding: 5px;
    }
</style>
```

Student.vue
```vue
<template>
    <div class="student">
        <h2>学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
        <button @click="sendStudentName">把学生名给School组件</button>
    </div>
</template>

<script>
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
        mounted(){
            
        },
        methods:{
            // 触发hello绑定事件
            sendStudentName(){
                this.$bus.$emit('hello',666);
            }
        }
    }
</script>
<style scoped lang="less">
    .student{
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    }
</style>
```

### 3.11.2 总结

1. 一种组件间的通信方式，适用于任意组件通信

2. 安装全局事件总线：
    ```js
    new Vue({
        ...
        beforeCreated(){
            Vue.prototype.$bus = this //安装事件总线，￥bus就是当前应用的vm
        }
        ...
    })
    ```
3. 使用事件总线
    1. 接受数据：A组件想接受数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。
        ```js
        methods(){
            demo(data){......}
        }
        ......
        mounted(){
            this.$bus.$on("xxx",this.demo)
        }
        ```
    2. 提供数据：
        ```js
        this.$bus.$emit('xxx',数据)
        ```
4. 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。

## 3.12 消息订阅与发布

### 3.12.1 代码

App.vue
```vue
<template>
    <div class="app">
        <h1>{{msg}}</h1>
        <School/>
        <Student/>
    </div>
</template>
<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:'App',
    components:{School,Student},
    data(){
        return {
            msg:'你好啊！',
        }
    },
   
}
</script>
<style>
    .app{
        background-color: gray;
        padding: 5px;
    }
</style>
```

School.vue
```vue
<template>
    <div class="school">
        <h2  class="title">学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
    </div>
</template>
<script>
    import pubsub from 'pubsub-js'
    export default {
        name: 'School', 
        data(){
            return {
                name:'尚硅谷',
                address:'北京昌平',
            }
        },
        mounted(){
            // 第一个参数 消息名  第二个参数 数据
            // 非箭头函数收不到this 因为引用的第三方库
            this.pubId = pubsub.subscribe('hello',(msgName,data) =>{
                console.log(this);
                console.log('有人发布了hello消息，hello消息的问题执行了',msgName,data);
            })
        },
        beforeDestroy(){
            this.$bus.$on('hello');
            //取消订阅
            pubsub.unsubscribe(this.pubId);
        }
      
    }
</script>
<style scoped>
    .school{
        background-color: skyblue;
        padding: 5px;
    }
</style>
```

Student.vue
```vue
<template>
    <div class="student">
        <h2>学生姓名：{{name}}</h2>
        <h2>学生性别：{{sex}}</h2>
        <button @click="sendStudentName">把学生名给School组件</button>
    </div>
</template>
<script>
    import pubsub from 'pubsub-js'
    export default {
        name: 'Student', 
        data(){
            return {
                name:'张三',
                sex: '男',
            }
        },
        mounted(){
            
        },
        methods:{
            // 消息发布
            sendStudentName(){
                pubsub.publish('hello',666)
            }
        }
    }
</script>
<style scoped lang="less">
    .student{
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    }
</style>
```

### 3.12.2 使用步骤
1. 安装pubsub:
    ```sh
    npm i pubsub-js
    ```
2. 引入： 
    ```js
    import pubsub from 'pubsub-js'
    ```
3. 接受数据：A组件想接受数据，则在A组件中订阅消息，订阅的回调留在A组件自身。
    ```js
    methods(){
        demo(data){......}
    }
    ......
    mounted(){
        this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
    }
    ```
4. 提供数据 
    ```js
    pubsub.publish('xxx',数据)
    ```
5. 最好在beforeDestroy钩子中，用pubsub.unsubscribe(pid)去取消订阅。

## 3.13 $nextTick

### 3.13.1 代码
```js
// DOM节点执行完毕之后 再执行
this.$nextTick(function(){
    this.$refs.inputTitle.focus();
})
```

### 3.13.2 总结

1. 语法：this.$nextTick(回调函数)
2. 作用：在下一次DOM更新结束后执行其指定的回调
3. 什么时候用： 当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行


## 3.14 Vue封装的过渡与动画


### 3.14.1 代码

1. 动画

```vue
<template>
    <div>
        <button @click="isShow = !isShow">显示/隐藏</button>
         <!-- 直接使用css动画 -->
        <!-- <h1 v-show="isShow" class="come">你好啊！</h1> -->
        <!-- 没有名字使用v-enter-active与v-leave-active  -->
        <!-- <transition>
             <h1 v-show="isShow" >你好啊！</h1>
        </transition> -->
        <!-- 有名字使用hello-enter-active与hello-leave-active  -->
        <!-- :appear="true" 直接执行动画 -->
        <transition class="hello" appear>
             <h1 v-show="isShow" >你好啊！</h1>
        </transition>
      
    </div>
</template>
<script>
export default {
    name:'test',
    data(){
        return{
            isShow:true,
        }
    }
}
</script>
<style>
    h1{
        background-color: orange;
    }
    /* vue设定动画效果 */
    .v-enter-active{
         animation: atguigu 1s;
    }
    .v-leave-active{
         animation: atguigu 1s reverse;
    }
    /* 起名后 */
    .hello-enter-active{
         animation: atguigu 0.5s linear;
    }
    .hello-leave-active{
         animation: atguigu 0.5s linear reverse;
    }
    

    .come{
        animation: atguigu 1s;
    }
    /* reverse 是反转 */
    .go{
        animation: atguigu 1s reverse;
    }

    @keyframes atguigu{
        from{
            transform: translateX(-100%);
        }
        to{
             transform: translateX(0px);
        }
    }
</style>
```

### 3.14.2 过渡

```vue
<template>
    <div>
        <button @click="isShow = !isShow">显示/隐藏</button>
       
       <!-- 单个元素 -->
        <transition class="hello" appear>
             <h1 v-show="isShow" >你好啊！</h1>
        </transition>
        <!-- 多个元素 -->
        <transition-group class="hello" appear>
             <h1 v-show="isShow"  key="1">你好啊！</h1>
             <h1 v-show="!isShow" key="2">尚硅谷</h1>
        </transition-group>
    </div>
</template>
<script>
export default {
    name:'test',
    data(){
        return{
            isShow:true,
        }
    }
}
</script>
<style>
    h1{
        background-color: orange;
       
    }
    /* 进入的起点  离开的终点*/
    .hello-enter,.hello-leave-to{
         transform: translate(-100%);
    }
    .hello-enter-active,.hello-leave-active{
        transition: 0.5s linear;
    }
      /* 进入的终点 离开的起点*/
    .hello-hello-to,.hello-leave{
          transform: translate(0);
    }
   
</style>
```

### 3.14.3 外部动画

外部动画官网https://animate.style/

引入包

```sh
npm install animate.css --save
```

```vue
<template>
    <div>
        <button @click="isShow = !isShow">显示/隐藏</button>
       
       <!-- 单个元素 -->
        <transition 
            appear
            class="animate__animated animate__bounce"
            enter-active-class="animate__swing"
            leave-active-class="animate__backInUp"
        >
             <h1 v-show="isShow" >你好啊！</h1>
        </transition>
    </div>
</template>
<script>
import 'animate.css'
export default {
    name:'test',
    data(){
        return{
            isShow:true,
        }
    }
}
</script>
<style>
    h1{
        background-color: orange;
    }
</style>
```


### 3.14.4 总结
1. 作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。
2. 图示（官方给的）

![](/framework/vue/vue2/025.png)

3. 写法
    1. 准备好样式：
        - 元素进入的样式：
            - v-enter：进入的起点
            - v-enter-active：进入过程中
            - v-enter-to：进入的终点
        - 元素离开的样式：
            - v-leave：离开的起点
            - v-leave-active：离开过程中
            - v-leave-to：离开的终点
    2. 使用`<transition>`包裹要过渡的元素，并配置name属性：
        ```vue
        <transition class="hello" appear>
                <h1 v-show="isShow" >你好啊！</h1>
        </transition>
        ```
    3. 备注：若有多个元素需要过渡，则需要使用：`<transition-group>`，且每个元素都要指定key值。


## 3.15 webpack配置

### 3.15.1 概述

1. 目录中存在 tsconfig.json 文件表明该目录是 TypeScript 项目的根目录。该 tsconfig.json 文件指定编译项目所需的根文件和编译器选项。

2. JavaScript 项目可以使用 jsconfig.json 文件来代替，它的作用几乎相同，但默认启用了一些与 JavaScript 相关的编译器标志

### 3.15.2 解释配置文件

jsconfig.json 源于 tsconfig.json ，是 TypeScript 的配置文件
jsconfig.json 相当于 tsconfig.json 的 “allowJs” 属性设置为 true

### 3.15.3 使用步骤

1. 配置说明

代码如下（示例）：

```json
{
  "compilerOptions": {
      "baseUrl": ".",
      "paths": {
          // 解决项目中使用@作为路径别名，导致vscode无法跳转文件的问题
          "@/*": ["src/*"]
      },
      // 解决prettier对于装饰器语法的警告
      "experimentalDecorators": true,
      // 解决.jsx文件无法快速跳转的问题
      "jsx": "preserve"
  },
  //提高 IDE 性能
  "exclude": ["node_modules", "dist", "build"]
}
```

在这里特别说明一下 exclude 为什么 提高 编译器 性能 ？

如果开发的项目根目录下没有 jsconfig.json，在默认情况下，像 VS Code， 默认只会把 node_modules 文件夹排除掉。

只要有可能，您应该使用不属于项目源代码的 JavaScript 文件排除文件夹。

意思就是与开发无关的文件可以让 IDE 全部在编译时排除掉，像上面的配置中就排除了，构建过程依赖文件（node_modules）和生成的文件(dist 目录) 排除这些文件，可以提高 vscode 的性能。


1. 高级配置选项

```json
{
  // 编译选项
  "compilerOptions": {
    // 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码
    // 命令行： tsc --target es5 11-测试TS配置文件.ts
    "target": "es5",
    // 指定要包含在编译中的 library
    "lib": ["dom", "dom.iterable", "esnext"],
    // 允许 ts 编译器编译 js 文件
    "allowJs": true,
    // 跳过类型声明文件的类型检查
    "skipLibCheck": true,
    // es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异
    "esModuleInterop": true,
    // 允许通过 import x from 'y' 即使模块没有显式指定 default 导出
    "allowSyntheticDefaultImports": true,
    // 开启严格模式
    "strict": true,
    // 对文件名称强制区分大小写
    "forceConsistentCasingInFileNames": true,
    // 为 switch 语句启用错误报告
    "noFallthroughCasesInSwitch": true,
    // 生成代码的模块化标准
    "module": "esnext",
    // 模块解析（查找）策略
    "moduleResolution": "node",
    // 允许导入扩展名为.json的模块
    "resolveJsonModule": true,
    // 是否将没有 import/export 的文件视为旧（全局而非模块化）脚本文件
    "isolatedModules": true,
    // 编译时不生成任何文件（只进行类型检查）
    "noEmit": true,
    // 指定将 JSX 编译成什么形式
    "jsx": "react-jsx"
  },
  // 指定允许 ts 处理的目录
  "include": ["src"]
}
```

2. 大部分使用默认配置

```json
{
  // 编译选项
  "compilerOptions": {
    // 编译ES5
    "target": "es5",
    // 指定模块系统
    "module": "esnext",
    // 模块基础目录
    "baseUrl": "./",
    // 解析导入模块
    "moduleResolution": "node",
    // 相对于模块路径
    "paths": {
     "@/*": ["src/*"]
    },
    // 默认库
    "lib": ["esnext", "dom", "dom.iterable", "srcipthost"]
  }
}
```