# API技术核心原理

## 1. API 是啥

API（Application Programming Interface，应用程序编程接口）是一组预先定义好的​​规则、协议和工具​​，它允许不同的软件应用程序之间相互通信和交换数据。

- ​​Application（应用）​​：指任何有特定功能的软件。

- ​​​Programming（编程）​​：开发人员需要使用它来编写代码。

- ​​​Interface（接口）​​：它是两个系统之间相互交互的“契约”或连接点。

## 2. 传统风格接口

通常指的是 ​​RPC (Remote Procedure Call, 远程过程调用)​​ 或 ​​SOAP (Simple Object Access Protocol)​​ 风格的接口。


1. 核心思想​​：

    像​​调用本地函数/方法​​一样调用远程服务。接口设计是​​动作导向 (Action-Oriented)​​ 的。

2. 特点​​：

    - ​​URL 设计​​：URL 路径通常包含​​动词​​，表示要执行的操作。

        例如：/getUser, /createProduct, /deleteOrder
    
    - 操作方式​​：通常只使用 ​​GET​​ 和 ​​POST​​ 这两种 HTTP 方法。真正的操作意图（是获取、创建还是删除）隐藏在 URL 或请求体里。
    
    - 状态管理​​：可能会使用 ​​Session​​ 或 ​​Cookie​​ 来维护用户会话状态，服务器需要记住客户端的状态（是“有状态的”）。
    
    - ​数据格式​​：SOAP 严格使用 XML，格式非常重，规范复杂。

3. 举个例子：一个传统的用户管理接口​​

    - GET /getUser?id=123（获取用户）
    - POST /createUser（在请求体中传递用户JSON数据来创建用户）
    - POST /updateUser（更新用户）
    - GET /deleteUser?id=123（删除用户）

## 3. REST 与 Restful

1. rest 与 restful 区别

    首先，​​REST​​ 和 ​​RESTful​​ 在绝大多数语境下可以互换使用，细微区别在于：

    - ​​REST​​：是一种架构风格（Architectural Style），由 Roy Fielding 博士在其论文中提出的一套​​设计原则和约束​​的集合。它是一种理论。

    - RESTful​​：意思是“符合 REST 原则的”。我们说一个接口是 ​​RESTful​​ 的，是指它的实现遵守了 REST 的准则。它是一种实践。

2. RESTful 的核心思想与约束

    其核心思想是​​资源导向 (Resource-Oriented)​​。将所有事物视为网络上的​​资源​​，并使用统一的接口（HTTP方法）来操作它们。

    ​​核心原则包括：​​

    1. ​资源 (Resource)​​：一切皆资源。用户、订单、商品都是资源。每个资源都有一个唯一的标识符（URI）。

        URI 示例：/users/123（ID为123的用户资源）

    2. 统一接口 (Uniform Interface)​​：这是 REST 最重要的特征，主要体现为：

        - 使用标准的 HTTP 方法​​ 来对资源执行 ​​CRUD​​ (Create, Read, Update, Delete) 操作：

            - ​​GET​​： ​​获取/查询​​ 资源（Safe & Idempotent 安全且幂等）
            - POST​​： ​​创建​​ 新资源（Non-Idempotent 非幂等）
            - ​PUT​​： ​​完整更新​​ 资源（Idempotent 幂等）
            - PATCH​​： ​​部分更新​​ 资源（Non-Idempotent 或 Idempotent）
            - DELETE​​： ​​删除​​ 资源（Idempotent 幂等）
        - 同一个资源地址（URI），通过不同的方法来实现不同的功能。

    3. ​无状态 (Stateless)​​：服务器不会保存客户端的任何会话状态。每次请求都必须包含处理该请求所需的所有信息（如认证令牌、参数等）。会话状态完全由客户端负责维护。

    4. 可缓存 (Cachable)​​：响应应该被明确标记为可缓存或不可缓存，以提高网络效率。
    
    
3. ​​举个例子：一个 RESTful 的用户管理接口​​

    - GET /users/123-> ​​获取​​ ID为123的用户
    - POST /users-> ​​创建​​ 一个新用户（请求体中包含用户信息）
    - PUT /users/123-> ​​完整更新​​ ID为123的用户信息（请求体中包含完整的用户信息）
    - PATCH /users/123-> ​​部分更新​​ ID为123的用户信息（如只更新邮箱）
    - DELETE /users/123-> ​​删除​​ ID为123的用户

## 4. GraphQL

GraphQL 是一种用于 API 的查询语言和运行时环境。它允许客户端精确地指定它需要什么数据，服务器则会返回 对应数据，不多也不少。​

一个完整的 GraphQL 接口由以下几个关键部分构成：

1. ​​Schema（模式）​​：这是 GraphQL 服务的​​核心契约和蓝图​​。它使用强类型系统定义了：
    
    - ​对象类型 (Object Types)​​：例如 User、Post，描述了数据的形状。

    - 查询类型 (Query Type)​​：定义了所有客户端可以执行的查询操作（根字段）。

    - 变更类型 (Mutation Type)​​：定义了所有客户端可以执行的变更操作（根字段）。

    - 订阅类型 (Subscription Type)​​：定义了所有可以订阅的事件。

    它就像是服务器提供给客户端的​​一份详细菜单​​，写明了可以点什么菜（查询什么），以及每道菜里有什么配料（返回哪些字段）。

2. 解析器 (Resolvers)​​：Schema 只定义了“是什么”，而​​解析器则定义了“怎么做”​​。每个字段（无论是根字段还是子字段）都有一个对应的解析器函数。当客户端请求某个字段时，服务器就会调用这个函数来获取数据。解析器是连接 GraphQL 引擎和你底层数据源（数据库、微服务、REST API 等）的桥梁。

3. ​​类型系统 (Type System)​​：GraphQL 是强类型的。每个字段都有明确的类型，如 String, Int, Boolean，或是自定义类型如 User。这确保了查询的合法性，并在执行前就能提供强大的​​错误检查和编辑器智能提示​​。

## 5. grpc

好的，我们来深入探讨一下 ​​gRPC 接口​​。这是一个非常核心的现代后端通信技术。



1. 契约优先与 Protocol Buffers (Protobuf)
    
    这是 gRPC 的基石。你不是直接写代码，而是先在一个 ​​.proto文件​​中严格定义​​服务接口​​和​​数据结构​​。

    - ​​service​​：定义一个服务，里面包含多个可远程调用的方法（函数）。
    - message​​：定义结构化数据，类似于 JSON 对象或编程语言中的类/结构体。
    - rpc​​：在服务内部定义具体的远程方法。

    **示例 (helloworld.proto)**：​​

    ```proto
    // 指定语法版本和包名
    syntax = "proto3";
    package helloworld;

    // 定义请求和响应消息的结构
    message HelloRequest {
        string name = 1; // 字段编号，非值
    }

    message HelloReply {
        string message = 1;
    }

    // 定义服务
    service Greeter {
        // 定义一个RPC方法，接收HelloRequest，返回HelloReply
        rpc SayHello (HelloRequest) returns (HelloReply) {}
    }
    ```
2. 强大的代码生成
    
    .proto文件是语言无关的。你可以使用 ​​Protobuf 编译器 (protoc)​​ 配合不同语言的插件（如 grpc-go，grpc-java），​​自动生成​​客户端存根（Stub）和服务端骨架（Skeleton）代码。

    - 服务端​​：你只需要继承生成的服务端基类，并实现具体的业务逻辑（如 SayHello方法）。
    - 客户端​​：你只需要像调用本地对象一样调用生成的客户端对象的方法。

    这消除了手动编写样板代码（如网络传输、序列化/反序列化）的需要，并保证了接口的一致性。

3. 基于 HTTP/2

    gRPC 不像 REST 那样使用 HTTP/1.1，而是使用 ​​HTTP/2​​ 作为底层传输协议。这带来了巨大优势：

    - 二进制协议​​：头部和载荷都采用二进制格式，更紧凑、高效。

    - 多路复用 (Multiplexing)​​：多个请求可以在同一个 TCP 连接上同时进行，避免了 HTTP/1.1 的队头阻塞问题，极大减少了连接开销。
    
    - 服务器推送 (Server Push)​​：服务器可以主动向客户端推送数据（虽然 gRPC 自身实现方式不同）。

    - 流式处理​​：天然支持四种流式模式。

4. 四种通信模式

    gRPC 接口支持灵活的交互模式，远超简单的请求-响应：

    - 一元 RPC (Unary RPC)​​：最普通的模式，客户端发送一个请求，服务器返回一个响应。

        ```rpc
        rpc SayHello (HelloRequest) returns (HelloReply) {}
        ```
        
    - ​​服务器流式 RPC (Server streaming RPC)​​：客户端发送一个请求，服务器返回一个流式的响应序列（例如，发送股票价格更新）。

        ```rpc
        rpc LotsOfReplies (HelloRequest) returns (stream HelloReply) {}
        ```
    
    - 客户端流式 RPC (Client streaming RPC)​​：客户端发送一个流式的请求序列，服务器返回一个单一的响应（例如，客户端上传一系列测量读数，服务器返回一个汇总报告）。

        ```rpc
        rpc LotsOfGreetings (stream HelloRequest) returns (HelloReply) {}
        ```
    - ​​双向流式 RPC (Bidirectional streaming RPC)​​：双方都使用一个独立的流来发送一系列消息（例如，一个实时聊天应用）。

        ```rpc
        rpc BidiHello (stream HelloRequest) returns (stream HelloReply) {}
        ```
## 6. trpc


1. 与 gRPC 的“契约优先”或 REST 的“文档优先”不同，tRPC 的核心哲学是 ​​“类型即契约”​​。

    - 传统方式​​：你需要额外维护一份接口契约（如 .proto文件或 OpenAPI/Swagger 文档），然后根据这份契约分别编写和调试前后端代码。契约和代码是分离的，容易不同步。

    - tRPC 方式​​：你的​​后端 TypeScript 代码本身就是契约​​。你编写一个普通的 TypeScript 函数，tRPC 通过其类型系统自动推断出这个函数的输入和输出类型，并让前端能安全地调用它。​​契约和代码是一体的​​，从根本上杜绝了前后端接口不一致的问题。



2. 定义路由器 (Router) 和过程 (Procedure)


    在后端，你不需要定义 .proto文件，而是直接使用 tRPC 的辅助函数来创建路由器和 API 端点（在 tRPC 中称为 “Procedures”）。

    **示例：后端​** (server.ts)​

    ```js
    // 1. 初始化 tRPC
    import { initTRPC } from '@trpc/server';
    import { z } from 'zod'; // 常用作输入验证库

    const t = initTRPC.create(); // 创建 TRPC 实例

    // 2. 创建路由器并定义 API 端点（Procedures）
    export const appRouter = t.router({
    // 定义一个名为 `getUser` 的查询 (Query)
    getUser: t.procedure
        // 使用 Zod 定义并验证输入
        .input(z.object({ id: z.string() }))
        // 定义查询实现，返回值类型会被自动推断
        .query(async (opts) => {
        const { input } = opts; // input 的类型为 { id: string }
        // 这里可以是数据库查询或其他逻辑
        const user = await db.user.findUnique({ where: { id: input.id } });
        return user; // TypeScript 知道 user 的类型，并会将其作为响应类型
        }),

    // 定义一个名为 `createUser` 的变更 (Mutation)
    createUser: t.procedure
        .input(z.object({ name: z.string().min(1) }))
        .mutation(async (opts) => {
        const { input } = opts;
        const newUser = await db.user.create({ data: { name: input.name } });
        return newUser;
        }),
    });

    // 导出路由器的类型，前端将直接使用它
    export type AppRouter = typeof appRouter;
    ```

3. 集成到 Web 框架

    tRPC 本身不是服务器，它需要与一个 Web 框架（如 Express、Next.js、Nuxt 等）适配。


    **示例：在 Next.js API 路由中** (pages/api/trpc/[trpc].ts)​​

    ```js
    import { createNextApiHandler } from '@trpc/server/adapters/next';
    import { appRouter } from '../../../server/router';

    // 将 tRPC 路由器挂载到 `/api/trpc` 路径下
    export default createNextApiHandler({
        router: appRouter,
    });
    ```

4. 在前端调用：魔法般的体验

    这是 tRPC 最令人惊艳的部分。前端直接导入​​后端的路由器类型​​，创建一个类型安全的客户端。

    **示例：前端** (frontend.tsx)​​

    ```tsx
    // 1. 导入来自后端的类型定义！
    import type { AppRouter } from '../server';
    import { createTRPCProxyClient, httpLink } from '@trpc/client';

    // 2. 创建客户端，并传入后端路由器的类型作为泛型参数
    const trpc = createTRPCProxyClient<AppRouter>({
        links: [httpLink({ url: '/api/trpc' })],
    });

    // 3. 像调用本地函数一样进行调用，享受完整的类型安全和自动补全！
    async function main() {
    // ❌ 错误：TypeScript 会报错，因为 input 需要 { id: string }
    // const user = await trpc.getUser.query({ name: "Alice" });

    // ✅ 正确：完全的类型安全
    const user = await trpc.getUser.query({ id: '1' });
    // 现在 `user` 的类型就是后端 `getUser` 函数返回的 Promise 的解析值类型
    console.log(user?.name); // 自动补全！

    // 调用变更 (mutation) 同样简单
    const newUser = await trpc.createUser.mutate({ name: 'Alice' });
        console.log(newUser.name);
    }
    ```