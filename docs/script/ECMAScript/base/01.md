# 一、ES6

## 1.1 let声明变量

### 1.1.1 基本用法
ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

```js
{
    var x = 100;
    let y = 20;
}
console.log("在块级作用域中var定义的变量", x);
// 错误 y is not defined
// console.log('在块级作用域中let定义的变量',y);
```


上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。

for循环的计数器，就很合适使用let命令。

```js
// 进行回调或者点击事件无法使用var定义的for循环
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    };
}
a[6](); // 10

var a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    };
}
a[6](); // 6
```


另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```js
// 03循环体内部是一个单独的子作用域 互相不干扰
for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
}
// abc
// abc
// abc
```

### 1.1.2 不存在变量提升

var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。
为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

```js
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。

### 1.1.3 暂时性死区
只要作用域内存在 let、const，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。

```js
let a = 2;
function func() {
    console.log(a);        // 报错
    let a = 1;
}
func();

let a = 2;
function func() {
    console.log(a);        // 2
}
func();
```

即：只要作用域内出现了同名的 let 或 const，那么就会去找这个量（向前找），如果找不到也不会跳去外部找，只会直接报错！
只要我们遵守 “先声明后使用”，那么其实就基本不会遇到变量提升及暂时性死区问题。


### 1.1.4 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。

```js
// 使用var是允许重新声明的
function func() {
    var a = 10;
    var a = 20;
}
// 报错
function func() {
    var b = 10;
    let b = 20;  
}
// 报错
function func() {
    let c = 10;
    let c = 1;   
}
```

因此，不能在函数内部重新声明参数。

```js
function func(arg) {
    let arg;
}
func(); // 报错

function func(arg) {
    {
        let arg;
    }
}
func(); // 不报错
```

### 1.1.5 不与顶层对象挂钩
var声明的变量一直都可以通过window.变量名获取

```js
var myname = 'zhangsan'
console.log(window.myname); //zhangsan

let myage = 100
console.log(window.myage);  //undefined
```

## 1.2 const声明变量

### 1.2.1 基本用法
const声明一个只读的常量。一旦声明，常量的值就不能改变。

```js
const PI = 3.1415;

PI // 3.1415
PI = 3;

// TypeError: Assignment to constant variable.
```


上面代码表明改变常量的值会报错。

const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。

```js
const foo;
// SyntaxError: Missing initializer in const declaration
```

上面代码表示，对于const来说，只声明不赋值，就会报错。

const的作用域与let命令相同：只在声明所在的块级作用域内有效。

```js
if (true) {
    const MAX = 5;
}
MAX; // Uncaught ReferenceError: MAX is not defined
```

const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

```js
if (true) {
    console.log(MAX); // ReferenceError
    const MAX = 5;
}
```

上面代码在常量MAX声明之前就调用，结果报错。

const声明的常量，也与let一样不可重复声明。

```js
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
```

### 1.2.2 本质
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
下面是另一个例子。

```js
const a = [];

a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。

## 1.3 解构赋值

### 1.3.1 数组的解构赋值

#### 1.3.1.1 原理
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
以前，为变量赋值，只能直接指定值。

```js
let a = 1;
let b = 2;
let c = 3;
```

ES6 允许写成下面这样。

```js
let [a, b, c] = [1, 2, 3];
```

上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。

1. 模式（结构）匹配 [] = [1, 2, 3];
2. 索引值相同的完成赋值 const [a, b, c] = [1, 2, 3];
3. 举例

```js
const [a, [, , b], c] = [1, [2, 3, 4], 5];

console.log(a, b, c);    // 1 4 5
```

#### 1.3.1.2 数组解构赋值的默认值
1. 默认值的基本用法

```js
const [a, b] = [];
console.log(a, b);    // undefined undefined

// ---------------------------------------
const [a = 1, b = 2] = [];
console.log(a, b);    // 1 2
```

2. 默认值的生效条件
只有当一个数组成员严格等于 (===) undefined 时，对应的默认值才会生效。

```js    
const [a = 1, b = 2] = [3, 0];        // 3 0
const [a = 1, b = 2] = [3, null];    // 3 null
const [a = 1, b = 2] = [3];            // 3 2
```

3. 默认值表达式
如果默认值是表达式，默认值表达式是惰性求值的（即：当无需用到默认值时，表达式是不会求值的）

```js
const func = () => {
    return 24;
};

const [a = func()] = [1];    // 1
const [b = func()] = [];    // 24
```

#### 1.3.1.3 数组解构赋值的应用
1. arguments

```js
function func() {
    const [a, b] = arguments;
    console.log(a, b);    // 1 2
}

func(1, 2);
```

2. NodeList

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NodeList</title>
</head>
<body>
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <script>
        const [p1, p2, p3] = document.querySelectorAll('p');
        console.log(p1, p2, p3);
        /*
            <p>1</p>
            <p>2</p>
            <p>3</p>
        */
    </script>
</body>
</html>
```

3. 函数参数的解构赋值

```js
const array = [1, 1];
// const add = arr => arr[0] + arr[1];
const add = ([x = 0, y = 0]) => x + y;
console.log(add(array));    // 2
console.log(add([]));        // 0
```

4. 交换变量的值

```js

let x = 2, y = 1;

// 原来
let tmp = x;
x = y;
y = tmp;

// 现在
[x, y] = [y, x];
// 理解：[x, y] = [2, 1]
console.log(x, y);
// 1 2
```

5. 跳过某项值使用逗号隔开

在解构数组时，可以忽略不需要解构的值，可以使用逗号对解构的数组进行忽略操作，这样就不需要声明更多的变量去存值了：

```js    
var [a, , , b] = [10, 20, 30, 40];

console.log(a);   // 10
console.log(b);   // 40
```    


上面的例子中，在 a、b 中间用逗号隔开了两个值，这里怎么判断间隔几个值呢，可以看出逗号之间组成了多少间隔，就是间隔了多少个值。如果取值很少的情况下可以使用下标索引的方式来获取值。
    
6. 剩余参数中的使用


通常情况下，需要把剩余的数组项作为一个单独的数组，这个时候我们可以借助展开语法把剩下的数组中的值，作为一个单独的数组，如下：

```js    
var [a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a);     // 10
console.log(b);     // 20
console.log(rest);  // [30, 40, 50]
```

在 rest 的后面不能有 逗号 不然会报错，程序会认出你后面还有值。...rest 是剩余参数的解构，所以只能放在数组的最后，在它之后不能再有变量，否则则会报错。

#### 1.3.1.4 必须要分号的两种情况

1. 立即执行函数
```js

;(function () { })();
 (function () { })();
```

2. 使用数组解构的时候

```js
const arr = [1, 2, 3]
const str = 'pink';

[1, 2, 3].map(function (item) {
  console.log(item)
})

let a = 1
let b = 2
  ;[b, a] = [a, b]
console.log(a, b)
```

### 1.3.2 对象的解构赋值
#### 1.3.2.1 原理
对象的解构和数组基本类似，对象解构的变量是在 {} 中定义的。对象没有索引，但对象有更明确的键，通过键可以很方便地去对象中取值。在 ES6 之前直接使用键取值已经很方便了：

```js
var obj = { name: 'imooc', age: 7 };
var name = obj.name;  // imooc
var age = obj.age;    // 7
```

但是在 ES6 中通过解构的方式，更加简洁地对取值做了简化，不需要通过点操作增加额外的取值操作。

```js
var obj = { name: 'imooc', age: 7 };
var { name, age } = obj;  // name: imooc, age: 7
```

在 {} 直接声明 name 和 age 用逗号隔开即可得到目标对象上的值，完成声明赋值操作。
1. 模式（结构）匹配 {} = {};
2. 属性名相同的完成赋值 
```js
const {name, age} = {name: 'jerry', age: 18};
···

或者调换位置

···js
const {age, name} = {name: 'jerry', age: 18};
```

#### 1.3.2.2 对象解构赋值的默认值
1. 对象的属性值严格等于 undefined 时，对应的默认值才会生效。
2. 如果默认值是表达式，默认值表达式是惰性求值的。


对象的默认值和数组的默认值一样，只能通过严格相等运算符（===）来进行判断，只有当一个对象的属性值严格等于 undefined，默认值才会生效。

```js
var {a = 10, b = 5} = {a: 3};                 // a = 3, b = 5
var {a = 10, b = 5} = {a: 3, b: undefined};   // a = 3, b = 5
var {a = 10, b = 5} = {a: 3, b: null};        // a = 3, b = null
```


所以这里的第二项 b 的值是默认值，第三项的 null === undefined 的值为 false，所以 b 的值为 null。

#### 1.3.2.3 重命名属性

在对象解构出来的变量不是我们想要的变量命名，这时我们需要对它进行重命名。

```js
var {a:x = 8, b:y = 3} = {a: 2};
console.log(x); // 2
console.log(y); // 3
```

这里把 a 和 b 的变量名重新命名为 x 和 y。

#### 1.3.2.4 对象解构赋值的应用

1. 对象作为函数参数

```js
// 之前
const logPersonInfo = user => console.log(user.name, user.age);

logPersonInfo({name: 'jerry', age: 18});

// 之后
const logPersonInfo = ({age = 21, name = 'ZJR'}) => console.log(name,age);

logPersonInfo({name: 'jerry', age: 18});    // jerry 18

logPersonInfo({});    // ZJR 21
```

2. 复杂的嵌套（主要是缕清逻辑关系即可）

```js
const obj = {
    x: 1,
    y: [2, 3, 4],
    z: {
        a: 5,
        b: 6
    }
};

// ----------------------------------------------------
const {x, y, z} = obj;
console.log(x, y, z);    // 1 [ 2, 3, 4 ] { a: 5, b: 6 }

// ----------------------------------------------------
const {y: [, y2]} = obj;
console.log(y2);    // 3
console.log(y);        // 报错

// ----------------------------------------------------
const {y: y, y: [, y2]} = obj;
console.log(y2);    // 3
console.log(y);        // [ 2, 3, 4 ]

// ----------------------------------------------------
const {y, y: [, y2], z, z: {b}} = obj;
console.log(y2);    // 3
console.log(y);        // [ 2, 3, 4 ]
console.log(z);        // { a: 5, b: 6 }
console.log(b);        // 6
```

3. 剩余参数中的使用

在对象的解构中也可以使用剩余参数，对对象中没有解构的剩余属性做聚合操作，生成一个新的对象。

```js
var {a, c, ...rest} = {a: 1, b: 2, c: 3, d: 4}

console.log(a);     // 1
console.log(c);     // 3
console.log(rest);  // { b: 2, d: 4 }
```

对象中的 b、d 没有被解构，通过剩余参数语法把没有解构的对象属性聚合到一起形成新的对象。

#### 1.3.2.5 注意点

1. 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

```js
    // 错误的写法
    let x;
    {x} = {x: 1};
    // SyntaxError: syntax error
```

上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

```js
// 正确的写法
let x;
({x} = {x: 1});
```

上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。


2. 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。

```js
({} = [true, false]);
({} = 'abc');
({} = []);
```

上面的表达式虽然毫无意义，但是语法是合法的，可以执行。


3. 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```js
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。
    

### 1.3.3 字符串的解构赋值

既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。

```js
// 数组形式解构赋值
const [a, b, , , c] = 'hello';
console.log(a, b, c);    // h e o

// 对象形式解构赋值
const {0: a, 1: b, 4: o, length} = 'hello';
console.log(a, b, o, length);    // h e o 5
```

### 1.3.4 数值和布尔值的解构赋值

只能按照对象的形式来解构赋值。
（会先自动将等号右边的值转为对象）

```js
// 先来复习一下将数值和布尔值转化为对象
console.log(new Number(123));
console.log(new Boolean(true));

// 转化后的对象里没有任何的属性（没有 123 这个属性，也没有 true 这个属性）和方法，

// 所有的属性和方法都在它的继承 __proto__ 中，比如 toString 方法就是继承来的。

// 里面的值只能是默认值，继承的方法倒是可以取到


const {a = 1, toString} = 123;
console.log(a, toString);    // 1 [Function: toString]

// 里面的值只能是默认值，继承的方法倒是可以取到

const {b = 1, toString} = true;
console.log(b, toString);    // 1 [Function: toString]
```
### 1.3.5 undefined 和 null 没有解构赋值
由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。


## 1.4 模板字符串

JavaScript 模板字符串（template string）是一种字符串字面量，使用反引号（`）来标识。它可以包含普通字符以及特殊的占位符。
模板字符串中可以包含变量，其写法是在变量名前面加上${，后面跟上}。当模板字符串被执行时，这些变量会被相应的值替换。

### 1.4.1 基础案例

```js
const name = 'Alice';
const age = 25;
const greeting = `Hello, my name is ${name} and I am ${age} years old.`;
 
console.log(greeting);
// Hello, my name is Alice and I am 25 years old.
```

### 1.4.2 内嵌表达式

```js
const x = 10;
const y = 20;
const sum = `${x} + ${y} = ${x + y}`;
 
console.log(sum);
//10 + 20 = 30
```

### 1.4.3 多行输出

```js
const multiLine = `This is a
multi-line
string.`;
 
console.log(multiLine);

/* 
    This is a
    multi-line
    string.
*/
```


## 1.5 字符串扩展

### 1.5.1 包含判断

传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。

- includes()：返回布尔值，表示是否找到了参数字符串。
- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

```js
let myname = 'kerwin'
// 字符串中是否存在字符或字符串
console.log(myname.includes("erw"));
// 开始是否是字符或字符串
console.log(myname.startsWith("ke"));
// 结束是否是字符或字符串
console.log(myname.endsWith("n"));

// 带参数 includes与startsWith都是从0开始
// endsWith 是下标位置往前取查询
console.log(myname.includes("e",1));
console.log(myname.startsWith("e",1));
console.log(myname.endsWith("r",3));
```

### 1.5.2 字符串重复
repeat方法返回一个新字符串，表示将原字符串重复n次。

```js
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
```

参数如果是小数，会被取整。

```js
'na'.repeat(2.9) // "nana"
```

如果repeat的参数是负数或者Infinity，会报错。

```js
'na'.repeat(Infinity)
// RangeError
'na'.repeat(-1)
// RangeError
```

但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。

```js
'na'.repeat(-0.9) // ""
```

参数NaN等同于 0。

```js
'na'.repeat(NaN) // ""
```

如果repeat的参数是字符串，则会先转换成数字。

```js
'na'.repeat('na') // ""
'na'.repeat('3') // "nanana"
```

## 1.6 数值扩展

### 1.6.1 二进制、八进制、十六进制的表示方法
- 二进制‌：使用0b或0B前缀表示。例如，0b10等于2。
- 八进制‌：使用0o或0O前缀表示。例如，0o10等于8。
- 十六进制‌：使用0x或0X前缀表示。例如，0x10等于16。

这些表示方法使得在处理不同进制的数值时更加直观和方便。

```js
let num1 = 100;
// 十六进制
let num2 = 0x100;
// 二进制
let num3 = 0b100;
// 八进制
let num4 = 0o100;

console.log(num1);  //100
console.log(num2);  //256
console.log(num3);  //4
console.log(num4);  //64
```

### 1.6.2  Number.isFinite() 和 Number.isNaN()
- ‌Number.isFinite()‌：用于检查一个数值是否有限。与传统的isFinite()方法不同，Number.isFinite()不会先将非数值的值转换为数值。
- Number.isNaN()‌：用于检查一个值是否为NaN（Not-a-Number）。与传统的isNaN()方法不同，Number.isNaN()不会先将非数值的值转换为数值。

```js
let num1 = Number.isFinite(100) //true
let num2 = Number.isFinite(100/0) //false
let num3 = Number.isFinite(Infinity) // false
let num4 = Number.isFinite("100") //false

let num1 = Number.isNaN(100) // false
let num2 = Number.isNaN(NaN) //true
let num3 = Number.isNaN("kerwin") //false
let num4 = Number.isNaN("100") // false
```

### 1.6.3 Number.parseInt() 和 Number.parseFloat()
1. Number.parseInt()

‌用途‌：

Number.parseInt()方法用于将字符串转换为整数。它会从字符串的第一个字符开始解析，直到遇到第一个不是数字的字符为止，或者直到字符串的末尾。

‌用法‌：

```js
Number.parseInt(string, radix);
```

- string：要解析的字符串。
- radix（可选）：指定解析时使用的基数（即进制）。范围是2到36。如果省略该参数或其值为0，则默认使用10进制。如果基数小于2或大于36，则parseInt()方法将返回NaN。


‌示例‌：

```js
console.log(Number.parseInt("123")); // 123
console.log(Number.parseInt("123abc")); // 123
console.log(Number.parseInt("0x10")); // 16（解析为16进制）
console.log(Number.parseInt("10", 2)); // 2（解析为2进制）
```

2. Number.parseFloat()
‌用途‌：


Number.parseFloat()方法用于将字符串转换为浮点数。它会从字符串的第一个字符开始解析，直到遇到第一个不能转换为浮点数的字符为止，或者直到字符串的末尾。


‌用法‌：

```js
Number.parseFloat(string);
```

string：要解析的字符串。


‌示例‌：

```js
console.log(Number.parseFloat("123.45")); // 123.45
console.log(Number.parseFloat("123.45abc")); // 123.45
console.log(Number.parseFloat("123.45.67")); // 123.45（只解析到第一个点为止）
```

区别


1. ‌返回类型‌：Number.parseInt()返回整数，而Number.parseFloat()返回浮点数。
2. ‌解析方式‌：Number.parseInt()按指定的基数（进制）解析字符串，而Number.parseFloat()则始终按十进制的方式解析字符串中的数字部分（尽管可以包含小数点）。
3. ‌解析终止条件‌：两者都会在遇到第一个不能转换的字符时停止解析，但Number.parseFloat()在解析浮点数时还会考虑小数点。


总的来说，Number.parseInt()和Number.parseFloat()是JavaScript中用于解析字符串并转换为数值的两个非常有用的方法。它们使得开发者能够方便地将字符串形式的数字转换为可以进行数学运算的数值类型。



### 1.6.4 Number.isInteger()

Number.isInteger()方法用于判断一个数值是否为整数。如果参数不是数值，Number.isInteger()会返回false。

```js
let num13 = Number.isInteger(100);      //true
let num14 = Number.isInteger(100.0);    //true
let num15 = Number.isInteger("kerwin"); //false
let num16 = Number.isInteger("100");    //false
```

### 16.5 Number.EPSILON
Number.EPSILON是ES6在Number对象上新增的一个极小的常量，表示1与大于1的最小浮点数之间的差。它用于确定两个浮点数是否足够接近，从而可以认为是相等的。

```js
function isEqual(x,y){
    return Math.abs(x-y)<Number.EPSILON
}
console.log(isEqual(0.1+0.2,0.3));
```


### 1.6.6 Math对象的扩展方法

- ‌Math.trunc()‌：用于去除一个数的小数部分，返回其整数部分。对于非数值，Math.trunc会先使用Number方法将其转换为数值。
- ‌Math.sign()‌：用于判断一个数是正数、负数还是零。对于非数值，会先将其转换为数值。
- ‌Math.cbrt()‌：用于计算一个数的立方根。
- ‌Math.hypot()‌：返回所有参数的平方和的平方根。如果参数不是数值，Math.hypot会将其转换为数值。只要有一个参数无法转换为数值，就会返回NaN。

```js
// 小数抹掉
console.log(Math.trunc(1.2));   //1
console.log(Math.trunc(1.8));   //1
console.log(Math.trunc(-1.2));   //-1
console.log(Math.trunc(-1.8));   //-1

// 判断是否是负数、正数、还是零
console.log(Math.sign(-100));       //-1
console.log(Math.sign(100));        //+1
console.log(Math.sign(0));          //+0
console.log(Math.sign(-0));         //-0
console.log(Math.sign("kerwin"));   //NaN
```

## 1.7 数组扩展

### 1.7.1 展开运算符 ...

```js
// 展开运算符 ...
let arr = [1, 2, 3];
// 使用 concat 复制
let arr2 = arr.concat();
arr2.pop();
console.log(arr2); //[1,2]

// 1.展开运算符-复制
let arr3 = [...arr];
arr3.pop();
console.log(arr3); //[1,2]
let arr4 = [4, 5, 6];

// 2.展开运算符-合并
console.log([...arr, ...arr4]); // [1, 2, 3, 4, 5, 6]

// 3.展开运算符-批量赋值
let myarr = [1, 2, 3, 4, 5, 6, 7, 8];
let [a, b, ...c] = myarr;
console.log(c); // [3, 4, 5, 6, 7, 8]

```

### 1.7.2 Array.from()

将类数组对象转换为真正数组

```html
<ul>
    <li>xxxx</li>
    <li>xxxx</li>
    <li>xxxx</li>
    <li>xxxx</li>
    <li>xxxx</li>
</ul>
<script>
    // Array.from剋将一些类数组转成真数组
    // arguments并不是真正的数组  不能使用数组的方法
    function test(arguments){
        console.log(arguments[1]);
        // Array.from将arguments转变真正的数组
        console.log(Array.from(arguments));
        
    }
    test(1,2,3,4)
  
    let olis = document.querySelectorAll("li");
    console.log(olis);
    
    // Array.from 转变成真数组
    Array.from(olis).map(function(){
        
    })
    
</script>
```


### 1.7.3 Array.of()

注意：单变量无法创建数组

```js
// Array.of
let arr3 = Array(3,4,5)
console.log(arr3);   // {0:3,1:4,2:5,length:1}

// 创建出的是三个长度的数组
let arr1 = Array(3) 
console.log(arr1);// {length:3}

// 解决单个变量无法创建数组
let arr2 = Array.of(3)
console.log(arr2);     // {0:3,length:1}
```

### 1.7.4 find与findIndex

```js
let arr = [11,12,13,14,15]

// 1.找出大于13的值（返回一个值）
let result = arr.find(function(item){
    return item>13
})
console.log(result);    //14

// 2.找出大于13的索引值 （返回一个值）
let result2 = arr.findIndex(function(item){
    return item>13
})
console.log(result2);   //4
// 相反的 findLast findLastIndex() 是ES13的
```

### 1.7.5 fill

```js
// 填充数据
let arr = new Array(3).fill("kerwin");
console.log(arr); //['kerwin', 'kerwin', 'kerwin']

// 替换数组内容
let arr1 = [11, 22, 33];
console.log(arr1.fill("kerwin", 1, 2)); //[11, 'kerwin', 33]
```


### 1.7.6 copyWithin()‌

- 作用：在数组内部，将一系列元素位置复制到另一个位置上，而不改变数组的大小。
- 参数：
- target（必须）：从该位置开始替换数据。如果为负值，表示倒数位置。
- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
- 示例：

```js
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3); // [4, 5, 3, 4, 5]
```

## 1.8 对象的扩展

### 1.8.1 属性的简洁表示法
ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。

```js
const foo = 'bar';
const baz = {foo};
baz // {foo: "bar"}

// 等同于
const baz = {foo: foo};
```

上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。


```js
function f(x, y) {
    return { x, y };
}

// 等同于
function f(x, y) {
    return { x: x, y: y };
}
f(1, 2); // Object {x: 1, y: 2}
```


除了属性简写，方法也可以简写。

```js
const o = {
    method() {
        return "Hello!";
    },
};
// 等同于
const o = {
    method: function () {
        return "Hello!";
    },
};
```

下面是一个实际的例子。

```js
let birth = "2000/01/01";
const Person = {
    name: "张三",
    //等同于birth: birth
    birth,
    // 等同于hello: function ()...
    hello() {
        console.log("我的名字是", this.name);
    },
};
```

这种写法用于函数的返回值，将会非常方便。

```js
function getPoint() {
    const x = 1;
    const y = 10;
    return { x, y };
}

getPoint();
// {x:1, y:10}
```

### 1.8.2 方括号语法

#### 1.8.2.1 方括号语法的用法

```js
const prop = "age";
const person = {};
person.prop = 18;
console.log(person); // { prop: 18 }

// -----------------------------------------
const prop = "age";
const person = {};
person[prop] = 18;
console.log(person); // { age: 18 }

// -----------------------------------------
// ES6 增强
const prop = "age";
const person = {
    [prop]: 18,
};
console.log(person); // { age: 18 }
```

#### 1.8.2.2 方括号中可以放什么

```js
// [值、可以得到值的表达式]
const prop = 'age';
const func = () => 'age2';
const person = {
    [prop]: 18,
    [func()]: 24,
    ['sex']: 'man',
    ['s' + 'ex2']: 'womam'
};

console.log(person);    // { age: 18, age2: 24, sex: 'man', sex2: 'womam' }
```

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};
myObject // Object {[object Object]: "valueB"}
```

上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。

#### 1.8.2.3 方括号语法和点语法的区别
1. 点语法是方括号语法的特殊形式
2. 属性名由数字、字母、下划线以及 $ 构成，并且数字还不能打头的时候可以使用点语法（合法标识符）
3. 能用点语法优先使用点语法

```js
const person = {
    age: 18
};

//person.age 等价于 person['age']
```

### 1.8.3 super 关键字
我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。

```js
const proto = {
    foo: "hello",
};

const obj = {
    foo: "world",
    find() {
        return super.foo;
    },
};

// setPrototypeOf 静态方法可以将一个指定对象的原型设置为另一个对象或者 null。
Object.setPrototypeOf(obj, proto);
obj.find(); // "hello"
```

上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。

注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。


```js
// 报错
const obj = {
    foo: super.foo,
};
// 报错
const obj = {
    foo: () => super.foo,
};
// 报错
const obj = {
    foo: function () {
        return super.foo;
    },
};
```

上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。


JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。

```js
const proto = {
    x: "hello",
    foo() {
        console.log(this.x);
    },
};
const obj = {
    x: "world",
    foo() {
        super.foo();
    },
};
Object.setPrototypeOf(obj, proto);
obj.foo(); // "world"
```

上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。

### 1.8.4 对象的展开运算符

#### 1.8.4.1 展开对象
对象不能直接展开，必须在 {} 中展开

```js
const apple = {
    color: '红色',
    shape: '球形',
    taste: '甜'
};
console.log({...apple});            // { color: '红色', shape: '球形', taste: '甜' }
console.log({...apple} === apple);  // false
```

#### 1.8.4.2 合并对象

```js
const apple = {
    color: '红色',
    shape: '球形',
    taste: '甜'
};
const pen = {
    color: '黑色',
    shape: '圆柱形',
    use: '写字'
};

// 新对象拥有全部属性，相同属性，后者覆盖前者
console.log({...apple, ...pen});    // { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }
console.log({...pen, ...apple});    // { color: '红色', shape: '球形', use: '写字', taste: '甜' }
```

#### 1.8.4.3 注意事项

##### 1.8.4.3.1 空对象的展开

如果展开一个空对象，则没有任何效果。

```js
console.log({...{}});           // {}
console.log({...{}, a: 1});     // { a: 1 }
```

##### 1.8.4.3.2 非对象的展开
如果展开的不是对象，则会自动将其转为对象，再将其属性罗列出来（没有属性便为空）。

```js
console.log({...1});            // {}
console.log(new Object(1));     // [Number: 1]
console.log({...undefined});    // {}
console.log({...null});         // {}
console.log({...true});         // {}
```

##### 1.8.4.3.3 字符串的展开
如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。


```js
// 字符串在对象中展开
console.log({...'alex'});       // { '0': 'a', '1': 'l', '2': 'e', '3': 'x' }

// 字符串在数组中展开
console.log([...'alex']);       // [ 'a', 'l', 'e', 'x' ]

// 字符串直接展开
console.log(...'alex');         // a l e x
```

##### 1.8.4.3.4 数组的展开

```js
console.log({...[1, 2, 3]});    // { '0': 1, '1': 2, '2': 3 }
```


##### 1.8.4.3.5 对象中对象属性的展开
不会展开对象中的对象属性。

```js
const apple = {
    feature: {
        taste: '甜'
    }
};
const pen = {
    feature: {
        color: '黑色',
        shape: '圆柱形'
    },
    use: '写字'
};
console.log({...apple});            // { feature: { taste: '甜' } }
// feature 会直接覆盖，因为 feature 不能展开
console.log({...apple, ...pen});    // { feature: { color: '黑色', shape: '圆柱形' }, use: '写字' }
```


#### 1.8.4.4 对象展开运算符的应用
##### 1.8.4.4.1 复制对象

```js
const a = {x: 1, y: 2};
const c = {...a};
console.log(c, c === a);
// { x: 1, y: 2 } false
```

#### 1.8.4.4.2 用户参数和默认参数

```js
const logUser = userParam => {
    const defaultPeram = {
        username: 'ZhangSan',
        age: 0,
        sex: 'male'
    };
    const param = {...defaultPeram, ...userParam};
    console.log(param.username, param.age, param.sex);
};
logUser({username: 'jerry'});   // jerry 0 male

```

再优化：

```js
const logUser = userParam => {
    const defaultPeram = {
        username: 'ZhangSan',
        age: 0,
        sex: 'male'
    };
    const {username, age, sex} = {...defaultPeram, ...userParam};
    console.log(username, age, sex);
};
logUser({username: 'jerry'});   // jerry 0 male
```

## 1.9 函数扩展

### 1.9.1 函数参数的默认值
#### 1.9.1.1 认识函数参数的默认值

调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值

#### 1.9.1.2 函数参数默认值的基本用法

```js
// 之前的默认值实现方式
const multiply = (x, y) => {
    if (typeof y === 'undefined') {
        y = 3;
    }
    return x * y;
};
console.log(multiply(2, 2));    // 4
console.log(multiply(2));        // 6

// ES6 默认值实现方式
const multiply = (x, y = 3) => {
    return x * y;
};
console.log(multiply(2, 2));    // 4
console.log(multiply(2));        // 6
```

#### 1.9.1.3 默认值的生效条件

不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效。
注意：null 就是 null，不会使用默认值。


#### 1.9.1.4 与解构赋值默认值结合使用
参数默认值可以与解构赋值的默认值，结合起来使用。

```js
function foo({ x, y = 5 }) {
    console.log(x, y);
}
foo({}); // undefined 5
foo({ x: 1 }); // 1 5
foo({ x: 1, y: 2 }); // 1 2
foo(); // TypeError: Cannot read property 'x' of undefined
```

上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo()的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo()调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。


```js
function foo({ x, y = 5 } = {}) {
    console.log(x, y);
}
foo(); // undefined 5
```


上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。
下面是另一个解构赋值默认值的例子。

```js
function fetch(url, { body = "", method = "GET", headers = {} }) {
    console.log(method);
}
fetch("http://example.com", {});
// "GET"
fetch("http://example.com");
// 报错
```


上面代码中，如果函数fetch()的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。

```js
function fetch(url, { body = "", method = "GET", headers = {} } = {}) {
    console.log(method);
}
fetch("http://example.com");
// "GET"
```

上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。
注意，函数参数的默认值生效以后，参数解构赋值依然会进行。


```js
function f({ a, b = "world" } = { a: "hello" }) {
    console.log(b);
}
f(); // world
```


上面示例中，函数f()调用时没有参数，所以参数默认值{ a: 'hello' }生效，然后再对这个默认值进行解构赋值，从而触发参数变量b的默认值生效。


#### 1.9.1.5 参数默认值的位置


通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```js
// 例一
function f(x = 1, y) {
    return [x, y];
}
f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
    return [x, y, z];
}
f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
```

上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。

如果传入undefined，将触发该参数等于默认值，null则没有这个效果。

```js
function foo(x = 5, y = 6) {
    console.log(x, y);
}
foo(undefined, null)
// 5 null
```


上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。

#### 1.9.1.6 函数参数默认值的应用


接收很多参数的时候

```js
// 普通时候
const logUser = (username = 'zjr', age = 18, sex = 'male') => {
    console.log(username, age, sex);
};
// 需要能够记住参数的顺序，如果参数较多那么需要配合文档，使用不方便
logUser('jerry', 18, 'male');

// ------------------------------------------------------------
// 接收一个对象作为参数
// 不需要记住参数的顺序
const logUser = options => {
    console.log(options.username, options.age, options.sex);
};
logUser({
    username: 'jerry',
    age: 18,
    sex: 'male'
});

// ------------------------------------------------------------
// 再优化
const logUser = ({username, age, sex}) => {
    console.log(username, age, sex);
};
logUser({
    username: 'jerry',
    age: 18,
    sex: 'male'
});

// ------------------------------------------------------------
// 引入默认值
const logUser = ({
    username = 'zjr',
    age = 18,
    sex = 'male'
}) => {
    console.log(username, age, sex);
};
// 其实是解构赋值原理
logUser({username: 'jerry'});    // jerry 18 male
logUser({});    // zjr 18 male
logUser();        // 报错，因为这样相当于传了一个 undefined，不符合解构赋值

// ------------------------------------------------------------
// 再优化（函数默认值 + 解构赋值 + 解构赋值默认值）
const logUser = ({
    username = 'zjr',
    age = 18,
    sex = 'male'
} = {}) => {
    console.log(username, age, sex);
};
logUser();    // zjr 18 male

/* 
    解释：
    1、options 与 {username = 'zjr', age = 18, sex = 'male'} 互等
    2、{username = 'zjr', age = 18, sex = 'male'} = {} 其实就是 options = {}
    3、由于 logUser() 的实参为 undefined，所以默认值为 {}
    4、再因为 {username = 'zjr', age = 18, sex = 'male'} = {} 是解构赋值
    5、由于 {} 内为 undefined，所以解构赋值启用默认值
    5、所以真正的形参为 {username = 'zjr', age = 18, sex = 'male'}
    注明：这样做的好处是增加函数的健壮性！
*/

```

某一个参数不得省略，如果省略就抛出一个错误

```js
function throwIfMissing() {
    throw new Error("Missing parameter");
}

function foo(mustBeProvided = throwIfMissing()) {
    return mustBeProvided;
}

foo();
// Error: Missing parameter
```

上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。

从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。
另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。
function foo(optional = undefined) { ··· }



### 1.9.2 rest 参数
#### 1.9.2.1 前言
剩余语法（Rest syntax 也可以叫剩余参数）看起来和展开语法完全相同都是使用 ... 的语法糖，不同之处在于剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来成为一个整体。

#### 1.9.2.2 函数参数

在讲解剩余参数前，我们先来看看，剩余参数在函数参数中都解决了哪些问题？为什么会引入剩余参数的概念？

在 ES5 中，函数经常会传入不定参数，在传入不定参数时，ES5 的给出的解决方案是通过 arguments 对象来获取函数调用时传递的参数。 arguments 对象不是一个数组，它是一个类数组对象，所谓类数组对象，就是指可以通过索引属性访问元素并且拥有 length 属性的对象。


一个简单的类数组对象是长这样的:

```js
var arrLike = {
    0: 'name',
    1: 'age',
    2: 'job',
    length: 3
}
```

而它所对应的数组应该是这样子的：

```js
var arr = ['name', 'age', 'job'];
```


这里我们说类数组对象与数组的性质相似，是因为类数组对象在访问、赋值、获取长度上的操作与数组是一致的，具体内容可查阅相关的类数组使用。
在函数体中定义了 Arguments 对象，其包含函数的参数和其它属性，以 arguments 变量来指代。下面我们看个实例：

```js
function fn() {
    console.log(arguments);
}
fn('imooc', 7, 'ES6')
```

在控制台中打印出上面的代码结果，如下图所示：在定义函数的时候没有给定参数，但是通过 arguments 对象可以拿到传入的参数。可以看到 arguments 中包含了函数传递的参数、length 等属性，length 属性表示的是实参的长度，即调用函数的时候传入的参数个数。这样我们就对 arguments 对象有了一定的了解。

在 ES5 的开发模式下，想要使用传递的参数，则需要按位置把对应的参数取出来。尽管 arguments 是一个类数组且可遍历的变量，但它终究不是数组，它不支持数组方法，因此我们不能调用 arguments.forEeach (…) 等数组的方法。需要使用一些特殊的方法转换成数组使用，如：


```js
function fn() {
    var arr = [].slice.call(arguments);
    console.log(arr)
}
fn('ES6');
//  ["ES6"]
fn('imooc', 7, 'ES6');
//  ["imooc", 7, "ES6"]
```

终于借助 call 方法把 arguments 转化成一个真正的数组了。但是这样无疑是一个繁琐的过程，而且不容易理解。这时 ES6 给出了它的完美解决方案 —— 剩余参数，那剩余参数是如何在函数传参中使用的呢？下面我们来看看实例：
语法：
```js
const add = (x, y, z, ...args) => {};
```


```js
function fn(...args) {
    console.log(args)
}
fn('ES6');
//  ["ES6"]
fn('imooc', 7, 'ES6');
//  ["imooc", 7, "ES6"]
```


使用方式很简单在函数定义时使用 ... 紧接着跟一个收集的参数，这个收集的参数就是我们所传入不定参数的集合 —— 也就是数组。这样就很简单地摆脱了 arguments 的束缚。

另外，还可以指定一个默认的参数，如下示例：

```js
function fn(name, ...args) {
    console.log(name);  // 基础参数
    console.log(args);  // 剩下的参数组成的数组
}
fn('ES6');
//    'ES6'
//    []
fn('imooc', 7, 'ES6');
//  "imooc"
//    [7, "ES6"]
```


上面的代码中给函数第一个参数，声明一个变量 name，剩余的参数会被 ... 收集成一个数组，这就是剩余参数。引入剩余参数就是为了能替代函数内部的 arguments，由于 arguments 对象不具备数组的方法，所以很多时候在使用之前要先转换成一个数组。而剩余参数本来就是一个数组，避免了这多余的一步，使用起来既优雅又自然。

#### 1.9.2.3 注意事项

箭头函数的剩余参数

箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号。

```js
const add = (...args) => {};
```

使用剩余参数替代 arguments 获取实际参数

- 剩余参数是一个 “真数组”，arguments 是一个 “伪数组”
- 剩余参数的名字可以自定义

剩余参数的位置

剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。


#### 1.9.2.4 剩余参数的应用

作为数组的应用：

```js
const add = (...args) => {
    let sum = 0;
    for (let i = 0; i < args.length; i++) {
        sum += args[i];
    } // 当然此处，arguments 也可以
    return sum;
};
console.log(add());            // 0
console.log(add(1, 1));        // 2
console.log(add(1, 2, 3));    // 6
```

与解构赋值结合使用：

（剩余参数不一定非要作为函数参数使用）

- 与数组解构赋值结合

```js
let array = [1, 2, 3, 4, 5];
let [a, b, ...others] = array;

console.log(a);                     // 1
console.log(b);                     // 2
console.log(others);         // [3,4,5]
```

- 与对象解构赋值结合
```js
const {x, y, ...z} = {a: 3, x: 1, y: 2, b: 4};
console.log(x, y, z);
// 1 2 { a: 3, b: 4 }
// 这里的剩余参数是个对象（准确的应该叫：剩余元素）

const func = ({x, y, ...z}) => {
    console.log(x, y, z);    // 1 2 { a: 3, b: 4 }
};
func({a: 3, x: 1, y: 2, b: 4});
```

- 在函数传参的时候也可以是和解构一起使用

```js
function fun(...[a, b, c]) {
    return a + b + c;
}
fun('1')          // NaN (b 和 c 都是 undefined)
fun(1, 2, 3)      // 6
fun(1, 2, 3, 4)   // 6 多余的参数不会被获取到
```

上面的代码中，a、b、c 会去解构传入参数，加上有剩余语法的作用，对应的值从数组中的项解构出来，在函数内部直接使用解构出来的参数即可。剩余语法看起来和展开语法完全相同，不同点在于，剩余参数用于解构数组和对象。

#### 1.9.2.5 小结

本节结合了 ES5 函数中的 arguments 对象引入了为什么 ES6 会引入剩余参数的概念，可以看到剩余参数所带来的好处。本节内容可以总结以下几点：

1. 剩余参数是为了能替代函数内部的 arguments 而引入的；
2. 和展开语法相反，剩余参数是将多个单个元素聚集起来形成一个单独的个体的过程。

### 1.9.3 箭头函数
#### 1.9.3.1 前言

在编程中使用最多的就是函数，在 ES5 中是用 function 关键字来定义函数的，由于历史原因 function 定义的函数存在一些问题，如 this 的指向、函数参数 arguments 等。

ES6 规定了可以使用 “箭头” => 来定义一个函数，语法更加简洁。它没有自己的 this、arguments、super 或 new.target，箭头函数表达式更适用于那些本来需要匿名函数的地方，但它不能用作构造函数。

#### 1.9.3.2 认识箭头函数

- 普通函数：
    - function 函数名() {}
    - const 变量名 = function () {};
- 箭头函数：
    - 参数 => 函数体
    - () => {}

由于箭头函数是匿名函数，所以我们通常把它赋给一个变量

```js
const add = (x, y) => {
    return x + y;
};
console.log(add(1, 1));        // 2
```

#### 1.9.3.3 箭头函数注意事项

1. 省略写法

```js
const add = (x) => {
    return x + 1;
};

// 单个参数可以省略 ()
const add = x => {
    return x + 1;
};

// 无参数
const test = () => {
    return 1;
};

//或者
const test = _ => {
    return 1;
};
```

2. 单行函数体

```js
const add = (x, y) => {
    return x + y;
};
// 单行函数体可以省略 return 和 {}，且一但省略就 return 和 {} 都要一起省略
const add = (x, y) => x + y; 
```

3. 单行对象

```js
const add = (x, y) => {
    return {
        value: x + y
    };
};
// const add = (x, y) => {value: x + y};  报错！因为 {} 会产生歧义！
// () 可以将语句变为表达式，从而 {} 就可以被顺理成章解释为对象
const add = (x, y) => ({value: x + y});
// 数组就没有以上问题
const add = (x, y) => [x, y];
```

推荐：一般情况最好不要简写！

##### 1.9.3.4 非箭头函数中的 this 指向
1. 全局作用域中的 this 指向

```js
console.log(this);
// window
```

2. 一般函数（非箭头函数）中的 this 指向
只有在函数调用的时候 this 指向才能确定，不调用的时候，不知道指向谁。
this 指向和函数在哪儿没有关系，只和谁在调用有关。

```js
function add() {
    console.log(this);
}
add();    // window
// 在非严格模式下，this 其实是先指向 undefined，然后被自动转为了 window

'use strict'    // 严格模式
function add() {
    console.log(this);
}
add();    // undefined
// 在严格模式下，this 为 undefined

'use strict'    // 严格模式

function add() {
    console.log(this);
}

const calc = {
    add: add
};

calc.add();        // 上下文 this 为 calc
const adder = calc.add;
adder();        // 指向 undefined（非严格模式下指向 window）
```


#### 1.9.3.5 箭头函数没有 this
在 JavaScript 中，要说让人最头疼的知识点中，this 绑定绝对算一个，这是因为 this 的绑定 ‘难以捉摸’，出错的时候还往往不知道为什么，相当反逻辑。下面我们来看一个示例：


```js
var title = "全局标题";
var imooc = {
    title: "慕课网 ES6 Wiki",
    getTitle : function(){
        console.log(this.title);
    }
};
imooc.getTitle();        // 慕课网 ES6 Wiki
var bar = imooc.getTitle;
bar();        // 全局标题
```

通过上面的小例子的打印结果可以看出 this 的问题，说明 this 的指向是不固定的。
这里简单说明一下 this 的指向，this 指向的是调用它的对象。例子中的 this 是在 getTitle 的函数中的，执行 imooc.getTitle() 这个方法时，调用它的对象是 imooc，所以 this 的指向是 imooc。


之后把 imooc.getTitle 方法赋给 bar，这里要注意的是，只是把地址赋值给了 bar ，并没有调用。 而 bar 是全局对象 window 下的方法，所以在执行 bar 方法时，调用它的是 Window 对象，所以这里打印的结果是 window 下的 title——“全局标题”。

TIPS: 上面的示例只是简单的 this 指向问题，还有很多更加复杂的，在面试中经常会被问到，所以还不清楚的同学可以去研究一下 this 的问题。

ES6 为了规避这样的问题，提出了箭头函数的解决方案，在箭头函数中没有自己的 this 指向，所有的 this 指向都指向它的上一层 this ，这样规定就比较容易理解了。下面看使用箭头函数下的 this 指向：


```js
var title = "全局标题";
var imooc = {
    title: "慕课网 ES6 Wiki",
    getTitle : () => {
        console.log(this.title);
    }
};
imooc.getTitle();        // 全局标题
var bar = imooc.getTitle;
bar();        // 全局标题
```


上面的打印结果可以看出来，所有的 this 指向都指向了 window 对象下的 title，本身的 imooc 对象下没有了 this ，它的上一层就是 window。

##### 1.9.3.6 不适用箭头函数的场景
1. 作为构造函数

因为箭头函数没有 this，而构造函数的核心就是 this。

2. 需要 this 指向调用对象的时候

因为箭头函数没有 this，所以如果箭头函数中出现了 this，那么这个 this 就是外层的！

3. 需要使用 arguments 的时候

箭头函数没有 arguments。（这个问题有替代解决方案：剩余参数）


```js
var fun = function() {
    console.log(arguments)
};
fun(1,2,3);  // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
var fun = () => {
    console.log(arguments)
};
fun(1,2,3);  // Uncaught ReferenceError: arguments is not defined

```

上面的示例中，对比两种定义函数的方法可以明显的看出，在箭头函数中去取 arguments 时会报引用错误，没有定义的 arguments。
arguments 的主要作用是获取所有调用函数时所需要传入的参数，在箭头函数中使用剩余参数 ...args，在函数内可以直接使用。

```js
function foo(...args) { 
    console.log(args)
}
foo(1);         // [1]
foo(1, 2, 3);   // [1, 2, 3]
```

##### 1.9.3.7 其他注意点

1. 不能用作构造器

箭头函数不能用作构造器，和 new 一起用会抛出错误。

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```

2. 没有 prototype 属性

箭头函数没有 prototype 属性。

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

3. 不能使用 yield 命令

yield 关键字通常不能在箭头函数中使用，因此箭头函数不能用作 Generator 函数。

#### 1.9.3.8 小结

本节主要讲解了 ES6 的箭头函数，总结了以下几点：

- 更短的函数，优雅简洁；
- 箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this；
- 不能绑定 arguments， 只能使用 ...args 展开运算来获取当前参数的数组。



### 1.9.4.函数的name属性

```js
function test(){
}
console.log(test.name); //test
```

## 1.10 Symbol

ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

### 1.10.1 使用Symbol作为对象属性名

```js
let name = Symbol()
let age = Symbol()
var obj  ={
    [name]:"kerwin",
    [age]:100
}
```

### 1.10.2 添加标记
Symbol()函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。这主要是为了在控制台显示，比较容易区分。

```js
let name = Symbol("name")
let age = Symbol("age")
var obj  ={
    [name]:"kerwin",
    [age]:100
}
console.log(obj)
```

### 1.10.3 遍历问题

```js
let keys = {
    name: Symbol("name"),
    age: Symbol("age"),
};
var obj = {
    [keys.name]: "kerwin",
    [keys.age]: 100,
    a: 1,
    b: 2,
    c: 3,
};
Reflect.ownKeys(obj).forEach(item => {
    console.log(item, obj[item]);
});
```

### 1.10.4 同一属性值
Symbol.for()可以重新使用同一个 Symbol 值

```js
var obj  ={
    [Symbol.for("name")]:"kerwin",
    [Symbol.for("age")]:100
}

console.log(obj[Symbol.for("name")])
```

## 1.11 Iterator迭代器

### 1.11.1 作用

Iterator 的作用有三个：

- 一是为各种数据结构，提供一个统一的、简便的访问接口；
- 二是使得数据结构的成员能够按某种次序排列；
- 三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of循环

```js    
let arr = ["kerwin", "tiechui", "gangdaner"]
for(let i of arr){
    console.log(i)
}
```

### 1.11.2 遍历过程

Iterator 的遍历过程是这样的。

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。

```js
let i = arr[Symbol.iterator]()

console.log(i.next())
console.log(i.next())
console.log(i.next())
console.log(i.next())
```

ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。

原生默认具备 Iterator 接口的数据结构如下。
- Array
- Set
- Map
- String
- arguments 对象
- NodeList 对象



### 1.11.3 如何对于对象进行for fo遍历？

```js
let obj = {
    0: "kerwin",
    1: "tiechui",
    2: "gangdaner",
    length: 3,
    [Symbol.iterator]: Array.prototype[Symbol.iterator]
}
for (let i of obj) {
    console.log(i)
}

 
let obj2 = {
    data: ['kerwin', 'tiechui', "gangdaner"],
    [Symbol.iterator]() {
        // let _this = this
        let index = 0;
        return {
            next: () => {
                if (index < this.data.length) {
                    return {
                        value: this.data[index++],
                        done: false
                    }
                } else {
                    return {
                        value: undefined,
                        done: true
                    }
                }
            }
        }
    }
};
for (let i of obj2) {
    console.log(i)
}
```

## 1.12 Set结构

它类似于数组，但成员的值都是唯一的，没有重复的值。
### 1.12.1 初识Set

```js
let s1 = new Set([1, 2, 3, 2, 3])
console.log(s1)

let s2 = new Set()
s2.add(1)
s2.add(2)
s2.add(3)
console.log(s2)
```

### 1.12.2 实例的属性和方法
- size：返回Set实例的成员总数。
- Set.prototype.add(value)：添加某个value。
- Set.prototype.delete(value)：删除某个value，返回一个布尔值，表示删除是否成功。
- Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
- Set.prototype.clear()：清除所有成员，没有返回值。
### 1.12.3 遍历
- Set.prototype.keys()：返回键名的遍历器
- Set.prototype.values()：返回键值的遍历器
- Set.prototype.entries()：返回键值对的遍历器
- Set.prototype.forEach()：遍历每个成员
### 1.12.4 复杂数据结构去重

```js
function uni(arr) {
    let res = new Set();
    return arr.filter(item => {
        let id = JSON.stringify(item);
        if (res.has(id)) {
            return false;
        } else {
            res.add(id);
            return true;
        }
    });
}
var arr = [
    1,
    2,
    3,
    "data",
    {
        name: "kerwin",
    },
    {
        name: "kerwin",
    },
    [1, 2],
    [3, 4],
    [3, 4],
];
console.log(uni(arr));
```

## 1.13 Map结构

类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。

### 1.13.1 初识Map

```js
let m1 = new Map()
m1.set("name","kerwin")
m1.set({a:1},"大连")

console.log(m1)

let m2= new Map([
    ["name","kerwin"],
    [{a:1},"大连"]
])

console.log(m2)
```

### 1.13.2 实例的属性和方法

- size：返回 Map 结构的成员总数。
- Map.prototype.set(key,value)：添加key对应得value，返回 Map 结构本身。
- Map.prototype.get(key)：获取key对应的value
- Map.prototype.delete(key)：删除某个键（键名+键值）
- Map.prototype.has(key)：某个键是否在当前 Map 对象之中。
- Map.prototype.clear()：清除所有成员，没有返回值。
### 1.13.3 遍历
- Map.prototype.keys()：返回键名的遍历器。
- Map.prototype.values()：返回键值的遍历器。
- Map.prototype.entries()：返回所有成员的遍历器。
- Map.prototype.forEach()：遍历 Map 的所有成员。


## 1.14 Reflect反射

Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。

### 1.14.1 代替Object的某些方法

```js
let obj = {};
Object.defineProperty(obj, "name", {
    value: "kerwin",
});
console.log(obj);

// Object 之后的一些方法和属性不再添加到Object 使用使用Reflect代替
// 使用Reflect
let obj2 = {};
Reflect.defineProperty(obj2, "name", {
    value: "kerwin",
    writable: false, // 是否可以修改
    enumerable: false, // 是否可以删除
});
console.log(obj2);
```


### 1.14.2 修改某些Object方法返回结果

```js
// 老写法
try {
    Object.defineProperty(target, property, attributes);
    // success
} catch (e) {
    // fail
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
    // success
} else {
    // fail
}
```

### 1.14.3 命令式变为函数行为
```js
let obj = {
    name:'kerwin'
}
// 判断是否在对象中
// 旧写法
console.log("name" in obj);
// 新写法
console.log(Reflect.has(obj,'name'));

// 删除
delete obj.name
// 新写法
Reflect.defineProperty(obj,"name")

// set与get
Reflect.set(obj,"age",100)
console.log(Reflect.get(obj.name));
```

### 1.14.4 配合Proxy

```js
let s = new Set()

let proxy = new Proxy(s,{
    get(target,key){
        console.log("get");
        // 判断如果是方法，修正this指向
        let value = target[key]
        if(value instanceof Function){
            // call apply bind
            // 这里是绑定原本的对象
            return value.bind(target)
        }
        // 不是就正常返回
        return value
    },
    set(target,key,value){
        // 走默认行为
        Reflect.set(target,key,value)
        // 简略写法
        // Reflect.set(...arguments)
    }
})
```

### 1.14.5 处理数组的代理

```js
let arr = [1,2,3]

let proxy = new Proxy(arr,{
    get(target,key){
        console.log("get",key);
        // 反射原来的方法
        return Reflect.get(...arguments)
    },
    set(target,key,value){
        console.log("set",target,key,value);
        
        return Reflect.set(...arguments)
    }
})

// 控制台proxy.push
// get push
// get length
// set (3) [1, 2, 3] 3 4
// set (4) [1, 2, 3, 4] length 4
```

## 1.15 Promise对象

Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象 。

- 指定回调函数方式更灵活易懂。
- 解决异步 回调地狱 的问题。

### 1.15.1 回调地狱
- 当一个回调函数嵌套一个回调函数的时候
- 就会出现一个嵌套结构
- 当嵌套的多了就会出现回调地狱的情况
- 比如我们发送三个 ajax 请求
    - 第一个正常发送
    - 第二个请求需要第一个请求的结果中的某一个值作为参数
    - 第三个请求需要第二个请求的结果中的某一个值作为参数

```js
ajax({
    url: "我是第一个请求",
    success(res) {
        // 现在发送第二个请求
        ajax({
            url: "我是第二个请求",
            data: { a: res.a, b: res.b },
            success(res2) {
                // 进行第三个请求
                ajax({
                    url: "我是第三个请求",
                    data: { a: res2.a, b: res2.b },
                    success(res3) {
                        console.log(res3);
                    },
                });
            },
        });
    },
});

```


- 回调地狱，其实就是回调函数嵌套过多导致的
- 当代码成为这个结构以后，已经没有维护的可能了
    
### 1.15.2 Promise使用
语法：

```js
new Promise(function (resolve, reject) {
    // resolve 表示成功的回调
    // reject 表示失败的回调
}).then(function (res) {
    // 成功的函数
}).catch(function (err) {
    // 失败的函数
});
```

#### 1.5.2.1 基础使用
1. 第一种写法

```js
let pro = new Promise(function(resolve,reject){
    //执行器函数
    setTimeout(()=>{
        // resolve()  打印出 奖金
        reject()   // 打印出 没有
    },1000)
})
// 第一种写法
pro.then(()=>{
    console.log("奖金");    
},()=>{
    console.log("没有");       
})
```


2. 第二种写法

```js
let pro = new Promise(function(resolve,reject){
    //执行器函数
    setTimeout(()=>{
        if(false){
            resolve(1000)  
        }else{
            reject("no 0")
        }
    },1000)
})
// 第二种写法
pro.then((res)=>{
    console.log("奖金",res);  
}).catch((err)=>{
    console.log("没有",err);  
})
```

#### 1.15.2.2 ajax使用Promise模拟

```js
function ajax(url){
    return new Promise((resolve,reject)=>{
        let xhr = new XMLHttpRequest()
        xhr.open("get",url,true)
        xhr.send()
        xhr.onreadystatechange = function(){
            // xhr.readyState等于4 是执行完成
            if(xhr.readyState === 4){
                if(xhr.status>=200&&xhr.status<300){
                    resolve(JSON.parse(xhr.responseText) )
                }else{
                    reject(xhr.responseText)
                }
            }
        }
    })
}
ajax("./json/1.json").then(res=>{
    console.log(res);
}).catch(err=>{
    console.log(err);
})
```

#### 1.15.2.3 Promise进行链式调用

```js
let pro = new Promise(function(resolve,reject){
    //执行器函数
    setTimeout(()=>{
         resolve(1000)  
         // reject("no 0")
    },1000)
})
pro.then((res)=>{
    console.log("奖金1",res);
    //如果return 非promise类型，pending-fulfilled 
    // 如果return promise类型，根据这个新的promise对象的结果，决定pending-fufilled pending-rejected
    return res
}).then((res)=>{
    console.log("奖金2",res);
}).catch((err)=>{
    console.log("没有",err);
    
})
```

#### 1.15.2.4 Promise使用链式调用解决多重嵌套

```js
function ajax(url){
    return new Promise((resolve,reject)=>{
        let xhr = new XMLHttpRequest()
        xhr.open("get",url,true)
        xhr.send()
        xhr.onreadystatechange = function(){
            // xhr.readyState等于4 是执行完成
            if(xhr.readyState === 4){
                if(xhr.status>=200&&xhr.status<300){
                    resolve(JSON.parse(xhr.responseText) )
                }else{
                    reject(xhr.responseText)
                }
            }
        }
    })
}

ajax("./json/1.json").then(res=>{
    console.log(res);
    // 并没有走完 接下来继续调用
    return ajax("./json/2.json",res)
}).then(res=>{
    console.log(res);
}).catch(err=>{
    console.log(err);
})

```


### 1.15.3 Promise 对象的状态

Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。

- 异步操作未完成（pending） 
- 异步操作成功（fulfilled） 
- 异步操作失败（rejected）

这三种的状态的变化途径只有两种。

- 从“未完成”到“成功” 
- 从“未完成”到“失败”

一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。

因此，Promise 的最终结果只有两种。

- 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 
- 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。


### 1.15.4 Promise.all


Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

```js
const p = Promise.all([p1, p2, p3]);
```

p的状态由p1,p2,p3 决定，分成两种情况。

1. 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
2. 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

实例：

```js
let pro1 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         resolve(1000)  
    },1000)
})
let pro2 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         resolve(2000)  
    },2000)
})
let pro3 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         resolve(3000)  
    },3000)
})

Promise.all([pro1,pro2,pro3]).then(res =>{
     //hide loading 
     console.log(res);
}).catch(err =>{
     console.log(err);
})
```

### 1.15.5 Promise.race


Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

```js
const p = Promise.race([p1, p2, p3]);
```

上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。


```js
let pro1 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         // 直接可以定义超时
         reject(1000)  
    },1000)
})
let pro2 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         resolve(2000)  
    },2000)
})
let pro3 = new Promise(function(resolve,reject){
    setTimeout(()=>{
         resolve(3000)  
    },3000)
})

// race 谁跑的快
// 只要有一个能反映 直接结束
Promise.race([pro1,pro2,pro3]).then(res =>{
     //hide loading 
     console.log(res);
}).catch(err =>{
     console.log(err);
})

```


## 1.16 Generator 函数

- Generator 函数是 ES6 提供的一种异步编程解决方案
- Generator 函数是一个状态机，封装了多个内部状态。
- 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

### 1.16.1 基本语法

```js
function *gen(){
    console.log(11);
    yield   //产出
    console.log(22);
    yield
    console.log(33);
}

// 驱动起来
let g = gen()
g.next()
g.next()
g.next()
```

### 1.16.2 使用yield产出标记

```js
function *gen(){
    console.log(11);
    yield  "aaa"    //产出
    console.log(22);
    yield  "bbb"
    console.log(33);
}

let g = gen()
// 迭代器
let res1 = g.next()
console.log(res1);  // {value: 'aaa', done: false}

let res2 =g.next()
console.log(res2);  // {value: 'bbb', done: false}

let res3 =g.next()
console.log(res3);  // {value: undefined, done: true}

// 结果与迭代器一致 所以可以使用forof
function *gen1(){
    yield  "ccc"    //产出
    yield  "ddd"
}

let g1 = gen1()
for (const i of g1) {
    console.log(i);    
}

```

### 1.16.3 next传递参数

```js
function *gen(){
    let res1 = yield "aaa"    //产出
    console.log("gen内部",res1);
    let res2 = yield "bbb"
    console.log("gen内部",res2);
}

let g = gen()
// 第一次传入的参数无意义
// 第一步：yield "aaa" 停掉
// 第二步： [传入-2222222] 值给了 res1

let res1 = g.next("传入-1111111")
console.log(res1);  
// {value: 'aaa', done: false}

let res2 = g.next("传入-2222222")
console.log(res2);
// gen内部 传入-2222222
// {value: 'bbb', done: false}

let res3 = g.next("传入-3333333")
console.log(res3);
// gen内部 传入-3333333
// {value: undefined, done: true}
```

### 1.16.4 Generator多重回调-手动版本

```js
function ajax(url){
    return new Promise((resolve,reject)=>{
        let xhr = new XMLHttpRequest()
        xhr.open("get",url,true)
        xhr.send()
        xhr.onreadystatechange = function(){
            // xhr.readyState等于4 是执行完成
            if(xhr.readyState === 4){
                if(xhr.status>=200&&xhr.status<300){
                    resolve(JSON.parse(xhr.responseText) )
                }else{
                    reject(xhr.responseText)
                }
            }
        }
    })
}
function *gen(){
    let res = yield ajax("./json/1.json")
    console.log("第一个请求的结果",res);
    let res2 = yield ajax("./json/2.json",res)
    console.log("第二个请求的结果",res2);
}
let g = gen()
//  g.next().value 得到Promise对象
// 手动版本
g.next().value.then(data=>{
    g.next(data).value.then(res=>{
        g.next(res)
    })
})
```


### 1.6.5 Generator多重回调-自动版本

```js
function ajax(url) {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open("get", url, true);
        xhr.send();
        xhr.onreadystatechange = function () {
            // xhr.readyState等于4 是执行完成
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(xhr.responseText);
                }
            }
        };
    });
}
function *gen() {
    let res = yield ajax("./json/1.json");
    console.log("第一个请求的结果", res);
    let res2 = yield ajax("./json/2.json", res);
    console.log("第二个请求的结果", res2);
}
// let g = gen();
//  g.next().value 得到Promise对象
// 自动版本
// 公共函数  yield 后面必须跟Promise对象
function AutoRun(gen) {
    let g = gen();
    function next(data) {
        let res = g.next(data);
        if (res.done) return;
        res.value.then(function (data) {
            next(data);
        });
    }
    next();
}
AutoRun(gen)
```

## 1.17 Class语法

### 1.17.1 ES5模拟类


```js
// 对象的构造函数写法
function Person(name,age){
    this.name = name
    this.age = age
}

// 放在原型上
Person.prototype.say = function(){
    console.log(this.name,this.age);
}
let obj = new Person("kerwin",100)
console.log(obj);
```


### 1.17.2 ES6写法

```js
let r = Symbol("run");

class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    say() {
        console.log(this.name, this.age);
    }
    // 使用Symbol获取其他类型也可以作为方法名
    [r](){
        console.log(this.name + "跑的贼快！");
    }
}

let obj = new Person("kerwin", 100);
// console.log(obj);   /Person {name: 'kerwin', age: 100}

// Person的属性还是放到原型上
console.log(Person === Person.prototype.constructor); //true

console.log(obj.__proto__ === Person.prototype);    //true

obj[r]()    //kerwin跑的贼快！
```


### 1.17.3 get与set拦截

```js
class Person{
    constructor(name,age,location){
        this.name = name;
        this.age = age;
        this.location = location
    }
    // 只做拦截使用 并不返回
    get location(){
        console.log("get");
        // return location  无限循环
    }
    set location(data){
        console.log("set",data);
        // this.location = data 也是无限循环
    }
}

let obj = new Person("kerrwin",100,"dalian")

```

### 1.17.4 案例 - 通过拦截直接创建页面DOM

```js
class Person{
    constructor(name,age,id){
        this.name = name;
        this.age = age;
        this.ele = document.querySelector(`#${id}`)
    }
  
    get html(){
        return this.ele.innerHTML
    }
    set html(data){
        this.ele.innerHTML= data.map(item=>`<li>${item}</li>`).join("")
    }
}
let obj = new Person("kerrwin",100,"list")

obj.html = ["111","222","333"]
```

### 1.17.5 静态类与属性

```js
class Person {
    static myname = "peson类的名字"
    static mymethod =  function(){
        console.log("mymethod");
    }
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    say() {
        console.log(this.name, this.age);
    }
}
// 这里写的是大写
// 也可以使用下面这种方式
// Person.myname = "peson类的名字"
// Person.mymethod = function(){
//     console.log("mymethod");
// }

let obj = new Person("kerwin",100)

// 直接使用类访问
console.log(Person.myname);
console.log(Person.mymethod);

```

### 1.17.6 继承的基本使用

```js
class Person {
    static myname = "peson类的名字";
    static mymethod = function () {
        console.log("mymethod");
    };
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    say() {
        console.log(this.name, this.age);
    }
}
class Student extends Person {
    constructor(name, age, score) {
        super(name,age);
        this.score = score;
    }
    getScore(){
        console.log(this.score);
    }
    // 相同的方法
    say() {
        super.say()
        console.log(this.score);
    }
}

let obj = new Student("kerwin",100,150)
obj.say();  
// kerwin 100
// 150

// 静态的方法与属性也会继承
console.log(Student.myname);    // peson类的名字
console.log(Student.mymethod);  //f()
```

### 1.17.7 面向对象开发

```html
<div class="box1">
    <h1></h1>
    <ul></ul>
</div>
<div class="box2">
    <h1></h1>
    <img src="" style="width: 100px;">
    <ul></ul>
</div>
<script>
    var data1 = {
        title:"体育",
        list:["体育-1","体育-2","体育-3"]
    }
    var data2 = {
        title:"综艺",
        url:'./img/1.jpeg',
        list:["综艺-1","综艺-2","综艺-3"]
    }
    class CreteBox{
        constructor(select,data){
            this.ele = document.querySelector(select)
            this.title = data.title
            this.list= data.list
            //初始化后 立即执行render
            // this.render()
        }
        render(){
            let oh1 = this.ele.querySelector("h1")
            let oul = this.ele.querySelector("ul")
            oh1.innerHTML = this.title
            oul.innerHTML =  this.list.map(item =>{  
                return `<li>${item}</li>`
            }).join("")
        
        }
    }
    let cb = new CreteBox(".box1",data1)
    cb.render()
    class CreateImgBox extends CreteBox{
        
        constructor(select,data){
            super(select,data)
            this.imgUrl = data.url
            // this.render()
        }
        render(){
            super.render()
            let oimg = this.ele.querySelector("img")
            console.log(this.imgUrl);
            
            oimg.src = this.imgUrl
        }
    }
    let cib = new CreateImgBox(".box2",data2)
    cib.render()
</script>
```

## 1.19 模块化

JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。

CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export。

ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。



### 1.19.1  语法

1. 写法1：
```js
export default A1

import a1 from "./1.js"
```

2. 写法2：

```js
export {A1,A2}

import {A1,A2} from "./1.js"
import {A1 as a1,A2 as a2} from "./1.js"
import * as obj from "./1.js"
```


3. 混合写法：

```js
export {A1}
export default A2

import A2,{A1} from "./1.js"
```

### 1.19.2 综合案例


1. CreateBox.js

```js
export class CreateBox{
    constructor(select,data){
        this.ele = document.querySelector(select)
        this.title = data.title
        this.list= data.list
        //初始化后 立即执行render
        this.render()
    }
    render(){
        let oh1 = this.ele.querySelector("h1")
        let oul = this.ele.querySelector("ul")
        oh1.innerHTML = this.title
        oul.innerHTML =  this.list.map(item =>{  
            return `<li>${item}</li>`
        }).join("")
    
    }
}
```

2. CreateImgBox.js

```js
import { CreateBox } from "./CreateBox.js"
class CreateImgBox extends CreateBox{
            
    constructor(select,data){
        super(select,data)
        this.imgUrl = data.url
        this.render()
    }
    render(){
        super.render()
        let oimg = this.ele.querySelector("img")
        console.log(this.imgUrl);
        
        oimg.src = this.imgUrl
    }
}
export default CreateImgBox
```

3. 综合实战.html

```html
<div class="box1">
    <h1></h1>
    <ul></ul>
</div>
<div class="box2">
    <h1></h1>
    <img src="" style="width: 100px;">
    <ul></ul>
</div>

<script type="module">
    import {CreateBox} from './js-class/CreateBox.js'
    import CreateImgBox from './js-class/CreateImgBox.js'
    var data1 = {
        title:"体育",
        list:["体育-1","体育-2","体育-3"]
    }
    var data2 = {
        title:"综艺",
        url:'./img/1.jpeg',
        list:["综艺-1","综艺-2","综艺-3"]
    }
    new CreateBox(".box1",data1)
    new CreateImgBox(".box2",data2)
</script>
```

