# 四、跨域

## 4.1 同源策略

1. 什么是同源策略？

    同源策略是Web浏览器的一种安全机制，用于限制来自不同源的文档或脚本如何与另一个源的资源进行交互。

    这种策略有助于防止恶意网站读取另一个网站的敏感数据，例如用户的登录凭据或私人信息。通过确保只有来自相同源的脚本才能访问和操作DOM、发送AJAX请求或读取Cookie等，同源策略为Web应用程序提供了基本的安全保障。

2. 源（origin）

    1. 定义
        Web内容的源由用于访问它的URL的方案（协议）、主机名（域名）和端口定义。即源由协议、域名和端口组成。

2. 组成
    - 协议（Protocol）： 资源使用的传输协议，如http、https、ftp等。
    - 域名（Domain Name）： 资源的网络域名。例如example.com、other-example.com 这包括了主域名以及可能存在的子域名，如www.example.com和mail.example.com会被视为不同的子域名，除非特别配置为同源。
    - 端口（Port）： 资源服务器监听的端口号，如80（http默认端口）或443（https默认端口）。如果端口号没有显式指定，则浏览器会使用协议的默认端口。

3. 同源

    只有当两个资源的协议、域名和端口都完全相同时，它们才被认为是同源的。例如(下方URL均与http://example.com/dir/index.html比较)：


    | URL                                  | 是否同源 | 原因                 |
    |--------------------------------------|------|--------------------|
    | http://example.com/dir2/index.html   | 同源   | 只有路径不同，协议、域名和端口均相同 |
    | https://example.com/dir/index.html   | 不同源  | 协议不同               |
    | http://example.com:81/dir/index.html | 不同源  | 端口不同               |
    | http://example.org/dir/index.html    | 不同源  | 主机不同（域名不同）         |


## 4.2 如何解决跨域

### 4.2.1 JSONP

**jsonp只支持get请求不支持post请求**

1. **JSONP 是什么**

JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明
才智开发出来，只支持get 请求。

2. **JSONP 怎么工作的？**

在网页有一些标签天生具有跨域能力，比如：img link iframe script。
JSONP 就是利用script 标签的跨域能力来发送请求的。

3. **JSONP 的使用**

    - html中调用

    ```js
        //1. 创建 script 标签
        const script = document.createElement('script');
        //2. 设置标签的 src 属性
        script.src = 'http://127.0.0.1:8000/check-username?callback=abc';
        //3. 将script 添加到body 中
        document.body.appendChild(script);
        function abc(data) {
            alert(data.name);
        };
    ```

    - 服务器node.js代码

        ```js
        app.get("/check-username" , function (req , res) {
            var callback = req.query.callback;
            const data = {
                name: '孙悟空'
            };
            //将数据转化为字符串
            let str = JSON.stringify(data);
            //返回结果(一段可执行的JavaScript代码)
            response.end(`handle(${str})`);
        });
        ```

### 4.2.2 CORS(服务端设置)

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS

1. **CORS 是什么？**

   CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源

2. **CORS 怎么工作的？**
   CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。

3. **CORS 的使用**

   主要是服务器端的设置：

    ```js
    router.get("/testAJAX" , function (req , res) {
        //通过res 来设置响应头，来允许跨域请求
        //res.set("Access-Control-Allow-Origin","http://127.0.0.1:3000");
        res.set("Access-Control-Allow-Origin","*");//允许所有来源访问
        res.send("testAJAX 返回的响应");
    });
    ```


### 4.2.3 vue-cli跨域(开发阶段)

可以配置一个代理服务器来转发 API 请求，绕过浏览器的同源策略。vue中通过 Vue CLI 的代理，Vue CLI 提供了一个内置的开发服务器（基于 Webpack Dev Server），可以通过配置代理来解决开发环境中的跨域问题，在vue-cli搭建的项目中有一个配置文件vue.config.js,可以在该文件中进行相应的配置解决开发环境的跨域问题。

在 vue.config.js 文件中进行配置，示例如下：


```js
devServer: {
	// 1.指定服务的ip
	host: "192.168.0.128",
	// 2.指定服务的端口
	port: 3000,
	open: true,
	overlay: {
		warnings: false,
		errors: true
	},
	// 3.开发环境进行http的代理
	proxy: {
		// 匹配 url 路径的开头
		'/api': {
			// 1.路劲只要是/api开头的url都代理到下面这个网站。
			// 例如：'/api/xxxx' 会代理到 https://119.20.224.137/api/xxxx
			target: 'http://119.20.224.137:8201',
			changeOrigin: true,
			pathRewrite: { '^/api': '/api/' }
		}
	}
}
```

### 4.2.4 nginx跨域(部署阶段)

在 NGINX 中，可以通过添加 Access-Control-Allow-* 响应头来解决跨域问题。以下是一个常见的配置方法：

```yml
server {
    listen 80;
    server_name your_domain.com;
 
    location / {
        # 允许的来源（如前端域名），* 表示允许所有来源
        add_header 'Access-Control-Allow-Origin' '*' always;
        # 允许的请求方法
        add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
        # 允许的请求头
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
        # 允许携带凭证（如 Cookies）
        add_header 'Access-Control-Allow-Credentials' 'true' always;
        # 预检请求（OPTIONS）的缓存时间
        add_header 'Access-Control-Max-Age' 1728000 always;
 
        # 处理 OPTIONS 预检请求
        if ($request_method = 'OPTIONS') {
            return 204;
        }
 
        # 你的其他配置，如 proxy_pass 或 root
        # 示例：反向代理到后端
        proxy_pass http://backend_server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```