# 二、Promise的对象方法

## 2.1 promise对象.then() 

1. 作用

    - promise对象.then() 用于处理 Promise 的成功状态（fulfilled），可以接收两个参数：
        - 第一个参数：处理成功的回调函数
        - 第二个参数（可选）：处理失败的回调函数（通常更推荐使用 .catch()）

2. 示例

    ```js
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('操作成功！');
            // 或者 reject('操作失败！');
        }, 1000);
    });

    promise.then((value) => {
        console.log('成功:', value); // 成功时执行
    },(error) => {
        console.error('失败:', error); // 失败时执行（不推荐这样写）
    });
    ```

## 2.2 promise对象.catch() 

1. 作用

    - promise对象.catch() 专门用于捕获 Promise 链中的错误。

2. 错误捕获特点
    - 会捕获前面所有 .then() 中的错误
    - 返回新 Promise，可以继续链式调用
    - 如果没有 .catch()，错误会静默失败（建议总是添加）

3. 示例

    ```js
    Promise.reject('出错了！')
    .catch(error => {
        console.error('捕获到错误:', error); // 捕获到错误: 出错了！
        return '默认值';
    })
    .then(value => {
        console.log('继续执行:', value); // 继续执行: 默认值
    });
    ```

## 2.3 promise对象.finally() 

1. 作用
    - promise对象.finally() 无论 Promise 最终状态如何都会执行，常用于清理工作（如关闭加载状态、清理资源等）。
2. 错误捕获特点

    - 不接收任何参数（不知道 Promise 的最终状态）
    - 返回的 Promise 会继承原 Promise 的状态

3. 代码示例

    - 发起请求

        ```js
        let isLoading = true;

        fetch('https://api.example.com/data')
        .then(response => response.json())
        .then(data => {
            console.log('数据:', data);
        }).catch(error => {
            console.error('请求失败:', error);
        }).finally(() => {
            isLoading = false;
            console.log('请求结束，清理状态');
        });
        ```

    - 处理loading

        ```js
        function simulateAsyncTask(success) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (success) {
                        resolve('任务成功完成');
                    } else {
                        reject(new Error('任务失败'));
                    }
                }, 1000);
            });
        }

        // 使用示例
        simulateAsyncTask(true).then(result => {
            console.log('结果:', result);
            return '额外处理';
        }).then(extra => {
            console.log('额外:', extra);
        }).catch(error => {
            console.error('错误:', error.message);
        }).finally(() => {
            console.log('异步操作结束（无论成功/失败）');
        });
        ```


## 2.4 链式调用

1. 基础使用

    ```js
    var p = new Promise((resolve,reject)=>{
        setTimeout(() => {
            resolve("data")
        }, 1000);
    })


    // 1. 结果 then传给catch 
    // 2. 传给 then 
    // 3. fainlly 结束
    var p1 = p.then(res=>{
        console.log(res);
        // 默认就是 return undefine,fulfilled

        // 直接使用转换成rejected 状态 还是会走 catch
        return Promise.reject("error-1111")
    }).catch(err=>{
        console.log(err);
        return Promise.resolve("data-2222")
    }).then(res=>{
            console.log(res);
    }).finally(()=>{
        console.log("结束");
    });
    ```

2. 实际使用

    ```js
    function ajax(url){
        return new Promise((resolve,reject)=>{
            var xhr = new XMLHttpRequest();
            xhr.open("get",url,true)
            xhr.send()
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    if(xhr.status>=200 && xhr.status <300){
                        // 成功
                        resolve(JSON.parse(xhr.responseText))
                    }else{
                        // 失败
                        reject(xhr.responseText)
                    }
                }
            }
        })
    }

    var name = "kerwin"

    ajax(`http://localhost:3000/news?author=${name}`).then(res=>{
        console.log(res[0].id);

        // 不能直接返回Promise对象 会一直处于pending 状态
        // return new Promise(()=>{})

        return (`http://localhost:3000/comments?newsId=${res[0].id}`)
    }).then(res=>{
        console.log("111",res);
    })
    ```
