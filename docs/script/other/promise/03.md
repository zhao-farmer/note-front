# 三、promise的类方法/静态方法

## 3.1 `Promise.resolve()`

1. 你预知状态的结果为fulfilled，则可以用这种简写方式

    ```js
    Promise.resolve('hello').then(res => console.log(res))//hello
    // 等价于
    const p = new Promise((resolve, reject) => resolve('hello'))
    p.then(res => console.log(res))//hello
    ```
2. 实际使用-缓存数据

    ```js
    function ajax(url){

        // if(缓存){
        //     return 缓存的数据
        // }
        var cache = ajax.cache || (ajax.cache = {data:null});
        if(cache.data){
            console.log("走缓存");
            // 使用Promise对象进行转换
            return Promise.resolve(cache.data);
        }

        return new Promise((resolve,reject)=>{
            var xhr = new XMLHttpRequest();
            xhr.open("get",url,true)
            xhr.send()
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    if(xhr.status>=200 && xhr.status <300){
                        console.log("不走缓存");
                        // 成功
                        resolve(JSON.parse(xhr.responseText))
                        // 缓存数据
                        ajax.cache.data = JSON.parse(xhr.responseText)
                    }else{
                        // 失败
                        reject(xhr.responseText)
                    }
                }
            }
        })
    }

    let file = "1.json"
    let url = "https://api.kuleu.com/api/MP4_xiaojiejie?type=json"

    function getInfo(){
        ajax(url).then(res=>{
            console.log("success",res);
        }).catch(err=>{
            console.log("err",err);
        })
    }

    setInterval(() => {
        getInfo()
    }, 2000);

    ```

## 3.2 `Promise.reject()`

1. 你预知状态的结果为rejected，则可以用这种简写方式

    ```js
    Promise.reject('hello').catch(err => console.log(err))/hello
    // 等价于
    const p = new Promise((resolve, reject) => reject('hello'))//hello
    p.catch(err => console.log(err))
    ```

2. 实际使用-判断参数

    ```js
    function ajax(url){
        console.log(typeof url);
        
        // 判断参数
        if(typeof url !== "string"){
            new Promise.reject("参数类型必须是字符串")
        }
        
        // 取缓存
        var cache = ajax.cache || (ajax.cache = {data:null});
        if(cache.data){
            console.log("走缓存");
            // 使用Promise对象进行转换
            return Promise.resolve(cache.data);
        }

        return new Promise((resolve,reject)=>{
            var xhr = new XMLHttpRequest();
            xhr.open("get",url,true)
            xhr.send()
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    if(xhr.status>=200 && xhr.status <300){
                        console.log("不走缓存");
                        // 成功
                        resolve(JSON.parse(xhr.responseText))
                        // 缓存数据
                        ajax.cache.data = JSON.parse(xhr.responseText)
                    }else{
                        // 失败
                        reject(xhr.responseText)
                    }
                }
            }
        })
    }

    let file = "1.json"
    let url = "https://api.kuleu.com/api/MP4_xiaojiejie?type=json"

    function getInfo(params){
        ajax(params).then(res=>{
            console.log("success",res);
        }).catch(err=>{
            console.log("err",err);
        })
    }

    let index = 0;
    setInterval(() => {
        index++;
        if(index%2 === 0){
            getInfo(url)
        }else{
            getInfo(20)
        }
    }, 2000);
    ```
3. 让catch再次执行

    ```js
    // 让catch再次执行
    var p = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("data");
        }, 1000);
    });

    p.then(res => {
        console.log(res);

        if (res) {
            console.log("渲染页面函数调用");
        } else {
            // 两种方式
            return Promise.reject("error");
            // throw new Error("kerwin == error");
        }
    }).catch(err => {
        console.log(err);
    });
    ```

## 3.3 `Promise.all()`


1. `Promise.all()`作用

    - `Promise.a11()` 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。

        ```js
        const p = Promise.all([p1，p2，p3]);
        ```

        - p的状态由p1,p2,p3 决定，分成两种情况。
            1. 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
            2. 只要p1、p2、p3之中有一个被 rejected，p的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给p的回调函数。

2. 实际使用

    ```js
    function ajax(url){
        return new Promise((resolve,reject)=>{
            var xhr = new XMLHttpRequest();
            xhr.open("get",url,true)
            xhr.send()
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    if(xhr.status>=200 && xhr.status <300){
                        // 成功
                        resolve(JSON.parse(xhr.responseText))
                    }else{
                        // 失败
                        reject(xhr.responseText)
                    }
                }
            }
        })
    }

    var list = ["kerwin","tiechui"]

    function getData(list){
        var newList = list.map(item=>ajax(`http://localhost:3000/news?author=${item}`))
        return Promise.all(newList)
    }

    // 直接获取多个查询
    getData(list).then(res=>{
        console.log(res);
    })
    ```

## 3.4 `Promise.race()`

1. `Promise.race()`作用

    - `Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

        ```js
        const p = Promise.race([p1，p2，p3]);
        ```

        上面代码中，只要 p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise实例的返回值，就传递给p的回调函数。

2. 实际使用

    ```js
    function ajax(url){
        return new Promise((resolve,reject)=>{
            var xhr = new XMLHttpRequest();
            xhr.open("get",url,true)
            xhr.send()
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    if(xhr.status>=200 && xhr.status <300){
                        // 成功
                        resolve(JSON.parse(xhr.responseText))
                    }else{
                        // 失败
                        reject(xhr.responseText)
                    }
                }
            }
        })
    }

    var p1 = ajax("https://api.kuleu.com/api/MP4_xiaojiejie?type=json")

    var p2 = new Promise((resolve,reject)=>{
        setTimeout(() => {
            reject("超时")
        }, 2000);
    })

    // 判断网络请求是否超时
    Promise.race([p1,p2]).then(res=>{
        console.log(res);
    }).catch(err=>{
        console.log(err);
    })
    ```

## 3.5 Promise.addSetted()

1. `Promise.addSetted()` 作用

    `Promise.a11sett1ed()`方法，用来确定一组异步操作是否都结束了(不管成功或失败)。所以，它的名字叫做"Settled"，包含了"fulfilled"和"rejected“两种情况。

    ```js
    const promises=[ ajax('/200接口')，ajax('/401接口')];
    Promise.a11settled(promises).then(results=>{
        // 过滤出成功的请求
        results.filter(item =>item.status === 'fulfilled');
        // 过滤出失败的请求
        results,filter(item=> item.status === 'rejected');
    })
    ```
2. 实际使用

    ```js
    const promiseOne = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("hello 张三");
        }, 1000);
    });

    const promiseTwo = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("hello 李四");
        }, 2000);
    });

    const promiseThree = new Promise((resolve, reject) => {
        setTimeout(() => {

        }, 3000);
    });
    Promise.allSettled([promiseOne, promiseTwo, promiseThree]).then(
        res => console.log(res)
    );
    // 如果没有调用resolve()或者reject()，该promise就无法得到一个结果，其中一个没有结果，则什么都不会打印。
    // 其中一个promise没有结果，则什么都不打印
    ```

## 3.6 Promise.any()


1. `Promise.any()` 作用

    - 只要参数实例有一个变成fulfilled状态，包装实例就会变成 fulfilled 状态;如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。
    - `Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是`Promise.any()`不会因为某个Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。

2. 实际应用

    ```js
    // 联合会员
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("山姆");
        }, 1000);
    });

    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("华润");
        }, 2000);
    });

    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("盒马")
        }, 3000);
    });
    // 如进入三家平台
    Promise.any([p1, p2, p3]).then( res =>{
        console.log(res)
        // 跳转到主页
    }).catch(err=>{
        console.log("error");
    });
    ```
## 3.7 Promise.try()

- 作用：统一处理同步/异步函数，自动捕获同步错误并返回 Promise。
- 适用场景：避免同步错误逃逸，统一 Promise 链式调用。

```js
// 同步函数
Promise.try(() => 'Sync Value')
  .then(console.log); // 'Sync Value'

// 异步函数
Promise.try(() => fetch('https://api.example.com'))
  .then(res => res.json())
  .catch(console.error);

// 同步错误捕获
Promise.try(() => { throw new Error('Boom!'); })
  .catch(err => console.error(err.message)); // 'Boom!'
  
```

## 3.8 Promise.withResolvers()

- 作用：返回一个包含 promise、resolve、reject 的对象，适用于手动控制 Promise。
- 适用场景：需要在外部控制 Promise 的解析/拒绝。

```js
const { promise, resolve, reject } = Promise.withResolvers();

setTimeout(() => resolve('Done!'), 1000);

promise.then(console.log); // 1秒后输出 'Done!'
```