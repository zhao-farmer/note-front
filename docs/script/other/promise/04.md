# 四、promise其他

## 4.1 封装ajax


1. ajax 函数

    ```js
    //如果data传入的是json格式，而header设置的是form表单编码
    //我们就需要将json字符串进行转换。
    function queryStringify(obj) {
        let str = ''
        for (let k in obj) str += `${k}=${obj[k]}&`
        //username=kerwin&password=789&
        return str.slice(0, -1)
    }

    // 封装 ajax
    function ajax(options) {
        //设置一个options默认值，在我们不传递参数的时候默认是get提交
        let defaultoptions = {
            url: "",
            method: "GET",
            async: true,
            data: {},
            headers: {
                "content-type": "application/x-www-form-urlencoded"
            },
            success: function () { },
            error: function () { }
        }
        // 进行解构赋值
        let { url, method, async, data, headers, success, error } = {
            //展开运算符
            ...defaultoptions,
            ...options
        }
        //判断headers的值是否为json
        if (typeof data === 'object' && headers["content-type"]?.indexOf("json") > -1) {
            data = JSON.stringify(data)
        }
        else {
            data = queryStringify(data)
        }
        // // 如果是 get 请求, 并且有参数, 那么直接组装一下 url 信息
        if (/^get$/i.test(method) && data) url += '?' + data

        // // 4. 发送请求
        const xhr = new XMLHttpRequest()
        xhr.open(method, url, async)
        xhr.onload = function () {
            if (!/^2\d{2}$/.test(xhr.status)) {
                // console.log(error)
                error(`错误状态码:${xhr.status}`) //回调
                return
            }

            // 执行解析
            try {
                let result = JSON.parse(xhr.responseText)
                success(result)
            } catch (err) {
                error('解析失败 ! 因为后端返回的结果不是 json 格式字符串')
            }
        }


        // // 设置请求头内的信息
        for (let k in headers) xhr.setRequestHeader(k, headers[k])
        //判断method是不是get
        if (/^get$/i.test(method)) {
            xhr.send()
        } else {
            xhr.send(data)
        }
    }
    ```

2. 使用 promise 进行封装

    ```js
    function pajax(options){
        //返回一个promise对象
        return  new Promise((resolve,reject) => {
            ajax({
                ...options,
                success(res){
                    resolve(res)
                },
                error(err){
                    reject(err)
                }
            })
        })
    }
    ```

## 4.2 手写promise

```js
function MyPromise(executor) {
    this.status = "pending";
    this.result = undefined;
    this.cb = []
    var _this = this;

    function resolve(res) {
        if (_this.status !== "pending") return;
        // console.log(_this)
        _this.status = "fulfilled"
        _this.result = res;
        _this.cb.forEach(item => {
            item.successCB && item.successCB(_this.result)
        });
    }

    function reject(res) {
        if (_this.status !== "pending") return;
        // console.log("reject")
        _this.status = "rejected"
        _this.result = res;
        _this.cb.forEach(item => {
            item.failCB && item.failCB(_this.result)
        });
    }
    executor(resolve, reject)
}

MyPromise.prototype.then = function (successCB, failCB) {

    if(!successCB){
        successCB = value=>value
    }
    if(!failCB){
        failCB = error=>error
    }

    // successCB()
    return new MyPromise((resolve, reject) => {
        if (this.status === "fulfilled") {
            var result = successCB && successCB(this.result)
            // console.log(result);

            if (result instanceof MyPromise) {
                result.then(res => {
                    // console.log(res)
                    resolve(res);
                }, err => {
                    // console.log(err)
                    reject(err)
                })
            } else {
                resolve(result);
            }
        }
        if (this.status === "rejected") {
            var result = failCB && failCB(this.result)

            if (result instanceof MyPromise) {
                result.then(res => {
                    // console.log(res)
                    resolve(res);
                }, err => {
                    // console.log(err)
                    reject(err)
                })
            } else {
                reject(result);
            }
        }

        if (this.status === "pending") {
            //收集回调
            this.cb.push({
                successCB: () => {
                    var result = successCB && successCB(this.result)

                    if (result instanceof MyPromise) {
                        result.then(res => {
                            // console.log(res)
                            resolve(res);
                        }, err => {
                            // console.log(err)
                            reject(err)
                        })
                    } else {
                        resolve(result);
                    }
                },
                failCB: () => {
                    var result = failCB && failCB(this.result)
                    if (result instanceof MyPromise) {
                        result.then(res => {
                            // console.log(res)
                            resolve(res);
                        }, err => {
                            // console.log(err)
                            reject(err)
                        })
                    } else {
                        reject(result);
                    }
                }
            })
        }
    })
}

MyPromise.prototype.catch= function(failCB){
    this.then(undefined,failCB)
}
```