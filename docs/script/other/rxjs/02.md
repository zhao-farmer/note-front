# 二、操作符

## 2.1 准备工作

1. 由于操作符含有url调用，使用json-server直接创建接口

    - db.json数据

        ```json
        {
            "posts":[
                {"name":"电脑","price":5000},
                {"name":"洗衣机","price":800},
                {"name":"冰箱","price":1000}
            ],
            "users":[
                {"username":"张三","age":18},
                {"username":"李四","age":20},
                {"username":"王五","age":32},
                {"username":"赵六","age":12}
            ]
        }
        ```
    - 使用json-server

        ```sh
        # 安装
        npm i json-server -g
        # 启动接口
        json-server db.json
        ```
2. 安装 rxjs

    ```sh
    npm install rxjs
    ```

## 2.2 创建操作符

RxJS 提供了多种 创建操作符（Creation Operators） 用于生成 Observable 流。

1. `of`

    - **作用**：创建一个 `Observable`，依次发出给定的值，然后完成。  
    - **适用场景**：同步发送一组固定值。

    ```js
    import { of } from 'rxjs';

    of(1, 2, 3).subscribe({
        next: value => console.log(value),
        complete: () => console.log('完成'),
    });

    // 输出：
    // 1
    // 2
    // 3
    // 完成
    ```

2. `from`

    - **作用**：从数组、Promise、迭代器或类数组对象创建 `Observable`。  
    - **适用场景**：转换其他数据结构为 `Observable`。

    -  **从数组**

        ```javascript
        import { from } from 'rxjs';

        from([1, 2, 3]).subscribe(console.log);
        // 输出：1, 2, 3
        ```

    - **从 Promise**


        ```javascript
        const promise = Promise.resolve('Hello RxJS');
        from(promise).subscribe(console.log);
        // 输出：Hello RxJS
        ```

    - **从字符串（逐字符发出）**

        ```javascript
        from('RxJS').subscribe(console.log);
        // 输出：R, x, J, S
        ```

3. `interval`

    - **作用**：每隔指定时间（毫秒）发出一个递增的数字（从 0 开始）。  
    - **适用场景**：定时轮询、周期性任务。

    ```javascript
    import { interval } from 'rxjs';

    interval(1000).subscribe(num => console.log(`当前计数: ${num}`));
    // 输出：
    // 当前计数: 0（1秒后）
    // 当前计数: 1（2秒后）
    // ...
    ```

4. `timer`

    - **作用**：
        *   单参数形式：延迟指定时间后发出 `0`，然后完成。  
        *   双参数形式：延迟后开始按间隔发出递增数字（类似 `interval`）。
    - **适用场景**：延迟执行、周期性延迟任务。

    -  **单参数（延迟执行）**

        ```javascript
        import { timer } from 'rxjs';

        timer(2000).subscribe(() => console.log('2秒后执行'));
        // 输出：（2秒后）2秒后执行
        ```

    -  **双参数（延迟 + 间隔）**

        ```javascript
        timer(1000, 2000).subscribe(num => console.log(`第 ${num} 次执行`));
        // 输出：
        // 第 0 次执行（1秒后）
        // 第 1 次执行（再等2秒）
        // ...
        ```

5. `fromEvent`

    - **作用**：将 DOM 事件或 Node.js 的 `EventEmitter` 转换为 `Observable`。  
    - **适用场景**：监听用户交互（点击、输入等）。

    ```html
    <script src="../node_modules/rxjs/dist/bundles/rxjs.umd.js"></script>
    <script>
        const { fromEvent } =  rxjs;

        const button = document.getElementById('myButton');
        fromEvent(button, 'click').subscribe(() => console.log('按钮被点击'));
    </script>
    ```
        
6. `ajax`

    - **作用**：发送 HTTP 请求并返回 `Observable`（浏览器环境）。  
    - **适用场景**：替代 `fetch` 或 `axios`。

    ```html
    <script src="../node_modules/rxjs/dist/bundles/rxjs.umd.js"></script>
    <script>
        const { ajax } = rxjs.ajax;

        const apiUrl = "http://localhost:3000/users";

        // 1. get请求
        ajax.getJSON(apiUrl).subscribe({
            next: data => console.log("get成功:", data),
            error: err => console.error("get失败:", err),
            complete: () => console.log("get请求完成"),
        });

        // 2. 使用完整的 ajax() 方法
        ajax({
            url: apiUrl,
            method: "GET",
        }).subscribe(res => console.log(res.response));

        
        // 3. post请求与header
        ajax({
            url: apiUrl,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                username: "敏敏",
                age:10,
            }),
        }).subscribe({
            next: res => console.log("post创建成功:", res.response),
            error: err => console.error("post创建失败:", err),
        });
    </script>
    ```


7. `EMPTY` / `NEVER`

    *   **`EMPTY`：立即完成，不发出任何值。
    *   **`NEVER`：不发出值，也不完成或报错。

    ```javascript
    import { EMPTY, NEVER } from 'rxjs';

    EMPTY.subscribe({
        next: () => console.log('不会执行'),
        complete: () => console.log('立即完成'),
    });

    NEVER.subscribe(() => console.log('永远不会执行'));
    ```

8. `throwError`(已过时)

    - **作用**：创建一个直接抛出错误的 `Observable`。  
    - **适用场景**：模拟错误或异常处理。

    ```javascript
    import { throwError } from 'rxjs';

    throwError('发生错误').subscribe({
        error: err => console.error(err),
    });
    // 输出：发生错误
    ```

9. `range`

    - **作用**：发出一个范围内的数字序列。  
    - **适用场景**：生成连续数字。

    ```javascript
    import { range } from 'rxjs';

    range(5, 3).subscribe(console.log); // 从5开始，发出3个数字
    // 输出：5, 6, 7
    ```


10. `defer`

    - **作用**：延迟创建 `Observable`，直到被订阅。  
    - **适用场景**：动态生成 `Observable`（如基于当前时间的流）。

    ```javascript
    import { defer, of } from 'rxjs';

    const random$ = defer(() => of(Math.random()));
    random$.subscribe(console.log); // 每次订阅生成新的随机数
    ```


11. **总结**

    | 操作符 | 作用  | 示例场景 |
    | --- | --- | --- |
    | `of` | 同步发出固定值 | `of(1, 2, 3)` |
    | `from` | 从数组/Promise/字符串转换 | `from([1, 2, 3])` |
    | `interval` | 定时递增数字 | `interval(1000)` |
    | `timer` | 延迟执行或周期性延迟任务 | `timer(2000, 1000)` |
    | `fromEvent` | 监听 DOM/Node.js 事件 | `fromEvent(button, 'click')` |
    | `ajax` | 发送 HTTP 请求 | `ajax.getJSON(url)` |
    | `empty` | 立即完成 | `empty()` |
    | `throwError` | 抛出错误 | `throwError('error')` |
    | `range` | 生成数字序列 | `range(1, 5)` |
    | `defer` | 延迟创建 Observable | `defer(() => of(...))` |


## 2.3 组合操作符


1. `combineLatest`

    - **作用**：当任意一个输入 `Observable` 发出新值时，取所有 `Observable` 的最新值组合成一个数组发出。  
    - **适用场景**：多个数据流需要实时联动（如表单联动校验）。

    ```javascript
    import { combineLatest, interval } from 'rxjs';
    import { take } from 'rxjs/operators';

    const timer1$ = interval(1000).pipe(take(3)); // 0, 1, 2（每秒一次）
    const timer2$ = interval(1500).pipe(take(2)); // 0, 1（每1.5秒一次）

    combineLatest([timer1$, timer2$]).subscribe(console.log);

    // 输出：
    // [1, 0] （timer1$ 发出 1 时，timer2$ 最新值是 0）
    // [2, 0] （timer1$ 发出 2 时，timer2$ 仍是 0）
    // [2, 1] （timer2$ 发出 1 时，timer1$ 最新值是 2）
    ```

2. `merge`

    - **作用**：合并多个 `Observable`，按时间顺序发出所有值。  
    - **适用场景**：并行处理多个事件流（如同时监听点击和键盘事件）。

    ```javascript
    import { merge, interval, fromEvent } from 'rxjs';
    import { take } from 'rxjs/operators';

    const clicks$ = fromEvent(document, 'click');
    const timer$ = interval(1000).pipe(take(3));

    merge(clicks$, timer$).subscribe(event => {
        console.log(event instanceof MouseEvent ? '点击事件' : `计时器: ${event}`);
    });

    // 输出：
    // 计时器: 0（1秒后）
    // 点击事件（如果用户点击）
    // 计时器: 1（2秒后）
    // ...
    ```

3. `concat`

    - **作用**：按顺序连接多个 `Observable`，前一个完成后再订阅下一个。  
    - **适用场景**：顺序执行异步任务（如按步骤上传文件）。

    ```javascript
    import { concat, of } from 'rxjs';

    const first$ = of('第一步');
    const second$ = of('第二步');

    concat(first$, second$).subscribe(console.log);

    // 输出：
    // 第一步
    // 第二步
    ```

4. `forkJoin`

    - **作用**：等待所有 `Observable` 完成，然后合并它们的最后一个值。  
    - **适用场景**：并行请求并等待所有结果（类似 `Promise.all`）。

    ```html
    <script src="../node_modules/rxjs/dist/bundles/rxjs.umd.js"></script>
    <script>
        const { ajax } = rxjs.ajax
        const { forkJoin} = rxjs;
        // 用户
        const api1$ = ajax.getJSON("http://localhost:3000/users");
        
        // 商品
        const api2$ = ajax.getJSON("http://localhost:3000/posts");

        forkJoin(api1$, api2$).subscribe({
            next: ([user, posts]) => console.log('用户和商品:', user, posts),
            error: err => console.error("请求失败:", err),
            
        });
        // 输出（当两个请求都完成时）：
        // 用户和商品: object object
    </script>
    ```

5. `zip`

    - **作用**：严格按顺序组合多个 `Observable` 的值（一一对应）。  
    - **适用场景**：需要精确对齐多个流的数据（如配对用户和订单）。

    ```javascript
    import { zip, of } from 'rxjs';

    const age$ = of(25, 30, 35);
    const name$ = of('Alice', 'Bob');

    zip(age$, name$).subscribe(console.log);

    // 输出：
    // [25, 'Alice']
    // [30, 'Bob']
    // （35 被忽略，因为 name$ 没有第三个值）
    ```

6. `combineLatestAll`

    - **作用**：将高阶 `Observable`（如 `Observable<Observable<T>>`）转换为组合后的低阶 `Observable`。  
    - **适用场景**：动态生成的 `Observable` 需要合并。

    ```javascript
    import { interval, map, take, combineLatestAll } from 'rxjs';

    const source$ = interval(1000).pipe(
        take(2),
        map(i => interval(1000).pipe(
            take(3),
            map(j => `源${i}: 值${j}`)
        ))
    );

    source$.pipe(combineLatestAll()).subscribe(console.log);

    // 输出：
    // ['源0: 值0', '源1: 值0']
    // ['源0: 值1', '源1: 值0']
    // ['源0: 值1', '源1: 值1']
    // ...
    ```

7. `withLatestFrom`

    - **作用**：当主 `Observable` 发出值时，取另一个 `Observable` 的最新值组合发出。  
    - **适用场景**：主事件触发时附带额外状态（如点击按钮时获取当前输入框的值）。

    ```html
    <script src="../node_modules/rxjs/dist/bundles/rxjs.umd.js"></script>
    <script>
        const { fromEvent, interval } = rxjs;
        const { withLatestFrom } = rxjs.operators;

        const clicks$ = fromEvent(document, 'click');
        const timer$ = interval(1000);

        clicks$.pipe(withLatestFrom(timer$)).subscribe({
            next: ([clickEvent, timerValue]) => {
                console.log(`点击时计时器值: ${timerValue}`);
            }
        });

        // 输出（假设在第3秒点击）：
        // 点击时计时器值: 2
    </script>
    ```

8. **总结**

    | 操作符 | 作用  | 示例场景 |
    | --- | --- | --- |
    | `combineLatest` | 任意流更新时合并最新值 | 表单联动校验 |
    | `merge` | 并行合并所有流的值 | 同时监听点击和定时事件 |
    | `concat` | 顺序连接流（前一个完成再下一个） | 分步上传文件 |
    | `forkJoin` | 等待所有流完成并合并最后结果 | 并行请求多个 API |
    | `zip` | 严格按顺序一一配对值 | 配对用户和订单数据 |
    | `combineAll` | 合并高阶 Observable 的内部流 | 动态生成的流组合 |
    | `withLatestFrom` | 主流触发时附带其他流的最新值 | 点击按钮时获取输入框值 |


## 2.4 转换操作符

 **转换操作符（Transformation Operators）** 用于对 `Observable` 发出的数据进行转换、映射或处理。

1. `map`

    - **作用**：对每个发出的值应用函数，转换成新值。  
    - **适用场景**：数据格式转换（如提取对象字段、数学计算）。

    ```javascript
    import { of } from 'rxjs';
    import { map } from 'rxjs/operators';

    of(1, 2, 3)
        .pipe(map(x => x * 2))
        .subscribe(console.log);

    // 输出：
    // 2
    // 4
    // 6
    ```

2. `pluck`（已弃用，推荐使用 `map`）

    - **作用**：提取对象中的指定属性（类似 `map` 的简化版）。  
    - **替代方案**：直接用 `map` + 解构。

    ```javascript
    import { of } from 'rxjs';
    import { map } from 'rxjs/operators';

    of({ name: 'Alice', age: 25 }, { name: 'Bob', age: 30 })
        .pipe(map(user => user.name))
        .subscribe(console.log);

    // 输出：
    // 'Alice'
    // 'Bob'
    ```

3. `scan`

    - **作用**：类似数组的 `reduce`，对累积值和当前值应用函数，逐步发出结果。  
    - **适用场景**：状态累积（如计数器、购物车总价）。

    ```javascript
    import { of } from 'rxjs';
    import { scan } from 'rxjs/operators';

    of(1, 2, 3)
    .pipe(scan((acc, curr) => acc + curr, 0))
    .subscribe(console.log);

    // 输出：
    // 1 (0 + 1)
    // 3 (1 + 2)
    // 6 (3 + 3)
    ```



4. `switchMap`

    - **作用**：切换到新 `Observable`，取消前一个未完成的内部订阅。  
    - **适用场景**：搜索框输入防抖后发起请求（避免旧请求干扰）。

    ```javascript
    import { fromEvent, interval } from 'rxjs';
    import { switchMap } from 'rxjs/operators';

    const button = document.getElementById('btn');
    fromEvent(button, 'click').pipe(
        switchMap(() => interval(1000)) // 每次点击重新开始计时
    ).subscribe(console.log);

    // 点击按钮后输出：
    // 0（1秒后）
    // 1（2秒后）
    // 如果再次点击，重新从0开始
    ```

5. `mergeMap`（别名 `flatMap`）

    - **作用**：并行处理多个内部 `Observable`，保留所有订阅。  
    - **适用场景**：并发请求（如批量上传文件）。

    ```javascript
    import { of,interval,take,map } from 'rxjs';
    import { mergeMap } from 'rxjs/operators';

    of('a', 'b', 'c').pipe(
        mergeMap(char => interval(1000).pipe(
            take(2),
            map(i => `${char}${i}`)
        ))
    ).subscribe(console.log);


    // 输出（每秒交错输出）：
    // 'a0', 'b0', 'c0'（第1秒）
    // 'a1', 'b1', 'c1'（第2秒）
    ```

6. `concatMap`

    - **作用**：顺序处理内部 `Observable`，前一个完成后再处理下一个。  
    - **适用场景**：顺序执行异步任务（如按顺序保存数据）。

    ```javascript
    import { of } from 'rxjs';
    import { concatMap, delay } from 'rxjs/operators';

    of('任务1', '任务2', '任务3').pipe(
        concatMap(task => of(`完成: ${task}`).pipe(delay(1000)))
    ).subscribe(console.log);

    // 输出（每秒一个）：
    // '完成: 任务1'（1秒后）
    // '完成: 任务2'（2秒后）
    // '完成: 任务3'（3秒后）
    ```


7. `exhaustMap`

    - **作用**：忽略新值直到当前内部 `Observable` 完成。  
    - **适用场景**：防止重复提交（如保存按钮连续点击）。

    ```javascript
    import { fromEvent, interval } from 'rxjs';
    import { exhaustMap, take } from 'rxjs/operators';

    const button = document.getElementById('btn');
    fromEvent(button, 'click').pipe(
        exhaustMap(() => interval(1000).pipe(take(3)))
    ).subscribe(console.log);

    // 第一次点击输出：0, 1, 2
    // 在3秒内再次点击会被忽略
    ```

8. `buffer` / `bufferTime`

    - **作用**：
        *   `buffer`：收集值直到另一个 `Observable` 发出信号。
        *   `bufferTime`：按时间窗口收集值。  
            
            **适用场景**：批量处理数据（如日志批量上报）。

    - `buffer`

        ```javascript
        import { interval, fromEvent } from 'rxjs';
        import { buffer } from 'rxjs/operators';

        const clicks$ = fromEvent(document, 'click');
        interval(1000).pipe(buffer(clicks$))
        .subscribe(console.log);

        // 输出（点击时打印间隔期间的所有值）：
        // [0, 1]（如果在第2秒点击）
        ```

    - `bufferTime`

        ```javascript
        import { interval } from 'rxjs';
        import { bufferTime } from 'rxjs/operators';

        interval(1000).pipe(bufferTime(3000))
        .subscribe(console.log);

        // 输出（每3秒一组）：
        // [0, 1, 2]（第3秒）
        // [3, 4, 5]（第6秒）
        ```

9. `toArray`

    - **作用**：将所有发出的值收集为数组，在流完成时一次性发出。  
    - **适用场景**：聚合流的所有结果（如计算总和）。

    ```javascript
    import { of } from 'rxjs';
    import { toArray } from 'rxjs/operators';

    of(1, 2, 3).pipe(toArray())
    .subscribe(console.log);

    // 输出：
    // [1, 2, 3]
    ```

10. **总结**

    | 操作符 | 作用  | 示例场景 |
    | --- | --- | --- |
    | `map` | 一对一转换值 | 数据格式化 |
    | `scan` | 累积值并逐步发出 | 计数器、购物车总价 |
    | `switchMap` | 取消旧订阅，切换到新流 | 搜索框防抖请求 |
    | `mergeMap` | 并行处理多个内部流 | 批量上传文件 |
    | `concatMap` | 顺序处理内部流 | 按步骤保存数据 |
    | `exhaustMap` | 忽略新值直到当前流完成 | 防止重复提交 |
    | `bufferTime` | 按时间窗口收集值 | 日志批量上报 |
    | `toArray` | 收集所有值为数组 | 聚合结果 |



## 2.5 过滤操作符

过滤操作符（Filtering Operators） 用于从 Observable 流中筛选出符合条件的数据，或者控制数据的流动节奏。


1. `filter`

    - **作用**：根据条件筛选发出的值，只有满足条件的值才会通过。  
    - **适用场景**：数据过滤（如只保留偶数、有效的用户输入）。

    ```javascript
    import { of } from 'rxjs';
    import { filter } from 'rxjs/operators';

    of(1, 2, 3, 4, 5).pipe(filter(x => x % 2 === 0))
    .subscribe(console.log);

    // 输出：
    // 2
    // 4
    ```

2. `take`

    - **作用**：只取前 `n` 个值，然后自动完成流。  
    - **适用场景**：限制数据量（如只获取前 3 次点击事件）。

    ```javascript
    import { interval } from 'rxjs';
    import { take } from 'rxjs/operators';

    interval(1000).pipe(take(3))
    .subscribe(console.log);

    // 输出：
    // 0（1秒后）
    // 1（2秒后）
    // 2（3秒后）
    // 流自动完成
    ```

3. `takeUntil`

    - **作用**：监听另一个 Observable，当它发出值时，终止当前流。  
    - **适用场景**：取消订阅（如组件销毁时停止定时器）。

    ```javascript
    import { interval, fromEvent } from 'rxjs';
    import { takeUntil } from 'rxjs/operators';

    const stopButton = document.getElementById('stop');
    const stop$ = fromEvent(stopButton, 'click');

    interval(1000).pipe(takeUntil(stop$))
    .subscribe(console.log);

    // 点击按钮后，定时器停止
    ```

4. `skip`

    - **作用**：跳过前 `n` 个值，从第 `n+1` 个值开始发出。  
    - **适用场景**：忽略初始数据（如跳过首次加载的缓存数据）。

    ```javascript
    import { of } from 'rxjs';
    import { skip } from 'rxjs/operators';

    of('A', 'B', 'C', 'D').pipe(skip(2))
    .subscribe(console.log);

    // 输出：
    // 'C'
    // 'D'
    ```

5. `debounceTime`

    - **作用**：防抖，仅在指定时间内没有新值时，才发出最新值。  
    - **适用场景**：搜索框输入防抖（避免频繁请求接口）。

    ```javascript
    import { fromEvent } from 'rxjs';
    import { debounceTime } from 'rxjs/operators';

    const input = document.getElementById('search');
    fromEvent(input, 'input').pipe(debounceTime(300))
    .subscribe(() => console.log('搜索:', input.value));

    // 输入停止 300ms 后触发
    ```


6. `throttleTime`

    - **作用**：节流，在指定时间内只发出第一个值，忽略后续值。  
    - **适用场景**：限制高频事件（如滚动事件）。

    ```javascript
    import { fromEvent } from 'rxjs';
    import { throttleTime } from 'rxjs/operators';

    fromEvent(window, 'scroll').pipe(throttleTime(1000))
    .subscribe(() => console.log('滚动事件（每秒最多触发一次）'));
    ```

7. `distinctUntilChanged`

    - **作用**：跳过连续重复的值，只有当前值与前一个值不同时才发出。  
    - **适用场景**：避免重复数据（如连续相同的按钮点击）。

    ```javascript
    import { of } from 'rxjs';
    import { distinctUntilChanged } from 'rxjs/operators';

    of(1, 1, 2, 2, 3, 2).pipe(distinctUntilChanged())
    .subscribe(console.log);

    // 输出：
    // 1
    // 2
    // 3
    // 2
    ```

8. `first` / `last`

    - **作用**：

        *   `first`：取第一个值（可加条件），然后完成。
        *   `last`：取最后一个值（可加条件），然后完成。
        

    ```javascript
    import { of } from 'rxjs';
    import { first, last } from 'rxjs/operators';

    of(1, 2, 3).pipe(first())
    .subscribe(console.log); // 输出：1

    of(1, 2, 3).pipe(last())
    .subscribe(console.log); // 输出：3
    ```


9. `sampleTime`

    - **作用**：定期采样，每隔一段时间发出当前的最新值（如果存在）。  
    - **适用场景**：周期性获取数据快照（如实时监控数据）。

    ```javascript
    import { interval } from 'rxjs';
    import { sampleTime } from 'rxjs/operators';

    interval(100).pipe(sampleTime(1000))
    .subscribe(console.log);

    // 每秒输出一个当前值（如 9, 19, 29...）
    ```

10. `auditTime`

    - **作用**：忽略指定时间内的值，只在时间窗口结束时发出最后一个值。  
    - **适用场景**：类似 `debounceTime`，但总是会发出最后一个值。

    ```javascript
    import { fromEvent } from 'rxjs';
    import { auditTime } from 'rxjs/operators';

    fromEvent(document, 'click').pipe(auditTime(1000))
    .subscribe(() => console.log('点击（1秒内最后一次）'));
    ```

11. **总结**

    | 操作符 | 作用  | 示例场景 |
    | --- | --- | --- |
    | `filter` | 按条件筛选值 | 过滤无效输入 |
    | `take` | 限制数据量 | 只取前 N 次事件 |
    | `takeUntil` | 监听信号终止流 | 组件销毁时取消订阅 |
    | `debounceTime` | 防抖控制 | 搜索框输入延迟触发 |
    | `throttleTime` | 节流控制 | 限制滚动事件频率 |
    | `distinctUntilChanged` | 跳过连续重复值 | 避免重复操作 |
    | `first` / `last` | 取第一个/最后一个值 | 快速获取特定数据 |
    | `sampleTime` | 定期采样 | 实时数据监控 |
    | `auditTime` | 时间窗口结束时发出最后一个值 | 高频事件处理 |



## 2.6 判断操作符


 **判断操作符（Conditional Operators）** 用于对 Observable 流中的数据进行条件判断或控制流的逻辑行为。以下是常见的判断操作符及其作用和示例：



1. `every`

    - **作用**：检查流中的所有值是否都满足指定条件，返回 `Observable<boolean>`。  
    - **适用场景**：验证所有数据是否符合条件（如表单全局校验）。



    ```javascript
    import { of } from 'rxjs';
    import { every } from 'rxjs/operators';

    of(2, 4, 6, 8)
    .pipe(every(x => x % 2 === 0))
    .subscribe(result => console.log('是否全为偶数？', result));

    // 输出：
    // true（因为所有值都是偶数）
    ```


2. `find` 和 `findIndex`

    - **作用**：
        *   `find`：查找第一个满足条件的值并发出，然后完成。  
        *   `findIndex`：返回第一个满足条件的值的索引。
            

    - **适用场景**：搜索特定数据（如查找数组中的第一个有效元素）。



    ```javascript
    import { of } from 'rxjs';
    import { find, findIndex } from 'rxjs/operators';

    of(10, 20, 30, 40)
    .pipe(find(x => x > 25))
    .subscribe(console.log); // 输出：30

    of(10, 20, 30, 40)
    .pipe(findIndex(x => x > 25))
    .subscribe(console.log); // 输出：2（索引值）
    ```

3. `isEmpty`

    - **作用**：检查 Observable 是否不发出任何值就完成，返回 `Observable<boolean>`。  
    - **适用场景**：判断空数据流（如 API 返回空响应）。

    ```javascript
    import { of, EMPTY } from 'rxjs';
    import { isEmpty } from 'rxjs/operators';

    EMPTY.pipe(isEmpty())
    .subscribe(console.log); // 输出：true（流为空）

    of(1).pipe(isEmpty())
    .subscribe(console.log); // 输出：false（流非空）
    ```

4. `defaultIfEmpty`

    - **作用**：如果流为空（不发出任何值），则发出一个默认值。  
    - **适用场景**：为空数据提供兜底值（如默认提示信息）。

    ```javascript
    import { EMPTY } from 'rxjs';
    import { defaultIfEmpty } from 'rxjs/operators';

    EMPTY.pipe(defaultIfEmpty('暂无数据'))
    .subscribe(console.log); // 输出：'暂无数据'
    ```

5. `sequenceEqual`

    - **作用**：比较两个 Observable 发出的值序列是否完全相同（包括顺序和值）。  
    - **适用场景**：数据一致性检查（如测试预期输出）。

    ```javascript
    import { of } from 'rxjs';
    import { sequenceEqual } from 'rxjs/operators';

    const source1$ = of(1, 2, 3);
    const source2$ = of(1, 2, 3);

    source1$.pipe(sequenceEqual(source2$))
    .subscribe(result => console.log('序列是否相同？', result));

    // 输出：
    // true（因为两个流的序列完全一致）
    ```

6. `iif`

    - **作用**：根据条件动态选择两个 Observable 中的一个进行订阅。  
    - **适用场景**：条件分支逻辑（如根据权限加载不同数据）。



    ```javascript
    import { iif, of } from 'rxjs';

    let isAdmin = true;
    const adminData$ = of('管理员数据');
    const userData$ = of('普通用户数据');

    iif( () => isAdmin, adminData$,userData$)
        .subscribe(console.log);

    // 输出：
    // '管理员数据'（因为 isAdmin 为 true）
    ```


7. `takeWhile` 和 `skipWhile`

    - **作用**：
        *   `takeWhile`：发出值直到条件不满足，然后完成。
        *   `skipWhile`：跳过值直到条件不满足，然后开始发出。
    - **适用场景**：条件控制数据流的截取或跳过。



    ```javascript
    import { of } from 'rxjs';
    import { takeWhile, skipWhile } from 'rxjs/operators';

    of(1, 2, 3, 4, 5).pipe(takeWhile(x => x < 4))
    .subscribe(console.log); // 输出：1, 2, 3（遇到4时停止）

    of(1, 2, 3, 4, 5).pipe(skipWhile(x => x < 3))
    .subscribe(console.log); // 输出：3, 4, 5（跳过1和2）
    ```


8. 总结

    | 操作符 | 作用  | 示例场景 |
    | --- | --- | --- |
    | `every` | 检查所有值是否满足条件 | 表单全局校验 |
    | `find` / `findIndex` | 查找第一个满足条件的值/索引 | 搜索数组中的特定元素 |
    | `isEmpty` | 判断流是否为空 | 处理空API响应 |
    | `defaultIfEmpty` | 为空时提供默认值 | 显示兜底提示信息 |
    | `sequenceEqual` | 比较两个流的序列是否相同 | 测试预期输出 |
    | `iif` | 条件选择不同的 Observable | 根据权限加载数据 |
    | `takeWhile` | 发出值直到条件不满足 | 截取有效数据 |
    | `skipWhile` | 跳过值直到条件不满足 | 忽略无效的初始数据 |