# 三、其他类型

## 3.1 pipe


RxJS 的 `pipe` 是 **链式调用操作符的核心方法**，用于将多个操作符按顺序组合起来，对 Observable 的数据流进行分步处理。它的作用类似于工厂的流水线，数据依次通过每个操作符的“加工”。

### 3.1.1 介绍

1.  **`pipe` 的作用**
    1.  **组合操作符**：将多个操作符（如 `map`、`filter`、`debounceTime`）按顺序连接。
    2.  **避免嵌套**：替代传统的嵌套式操作符调用，代码更易读。
    3.  **纯函数**：不会修改原始 Observable，而是返回一个新的 Observable。


2. **基础语法**

    ```typescript
    observable.pipe(
        operator1(),
        operator2(),
        operator3()
    ).subscribe(...);
    ```


### 3.1.2 示例场景与代码

1. 数据转换 + 过滤

    **场景**：从数字流中筛选偶数并翻倍。


    ```javascript
    import { of } from 'rxjs';
    import { filter, map } from 'rxjs/operators';

    const numbers$ = of(1, 2, 3, 4, 5);

    numbers$.pipe(
        filter(x => x % 2 === 0), // 筛选偶数
        map(x => x * 2)           // 翻倍
    ).subscribe(console.log);

    // 输出：
    // 4（2×2）
    // 8（4×2）
    ```



2. 防抖 + 异步请求

    **场景**：搜索框输入防抖后请求 API。

    ```javascript
    import { fromEvent } from 'rxjs';
    import { debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';

    const input = document.getElementById('search');

    fromEvent(input, 'input').pipe(
        debounceTime(300),          // 防抖 300ms
        map(event => event.target.value.trim()), // 提取输入值
        distinctUntilChanged(),      // 忽略重复值
        switchMap(query => fetch(`/api/search?q=${query}`)) // 切换为请求
    ).subscribe(response => {
        console.log('搜索结果:', response);
    });
    ```



3. 错误处理 + 重试

    **场景**：请求失败时重试 3 次。

    ```javascript
    import { ajax } from 'rxjs/ajax';
    import { retry, catchError } from 'rxjs/operators';

    ajax.getJSON('https://api.example.com/data').pipe(
        retry(3), // 失败时重试3次
        catchError(error => of({ status: 'error', message: '请求失败' })) // 兜底
    ).subscribe(console.log);
    ```



4. 多操作符组合

    **场景**：统计点击次数，但每秒最多统计一次。

    ```javascript
    import { fromEvent } from 'rxjs';
    import { scan, throttleTime } from 'rxjs/operators';

    fromEvent(document, 'click').pipe(
        throttleTime(1000),         // 节流（1秒内只取一次）
        scan(count => count + 1, 0) // 计数
    ).subscribe(count => {
        console.log(`点击次数: ${count}`);
    });
    ```





5. 高级用法：自定义操作符

    通过 `pipe` 可以封装自定义操作符：

    ```javascript
    import { pipe,of } from 'rxjs';
    import { map, filter } from 'rxjs/operators';

    // 自定义操作符：筛选偶数并翻倍
    const evenDouble = pipe(
        filter((x) => x % 2 === 0),
        map(x => x * 2)
    );

    of(1, 2, 3, 4).pipe(evenDouble).subscribe(console.log);
    // 输出：4, 8
    ```

6. **总结**

    | 场景  | 典型操作符组合 | 作用  |
    | --- | --- | --- |
    | 数据转换 | `map` + `filter` | 筛选并修改数据 |
    | 用户输入防抖 | `debounceTime` + `distinctUntilChanged` | 减少频繁触发 |
    | 错误处理 | `retry` + `catchError` | 自动重试或提供兜底数据 |
    | 异步控制 | `switchMap` + `throttleTime` | 取消旧请求或限制频率 |
    | 状态管理 | `scan` + `startWith` | 累积数据或初始化状态 |



## 3.2 异常处理

RxJS 提供了多种 **异常处理操作符**，用于捕获、处理或恢复 Observable 流中的错误。以下是常见的异常处理方式及其作用和示例：

1. `catchError`（捕获错误并恢复）

    -  **作用**：捕获错误，并返回一个新的 Observable 替代错误流。  
    - **适用场景**：API 请求失败时提供备用数据或重试。


    ```javascript
    import { of } from 'rxjs';
    import { ajax } from 'rxjs/ajax';
    import { catchError } from 'rxjs/operators';

    ajax.getJSON('https://api.example.com/data').pipe(
    catchError(error => {
        console.error('请求失败:', error);
        return of({ status: 'fallback', data: [] }); // 返回备用数据
    })
    ).subscribe(console.log);

    // 输出：
    // 如果请求成功：API 返回的数据
    // 如果请求失败：{ status: 'fallback', data: [] }
    ```

2. `retry`（自动重试）

    - **作用**：在发生错误时重新订阅 Observable，重试指定次数。  
    - **适用场景**：网络请求失败后自动重试。


    ```javascript
    import { ajax } from 'rxjs/ajax';
    import { retry } from 'rxjs/operators';

    ajax.getJSON('https://api.example.com/data').pipe(
        retry(3) // 失败时重试3次
    ).subscribe({
        next: data => console.log('成功:', data),
        error: err => console.error('重试3次后仍失败:', err)
    });

    // 输出：
    // 如果首次请求失败，会重试最多3次
    // 如果全部失败，最终抛出错误
    ```



3. `retryWhen`（按条件重试）**

    - **作用**：根据自定义逻辑控制重试（如延迟重试或条件触发）。  
    - **适用场景**：需要复杂重试策略（如指数退避）。


    ```javascript
    import { ajax } from 'rxjs/ajax';
    import { retryWhen, delay, mergeMap } from 'rxjs/operators';

    ajax.getJSON('https://api.example.com/data').pipe(
    retryWhen(errors => errors.pipe(
        mergeMap((error, attempt) => {
        if (attempt >= 2) throw error; // 最多重试2次
            return of(error).pipe(delay(1000)); // 延迟1秒后重试
        })
    ))
    ).subscribe(console.log);
    ```



4. `finalize`（最终处理）**

    - **作用**：无论流成功或失败，最终都会执行的回调。  
    - **适用场景**：清理资源（如隐藏加载动画）。


    ```javascript
    import { of } from 'rxjs';
    import { finalize } from 'rxjs/operators';

    of(1, 2, 3).pipe(
        finalize(() => console.log('清理资源（无论成功或失败）'))
    ).subscribe({
        next: console.log,
        error: () => console.error('出错')
    });

    // 输出：
    // 1
    // 2
    // 3
    // 清理资源（无论成功或失败）
    ```



5. `throwError`（主动抛出错误）**

    - **作用**：创建一个直接抛出错误的 Observable（RxJS 8+ 使用 `throw`）。  
    - **适用场景**：模拟错误或转换错误类型。


    ```javascript
    import { throwError } from 'rxjs';
    import { catchError } from 'rxjs/operators';

    throwError(() => new Error('自定义错误')).pipe(
        catchError(err => {
            console.error('捕获错误:', err.message);
            return of('备用数据');
        })
    ).subscribe(console.log);

    // 输出：
    // 捕获错误: 自定义错误
    // 备用数据
    ```



6. 全局错误处理（`subscribe` 的 `error` 回调）**

    - **作用**：在订阅时捕获未被操作符处理的错误。  
    - **适用场景**：全局错误上报或用户提示。


    ```javascript
    import { throwError } from 'rxjs';

    throwError(() => new Error('致命错误')).subscribe({
        next: () => console.log('不会执行'),
        error: err => console.error('全局捕获:', err.message),
        complete: () => console.log('不会执行')
    });

    // 输出：
    // 全局捕获: 致命错误
    ```



7. 组合使用示例**

    **错误重试 + 兜底数据 + 资源清理**

    ```javascript
    import { ajax } from 'rxjs/ajax';
    import { retry, catchError, finalize } from 'rxjs/operators';

    ajax.getJSON('https://api.example.com/data').pipe(
        retry(2), // 重试2次
        catchError(error => {
            console.error('最终失败:', error);
            return of({ data: '默认值' }); // 提供兜底数据
        }),
        finalize(() => console.log('请求结束（无论成功或失败）'))
    ).subscribe(console.log);
    ```

8. 总结

    | 操作符 | 作用  | 典型场景 |
    | --- | --- | --- |
    | `catchError` | 捕获错误并返回新 Observable | API 失败时返回缓存数据 |
    | `retry` | 自动重试指定次数 | 网络请求重试 |
    | `retryWhen` | 按条件控制重试逻辑 | 指数退避重试策略 |
    | `finalize` | 最终清理资源 | 隐藏加载动画、关闭连接 |
    | `throwError` | 主动抛出错误 | 模拟错误或转换错误类型 |
    | `subscribe` 的 `error` | 全局错误处理 | 错误上报或用户提示 |